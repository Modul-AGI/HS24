[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modul AGI",
    "section": "",
    "text": "Willkommen!\nWillkommen im Kurs Angewandte Geoinformatik an der Zürcher Hochschule für Angewandte Wissenschaften (ZHAW). Wir nutzen diese Plattform (modul-agi.github.io) um euch Zugriff auf unsere Übungsunterlagen und Theorieinputs zu gewährleisten.\nDer gesamte Quellcode um dieses Buch zu erstellen ist in dem folgenden github-repo verfügbar: github.com/Modul-AGI.",
    "crumbs": [
      "Willkommen!"
    ]
  },
  {
    "objectID": "A_Unsicherheit/2_Datengrundlage.html",
    "href": "A_Unsicherheit/2_Datengrundlage.html",
    "title": "Datengrundlage",
    "section": "",
    "text": "Layer\nDie Feature Class Tick_Original beinhaltet die Originalstandorte der via Zecken App gemeldeten Zeckenstiche im Raum Zürich aus dem Zeitraum März 2015 bis Juli 2019. Es handelt sich dabei um 1076 Meldungen. Die anderen 40 Feature Classes mit den Bezeichnungen Tick_Run_1 (bis …40) enthalten die mittels Zufall veränderten Positionen der Originalstandorte (vgl. Abschnitt Datenvorverarbeitung).\nDer Layer Wald_NichtWald beinhaltet die Waldausdehnung innerhalb des Untersuchungsraums. Die Daten stammen aus dem Landschaftsmodell swissTLM3D von swisstopo (Layer Bodenbedeckung).",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datengrundlage</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/2_Datengrundlage.html#layer",
    "href": "A_Unsicherheit/2_Datengrundlage.html#layer",
    "title": "Datengrundlage",
    "section": "",
    "text": "FC Wald_Nichtwald\n\nWald: 0 = Kein Wald / 1 = Wald\n\nFC Tick_Original\n\nID: ID Zeckenstichmeldung\nacc_: Zoomstufe in Karte während der Erfassung des Stiches in der App\nx_lv95: X Koordinate (CH1903+ LV95)\ny_lv95: Y Koordinate (CH1903+ LV95)\nRun_Nr: 0 (Original)\n\nFC Tick_Run_1 bis Tick_Run_40\n\nID: ID Zeckenstichmeldung (gleich wie in Original)\nacc_: Zoomstufe in Karte während der Erfassung des Stiches in der App (gleich wie in Original)\nx_lv95: X Koordinate (Originalstandort)\ny_lv95: Y Koordinate (Originalstandort)\nRun_Nr_x: X Zufallskoordinate Run Nr\nRun_Nr_y: Y Zufallskoordinate Run Nr\nRun_Nr: Nummer Zufallsdurchgang",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datengrundlage</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/3_Datenvorverarbeitung.html",
    "href": "A_Unsicherheit/3_Datenvorverarbeitung.html",
    "title": "Datenvorverarbeitung",
    "section": "",
    "text": "Übung 1: Daten erkunden und neues “Resultate” Feature Dataset erstellen\nDownloade das ArcGIS Pro Package von Moodle, speichere es lokal auf deinem Computer und entpacke die Datei. Öffne anschliessend das Projekt-File (*.aprx), erkunde die Daten und mache dich mit ihnen vertraut.\nErstelle anschliessend in der Projekt-Geodatenbank Unsicherheit.gdb ein neues Feature Dataset mit dem Namen “Resultate”. Weise dem neuen Feature Dataset das Koordinatensystem CH1903+ LV95 zu.\nIn diesem neuen Feature Dataset sollen nachfolgend alle neu erstellten (Zwischen-)Resultate abgelegt werden.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenvorverarbeitung</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "",
    "text": "Übung 2: Zusammenfügen (Append) aller Runs zu einem Datensatz\nKopiere zuerst die Feature Class Tick_Original in das Feature Dataset Resultate. Benenne die kopierte Feature Class in Tick_Append um, ändere auch den Alias. Nutze anschliessend das Geoverarbeitungswerkzeug “Append”, um die soeben kopierten Original-Standorte mit den Zeckenstichstandorten aller Runs zusammenzufügen. Wähle unter Field Matchig Type die Option “Use the field map to reconcile field differences”.\nÜberprüfe das Resultat. Die Tick_Append Feature Class sollte anschliessend 44’116 Features beinhalten.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-2-zusammenfügen-append-aller-runs-zu-einem-datensatz",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-2-zusammenfügen-append-aller-runs-zu-einem-datensatz",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "",
    "text": "ArcGIS Pro Help: Geoprocessing Tool Append\n\n\n\nhttps://pro.arcgis.com/en/pro-app/latest/tool-reference/data-management/append.htm",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-3-summe-der-stiche-innerhalb-der-waldfläche",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-3-summe-der-stiche-innerhalb-der-waldfläche",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 3: Summe der Stiche innerhalb der Waldfläche",
    "text": "Übung 3: Summe der Stiche innerhalb der Waldfläche\nUm zu überprüfen wie viele Stiche sich innerhalb des Waldes befinden, muss zunächst der Punktlayer mit den Stichdaten aller Runs und den Originaldaten (Resultat aus Übung 2) mit dem Wald-Layer überlagert werden. Hierbei bietet sich das Geoverarbeitungswerkzeug “Summarize Within” (GeoAnalytics Desktop Tools) an. Dieses Werkzeug zählt alle Punkte welche sich in den jeweiligen Flächen des Input-Polygons befinden. Ausserdem kann damit eine separate Output Tabelle (Output Grouped Table) generiert werden, welche für jeden Run angibt (Group Field = Run_Nr), wie viele Punkt pro Run inner- oder ausserhalb des Waldes liegen. Hinweis: Speichere die Output Grouped Table direkt auf Datenbank-Ebene und nicht im Feature Dataset Resultate. Ansonsten kann die Ausführung des Werkzeugs zu einem Fehler führen.\n\n\n\n\n\n\nArcGIS Pro Help: Geoprocessing Tool Summarize Within\n\n\n\nhttps://pro.arcgis.com/en/pro-app/latest/tool-reference/geoanalytics-desktop/summarize-within.htm\n\n\nÜberprüfe anschliessend die beiden generierten Outputs (Tabelle und Feature Class). Welche Informationen sind darin enthalten? Was bedeuten die Werte in den Feldern Join ID, Run_Nr und Count of Points innerhalb der Output Grouped Table?",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-4-prozentualer-anteil-der-stiche-innerhalb-des-waldes",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-4-prozentualer-anteil-der-stiche-innerhalb-des-waldes",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 4: Prozentualer Anteil der Stiche innerhalb des Waldes",
    "text": "Übung 4: Prozentualer Anteil der Stiche innerhalb des Waldes\nErweitere die Output Grouped Table (Resultat aus Übung 3) um ein Feld, in dem du anschliessend den prozentualen Anteil der Punkte pro Run innerhalb des Waldes berechnen kannst.\nHinweis: Pro Run gibt es 1076 Features\n\n\n\n\n\n\nArcGIS Pro Help: Calculate Field\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/data-management/calculate-field.htm",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-5-diagramm-bar-chart-mit-prozentualem-anteil-der-individuellen-runs",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-5-diagramm-bar-chart-mit-prozentualem-anteil-der-individuellen-runs",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 5: Diagramm (Bar Chart) mit prozentualem Anteil der individuellen Runs",
    "text": "Übung 5: Diagramm (Bar Chart) mit prozentualem Anteil der individuellen Runs\nErstelle zuerst eine Kopie der Output Grouped Table in der Projekt-Geodatenbank. Entferne nachfolgend in der soeben erstellten Kopie alle Records welche die Summen der Stiche ausserhalb des Waldes beinhalten.\nHinweis: beachte die Werte im Feld Join_ID\n\n\n\n\n\n\nArcGIS Pro Help: Select Layer By Attribute\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/data-management/select-layer-by-attribute.htm\n\n\nErstelle anschliessend ein Balkendiagramm welches die unterschiedlichen prozentualen Anteile der Stiche innerhalb des Waldes pro Run symbolisiert. Gehe hierfür in das Menüband “Standalone Table” und wähle “Create Chart”.\n\nBeachte die Werte und deren Spannweite. Was bedeuten die Werte? Was für Aussagen bezüglich Unsicherheit (Genauigkeit) können bei den Stichdaten gemacht werden?",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-6-berechnung-des-mittelwertes-aller-runs",
    "href": "A_Unsicherheit/4_Unsicherheit-Zeckenstandorte.html#übung-6-berechnung-des-mittelwertes-aller-runs",
    "title": "Unsicherheit der gemeldeten Zeckenstichstandorte",
    "section": "Übung 6: Berechnung des Mittelwertes aller Runs",
    "text": "Übung 6: Berechnung des Mittelwertes aller Runs\nNutze die Tabelle der in Übung 3 erstellten Feature Class und berechne den prozentualen Anteil aller Stiche (über alle Runs) welche sich innerhalb des Waldes befinden. Vergleiche diesen Wert mit dem Wert aus den Originaldaten.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unsicherheit der gemeldeten Zeckenstichstandorte</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html",
    "title": "Unschärfe des Waldrandes",
    "section": "",
    "text": "Übung 7: Waldrandlinie aus Waldpolygon erstellen\nDie Waldrandlinie kann mit Hilfe des Geoverarbeitungswerkzeug “Polygon to Line” hergeleitet werden. Überlege dir, ob vorgängig eine Selektion im Input Feature notwendig ist.\nBetrachte das Resultat und überlege dir wie genau die digitale Waldrandlinie dem Waldrand in der Realität entspricht? Kann das Objekt Waldrand überhaupt grenzscharf abgebildet werden (vgl. rote Linie in Abbildung)?",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-7-waldrandlinie-aus-waldpolygon-erstellen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-7-waldrandlinie-aus-waldpolygon-erstellen",
    "title": "Unschärfe des Waldrandes",
    "section": "",
    "text": "ArcGIS Pro Help: Polygon To Line\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/data-management/polygon-to-line.htm\n\n\n\n\n\n\n\n\n\nAbbildung 4.1: Rote Linie: abgeleitete Waldrandlinie / orange Punkte: Stichstandorte original / blaue Punkte: Stichstandorte 40 Monte Carlo Runs",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-8-waldrandbereich-festlegen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-8-waldrandbereich-festlegen",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 8: Waldrandbereich festlegen",
    "text": "Übung 8: Waldrandbereich festlegen\nWir gehen davon aus, dass ein Waldrand kaum mit einer grenzscharfen Linie repräsentiert werden kann. In der Realität entspricht ein Waldrand wohl eher einem bestimmten Bereich. Der Waldrand an sich hat eine Unschärfe (Vagueness). In der GIS-Welt wird eine solche Unschärfe oft mit einem Puffer mit einem zu definierenden Abstand zu einer Linie (Waldrandlinie) abgebildet.\nErstelle basierend auf der in Übung 7 erstellten Waldrandlinie nun den Waldrandbereich mit einem äusseren und inneren Abstand von 25 Metern. Benutze hierfür das dir bereits bekannte Geoverarbeitungswerkzeug “Buffer”. Achte bei der Umsetzung auf die korrekte Festlegung der Werkzeugparameter.\n\n\n\n\n\n\nArcGIS Pro Help: Buffer\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/analysis/buffer.htm\n\n\nOptional Analog wie in Übungen 3 bis 5 könntest du nun untersuchen, welchen Einfluss die Unschärfe des Waldrandes darauf hat, ob Zeckenstichstandorte im Waldrandbereich liegen oder nicht.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-9-distanz-zu-waldrandlinie-berechnen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-9-distanz-zu-waldrandlinie-berechnen",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 9: Distanz zu Waldrandlinie berechnen",
    "text": "Übung 9: Distanz zu Waldrandlinie berechnen\nNun wollen wir diese Unschärfe des Konzepts Waldrand noch erweitern und die grenzscharfe Pufferdistanz aus der vorigen Übung mit einer graduellen Zugehörigkeit (membership function) ersetzen. Hierfür sollen folgende Fuzzy Tallness Werte definiert werden (vgl. Abbildung): Abstand zu Waldrandlinie:\n\n10 Meter = 1\n10 bis 20 = 0.7\n20 bis 30 = 0.4\n&gt; 30 Meter = 0\n\n\nBerechne nun als ersten Schritt für den gesamten Untersuchungsraum den Abstand zur nächstgelegenen Waldrandlinie. Nutze hierfür das Geoverarbeitungswerkzeug “Euclidean Distance”. Lege die Output Cell Size auf 1 Meter fest und definiere in den Environments das Output Coordinate System und den Raum in dem diese globale Rasterfunktion ausgeführt wird (Extent = Untersuchungsgebiet).\n\n\n\n\n\n\nArcGIS Pro Help: Euclidean Distance\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/euclidean-distance.htm\n\n\nDie Ausführung dieser Rasterfunktion kann einige Minuten dauern.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-10-zuweisung-der-fuzzy-tallness-werte",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-10-zuweisung-der-fuzzy-tallness-werte",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 10: Zuweisung der Fuzzy Tallness Werte",
    "text": "Übung 10: Zuweisung der Fuzzy Tallness Werte\nJeder Zelle mit einem Distanzwert soll nun ein Fuzzy Tallness Wert gemäss Abbildung in Übung 9 zugeteilt werden. Verwende hierfür das Geoverarbeitungswerkzeug “Reclassify”.\n\n\n\n\n\n\nArcGIS Pro Help: Reclassify\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/reclassify.htm\n\n\nBeim Reklassifizieren können den neuen Werten nur ganzzahlige Werte zugeteilt werden. Verwende deshalb die Werte 100, 70, 40 und 0 statt 1, 0.7, 0.4 und 0. Nutze anschliessend zuerst das Werkzeug “Float” und dann “Divide” um die ganzzahligen Werte wieder in Kommawerte umzurechnen.\n\nFloat\nDivide",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-11-unschärfe-werte-den-stichstandorten-zuweisen",
    "href": "A_Unsicherheit/5_Unschaerfe-des-Waldrandes.html#übung-11-unschärfe-werte-den-stichstandorten-zuweisen",
    "title": "Unschärfe des Waldrandes",
    "section": "Übung 11: Unschärfe-Werte den Stichstandorten zuweisen",
    "text": "Übung 11: Unschärfe-Werte den Stichstandorten zuweisen\nDie für jede Zelle definierten Unschärfe-Werte (membership zum Waldrand) werden nun den Daten mit den Stichstandorten zugeteilt. Dies erfolgt mittels “Extract Values to Points”.\n\n\n\n\n\n\nArcGIS Pro Help: Extract Values to Points\n\n\n\nhttps://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/extract-values-to-points.htm\n\n\nDabei sollen die Unschärfe-Werte (1 / 0.7 / 0.4 / 0) vorerst nur den Original-Stichstandortdaten zugeteilt werden (Input point feature = Tick_Original). Erstelle eine grafische Visualisierung (bsp. Histogramm).\nBeantworte anschliessend folgende Fragen:\nWie viele Zeckenstiche im Original-Datensatz verfügen über Waldrand Unschärfe-Werte von 1, 0.7, 0.4 und 0 und welche Aussage kannst du damit machen?",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Unschärfe des Waldrandes</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html",
    "href": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html",
    "title": "Automatisierung mit ModelBuilder",
    "section": "",
    "text": "Übung 12: Waldrand-Fuzzy-Modell in ModelBuilder erstellen\nErstelle ein Modell mit ModelBuilder in dem die 5 Prozesse von Übung 9 bis 11 automatisiert ausgeführt werden können. Das Modell kann anschliessend wie ein normales Werkzeug aufgerufen werden. Als Modellparameter müssen die Fuzzy Tallness Distanzen resp. Werte angepasst sowie ein neuer Output Datensatz erstellt werden können.\nVorgehen:\nMit Hilfe von solchen Modellen kannst du deine Geoverarbeitungsketten auf einfache Art und Weise automatisieren ☺.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Automatisierung mit ModelBuilder</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html#übung-12-waldrand-fuzzy-modell-in-modelbuilder-erstellen",
    "href": "A_Unsicherheit/6_Automatisieren-Modelbuilder.html#übung-12-waldrand-fuzzy-modell-in-modelbuilder-erstellen",
    "title": "Automatisierung mit ModelBuilder",
    "section": "",
    "text": "Gehe in das Menüband “Analysis”.\nWähle den Button ModelBuilder. Damit wird ein neues, noch leeres Modell erstellt.\nGehe in das Catalog Pane und navigiere zu “Toolboxes &gt; Unsicherheit.tbx” und benenne das Modell sinnvoll (Name und Label). Hinweis: keine Sonderzeichen und Leerschläge erlaubt.\nGehe im Catalog Pane in das Register “History”.\nFüge die letzten 5 Prozesse (Übungen 9 bis 11) nacheinander mittels Drag und Drop dem neuen Modell hinzu.\nKlicke im Modell mit rechter Maustaste auf das Tool Reclassify und wähle im Kontextmenü Create Variable &gt; From Parameter &gt; Reclassification\nKlicke mit rechter Maustaste auf die soeben erstellte Modellvariable und wähle im Kontextmenü “Parameter”. Diese Modellvariable erscheint nun beim Aufrufen des Modells als veränderbarer Parameter, d.h. die Fuzzy Tallness Distanzen und Werte können angepasst werden.\nKlicke mit rechter Maustaste auf den Final Output und definiere ihn ebenfalls als Modellparameter.\nSpeichere das Modell via Menüband ModelBuilder &gt; Save\nGehe im Catalog auf Toolboxes &gt; Unsicherheit.tbx &gt; und öffne dein Modell mittels Doppelklick.\nGebe die Modellparameter ein (Fuzzy Tallness Distanzen & Werte und Output Dataset) und führe das Modell mit Run aus.",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Automatisierung mit ModelBuilder</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/7_Leistungsnachweis.html",
    "href": "A_Unsicherheit/7_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Als Leistungsnachweis wird eine schriftliche Dokumentation der Lösung dieser Übung erwartet. Die Dokumentation sollte vier A4-Seiten nicht überschreiten und muss Folgendes beinhalten:\n\nName und Vorname der Autorin oder des Autors.\nResultate der Übung aufbereitet mittels ansprechenden Grafiken, Tabellen und evtl. Karten.\nBeantwortung der in dieser Übung enthaltenen Fragen.\nKurze Diskussion der Resultate.\nBeschreibung des ModelBuilder Modells inklusive:\n\nGrafische Abbildung des ModelBuilder Modells\nWelche Modellparameter wurden definiert und weshalb\nStichwortartige Beschreibung was das Modell berechnet\n\n\nAbgabeform und -termin\nLade deine vollständige Dokumentation spätestens bis Freitag 6. Oktober 2023 als PDF über Moodle hoch (Abgabe Leistungsnachweis Datenqualität und Unsicherheit).",
    "crumbs": [
      "Unsicherheit",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/2_Uebung.html",
    "href": "B_Datenbanken_1/2_Uebung.html",
    "title": "Übung",
    "section": "",
    "text": "Anforderungen Pflanzendatenbank\nSie sind ein Datenbank-Spezialist und werden vom Garten-Team der ZHAW beauftragt eine Datenbanklösung zur Pflege und Verwaltung der Pflanzenwelt auf dem Areal des Campus Grüental zu entwickeln. Hierbei sollen alle Pflanzen des Campus katalogisiert und für verschiedene Nutzergruppen über differenzierte Zugriffsmöglichkeiten mit verschiedenen Informationen zugänglich gemacht werden.\nHierbei müssen folgende Anforderungen eingehalten werden:\nDie Pflanzen müssen mit Familie, Gattung, Art und Sorte erfasst werden. Zusätzlich braucht es Informationen darüber, ob es sich um eine einheimische Pflanze handelt oder nicht. Als weitere Information muss es die Möglichkeit geben die Wuchsform, wie z.B. Staude, Strauch oder Baum zu erfassen. Zu einigen Pflanzen sollen Hinweise zur Pflege oder sonstige Bemerkungen eingegeben werden können.\nZu Lernzwecken sollen Pflanzen verschiedenen Pflanzenlernparcours zugeordnet werden können. Hierzu werden einzelne Pflanzen ausgewählt und einem Kurs zugeordnet. Jede Pflanze kann dabei zu verschiedenen Lernparcours gehören und ein Lernparcours kann unterschiedlich viele Pflanzen beinhalten.\nJede Pflanze auf dem Campus muss verortet werden. Dies bedeutet, dass jeder Pflanze auf dem Campus eine genaue Lage zugewiesen werden kann. Es reicht in dieser ersten Version aus die jeweilige Pflanze als Punkt darzustellen. Flächenartige Gewächse wie Stauden oder Gräser können als Punkt zusammengefasst werden. Linienartige Pflanzen wie Hecken können vernachlässigt werden und brauchen nicht aufgenommen zu werden. Für jede Pflanze ist zusätzlich zur genauen (Punkt-)Lage wichtig zu wissen auf welcher gärtnerischen Fläche (Beet) sich die Pflanze befindet. Zur besseren Planung müssen die Gärtner später abfragen können, welche Pflanzen auf welchem Beet stehen. Für die Flächen ist es ausreichend einen Namen und eine ID zu erfassen.",
    "crumbs": [
      "Datenbanken I",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/2_Uebung.html#aufgabenstellung",
    "href": "B_Datenbanken_1/2_Uebung.html#aufgabenstellung",
    "title": "Übung",
    "section": "Aufgabenstellung",
    "text": "Aufgabenstellung\n\nSchritt 1\nLesen Sie die Aufgabenstellung gewissenhaft. Skizzieren Sie ein erstes Textmodell (stichwortartig) bei welchem Sie bereits erste Objekte identifizieren und Attribute und Beziehungen ableiten. Überlegen Sie sich, ob es offene Fragen oder Unklarheiten gibt. Sie haben anschliessend die Gelegenheit den Auftraggeber über eventuell ungeklärte Anforderungen zu befragen, um ihr Textmodell zu vervollständigen.\n\n\nSchritt 2 (optional)\nSind alle offenen Fragen geklärt und das Textmodell fertig, entwickeln Sie aus ihrem Textmodell ein konzeptuelles Modell. Identifizieren Sie alle notwendigen Objekte mit den zugehörigen Attributen und zeigen Sie die Kardinalitäten der Objekte untereinander auf. Nutzen Sie hierbei die ER-Modellierung, wie in den Vorlesungsfolien aufgezeigt.\n\n\nSchritt 3\nZum Abschluss erstellen Sie auf der Grundlage ihres konzeptuellen Modells das erforderliche logische Modell. Leiten Sie aus den identifizierten Objekten, Attributen und Kardinalitäten die benötigten Tabellen und Schlüsselattribute ab. Achten Sie im Speziellen darauf wo es räumliche Tabellen sind und wo es sich um Sachdatentabellen handelt. Markieren Sie ausserdem auch alle Schlüssel-Attribute (Primärschlüssel und Fremdschlüssel).",
    "crumbs": [
      "Datenbanken I",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/2_Uebung_Datenintegritaet.html",
    "href": "B_Datenbanken_2/2_Uebung_Datenintegritaet.html",
    "title": "Datenintegrität",
    "section": "",
    "text": "Übung 1: Datenintegrität und Konsistenz\nSie haben den Auftrag ein Datenmodell zur Speicherung von unterschiedlichen Sozialen Schlüssel-Indikatoren für schweizerische Gemeinden zu überprüfen. Hierbei werden jedes Jahr Datenwerte auf Basis einer Gemeinde erhoben. Diese sollen später in der Datenbank gespeichert und ausgewertet werden können. Wichtig hierbei ist, dass die Daten später in einer Karte visualisiert werden können. Deshalb ist es notwendig, dass Gemeinde-Geometrien ebenfalls in der Datenbank gespeichert werden sollen. Ebenfalls ist es sinnvoll bestimmte Indikatoren auch für den gesamten Kanton hochzurechnen, damit diese als Karte dargestellt werden können. Sie bekommen als erste Grundlage folgendes Datenbankmodell vom Auftraggeber gestellt. Leider gibt es in diesem Modell ein paar Konsistenzfehler.\nUntersuchen Sie das Datenmodell auf Konsistenzfehler und korrigieren Sie diese. Lesen Sie den Aufgabentext aufmerksam und schauen sich die Abbildung an und entwickeln Sie daraus ein passendes logisches Datenmodell, welches alle Regeln der Datenintegrität einhält. Es muss nicht perfekt sein. Es geht in dieser Übung darum etwas Erfahrung im Lesen von gegebenen Modellen zu bekommen.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenintegrität</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "",
    "text": "Übung 2: Datenbankverbindung zum Server in pgAdmin herstellen\nIn den nächsten Übungen wollen wir eine Beispiel Datenbank mit dem dort bereits implementierten Datenbankmodell abfragen. Hierzu müssen wir in einem ersten Schritt eine Verbindung zum PostgreSQL/PostGIS Datenbankserver herstellen. Hierfür nutzen wir das Datenbank-Administrations-Werkzeug pgAdmin.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-2-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-2-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "",
    "text": "Starten Sie pgAdmin.\nIm Dashboard klicken Sie auf NEW Server und geben die folgenden Verbindungsparameter ein:\nRegister General: Name: svma-s-01323_waelder_studentNr. Verwenden Sie dabei die Nr. Ihres zugewiesenen Benutzers (siehe Abbildung 9.1)\nRegister Connection (siehe Abbildung 9.2):\n\nHost name/address: svma-s-01323.zhaw.ch\nPort: 5432\nMaintenance database: waelder\nUsername: studentNr (Verwenden Sie hier Ihren zugewiesenen Anmeldenamen)\nPasswort: (Verwenden Sie hier Ihr zugewiesenes Passwort)\n\nAlle anderen Einstellungen können belassen werden. Speichern Sie mit Klick auf Save.\nLassen Sie sich nicht davon verunsichern, dass es bereits einige Einträge hat. Da auf dem Server bereits andere Datenbanken installiert sind, sehen Sie auch diese. Navigieren Sie zu unserer Datenbank “waelder” und verschaffen sich einen Überblick über die vorhandenen Tabellen.\nVerwenden Sie für alle folgenden Übungen diese Datenbankverbindung, wenn nichts anderes angegeben ist (siehe Abbildung 9.2).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.1: PG Admin Oberfläche\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.2: PG Admin Connection",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-3-verbindung-zur-postgresqlpostgis-datenbank-mit-arcgis-pro-herstellen",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-3-verbindung-zur-postgresqlpostgis-datenbank-mit-arcgis-pro-herstellen",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 3: Verbindung zur PostgreSQL/PostGIS Datenbank mit ArcGIS Pro herstellen",
    "text": "Übung 3: Verbindung zur PostgreSQL/PostGIS Datenbank mit ArcGIS Pro herstellen\nNachdem die Datenbank erstellt wurde und eine Verbindung über pgadmin eingerichtet wurde, benötigen wir auch eine Verbindung von ArcGIS Pro zu der Datenbank.\n\nStarten Sie ArcGIS Pro und erstellen ein neues Projekt mit dem Namen “Datenbankzugriff”\nÖffnen Sie das Catalog-Fenster oder das Register Catalog und wählen Sie “Databases” (siehe Abbildung 9.3).\nIm Kontextmenü (rechte Maustaste) kann eine neue Datenbankverbindung zur Server Datenbank hergestellt werden.\n\nDatabases→Kontextmenü→New Database Connection\n\nGeben Sie im Database Connection Fenster die notwendigen Verbindungsparameter ein (siehe Abbildung 9.4).\n\nDatabase Platform: PostgreSQL\nInstance: svma-s-01323.zhaw.ch\nAuthentication Type: Database authentication\nUser Name: studentNr (Verwenden Sie hier Ihren zugewiesenen Anmeldenamen)\nPassword: (Verwenden Sie hier Ihr zugewiesenes Passwort)\nDatabase: waelder\n\nEin Klick auf OK stellt die Verbindung zur Datenbank her.\nSie können der Datenbankverbindung noch einen sinnvollen Namen geben. Es empfiehlt sich eine Kombination aus dem Servernamen, der verbundenen Datenbank und dem Benutzer. Z.B. “svma-s-01323_waelder_student1”\nUnter dem Eintrag “Databases” im Catalog gibt es jetzt eine neue Datenbankverbindung zur Datenbank (siehe Abbildung 9.5).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.3: Neue Datenbankverbindung in ArcGIS Pro\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.4: Notwendige Verbindungsparameter eingeben\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.5: Neue Datenbankverbindung ist erstellt",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-4-datenbank-schemata-für-arcgis-pro-benutzer",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-4-datenbank-schemata-für-arcgis-pro-benutzer",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 4: Datenbank Schemata für ArcGIS Pro Benutzer",
    "text": "Übung 4: Datenbank Schemata für ArcGIS Pro Benutzer\nNachdem die Datenbank erstellt wurde und alle Verbindungen eingerichtet sind, ist die Datenbank startklar. ArcGIS pro nutzt für die Daten jeweils ein eigenes Schema. Das Schema hat dabei den Namen des Datenbank Admin Users.\n\nNutzen Sie wieder die Verbindung mit der Datenbank “waelder” in pgAdmin und öffnen Sie die Inhalte/Eigenschaften mit Klick auf den kleinen Pfeil.\nNavigieren Sie zum Eintrag Schemas. Dort sind 4 Einträge zu sehen. Ein Schema ist eine Art abgeschlossener Namensraum für die Datenhaltung. Es empfiehlt sich thematisch zusammenpassende Tabellen in einem gemeinsamen Schema zu speichern. Für die meisten Datenbank-Anwendungen genügt es aber alle Tabellen im default Schema “public” zu erstellen. Für den Zugriff über ArcGIS wurde aber durch das Werkzeug “Create Database User” ein spezielles Schema mit dem Namen des Database Users erstellt. Dies ist notwendig damit auch ArcGIS Pro auf die Daten zugreifen und diese verwalten kann. Das entsprechende Schema bekommt dabei immer den Namen des Admin Datenbankbenutzers. In diesem Fall “arcgispro_editor”. Sie können dort z.B. auch ein Schema mit Namen “sde” vom Geodatenbank-Administrator sehen (siehe Abbildung 9.6).\nÖffnen Sie das public Schema. Hier gibt es bereits Einträge. Hier werden die zugehörigen Informationen der Datenbank, wie Sichten, Funktionen usw. zugänglich gemacht. Interessant ist zunächst aber nur der Eintrag “Tables (3)”. In Klammern ist immer die Anzahl der vorhandenen Datenbanktabellen angegeben. Wie wir sehen, gibt es default-Tabellen, welche bereits erstellt wurden. Die Tabelle “spatial_ref_sys” enthält z.B. alle Koordinatensysteme. Die Tabelle “sde_spatial_references” ist eine Hilfstabelle für Koordinatensysteme von ArcGIS Pro. Löschen Sie diese beiden Tabellen NIEMALS. Ohne diese Tabellen sind bestimmte Funktionen nicht mehr ausführbar (siehe Abbildung 9.7)\n\n\n\n\n\n\n\nTipp\n\n\n\nDer Name des Schemas muss in zukünftigen Abfragen immer dem Tabellennamen vorangestellt werden, damit klar ist aus welchem Schema abgefragt werden soll.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nFalls Sie einmal eigene Tabellen erstellen sollten: Es empfiehlt sich alle räumlichen Tabellen direkt in ArcGIS Pro zu erstellen. Dadurch entscheidet ArcGIS Pro selbstständig über die korrekten Datentypen und Geometrietypen. Alle anderen Tabellen sowie Fremdschlüssel usw. können auch in pgadmin erstellt werden. Alle Tabellen wurden im ArcGIS Pro Schema “arcgispro_editor” erstellt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.6: PG Admin Schemas\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.7: PG Admin Tables",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-5-datenbankschema-prüfen",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-5-datenbankschema-prüfen",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 5: Datenbankschema prüfen",
    "text": "Übung 5: Datenbankschema prüfen\nFür die kommenden Übungen nutzen wir die Datenbank “waelder” auf unserem Server. Den Zugriff haben wir in den vorigen Übungen eingerichtet. Um einen Überblick zu bekommen, lesen Sie das folgende Datenbankschema und machen sich mit den Tabellen, Attributen und Abhängigkeiten vertraut. Da Sie jetzt alle gemeinsam dieselben Tabellen bearbeiten, gibt es in jeder Tabelle jeweils ein Feld “id_erfasser”. Sobald Sie Tabellen mit Daten befüllen, schreiben Sie bitte immer jeweils Ihre studentNr in das Feld “id_erfasser”, damit die Einträge später unterscheidbar sind.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-6-datenimport-in-die-datenbank-über-pgadmin",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-6-datenimport-in-die-datenbank-über-pgadmin",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 6: Datenimport in die Datenbank über pgAdmin",
    "text": "Übung 6: Datenimport in die Datenbank über pgAdmin\nDa jetzt alle Tabellen vorliegen sollen diese noch mit ein paar Beispiel-Daten gefüllt werden. Auch hier bietet es sich an räumliche Objekte (Geometrien) mit Hilfe von ArcGIS Pro zu erfassen. Nicht-räumliche Objekte können meist sogar schneller über SQL importiert werden.\n\nSuchen Sie in der Datenbank “waelder” das schema “arcgispro_editor”.\nÖffnen Sie anschliessend den SQL Editor von pgadmin. Sie finden das so genannte Query Tool im Kontextmenü des Schemas oder in der Menüleiste oben unter Tools→Query Tool\nImportieren Sie mit Hilfe eines SQL Statements eine Tierart in die Tabelle “tierarten”.\nDa Sie jetzt alle gemeinsam und gleichzeitig Daten in dieselbe Tabelle einfüllen und Sie die Einträge noch unterscheiden wollen, fügen Sie unter id_erfasser jeweils ihre zugewiesene studentNr (nur die Zahl) ein.\nBenutzen Sie dazu das INSERT Statement und tippen es in das Query Tool (siehe Abbildung 9.8)\n\n   INSERT INTO arcgispro_editor.tierarten (id_tierart, name_tierart, id_erfasser) \n   Values (DEFAULT, 'Bär', studentNr);\nSchliessen Sie die Eingabe mit Klick auf Execute ab.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDEFAULT ist ein SQL Befehlswort, welches den Zähler für die id_tierart automatisch auf den nächsten freien Wert setzt. So kann die id_tierart automatisch fortlaufend hochnummeriert werden. Sie dürfen gern ein eigenes Tier in die Datenbank einfüllen.\nAchten Sie darauf, dass Text immer in einfache Anführungszeichen (Das Zeichen auf der ?- Taste) gesetzt werden muss. Bei Copy & Paste aus Dateien wird oft das Anführungszeichen verändert.Beachten Sie ausserdem die Punktschreibweise, dabei muss der Name des Schemas “arcgispro_editor” immer mit Punkt verbunden vor dem Namen der Tabelle angegeben werden. Jedes Statement wird mit Semikolon abgeschlossen.\n\n\n\nLassen Sie sich den Inhalt der Tabelle ausgeben. Dies können Sie über ein SELECT SQL Statement ausführen (siehe Abbildung 9.9).\n\n   SELECT * FROM arcgispro_editor.tierarten;\n\nSie können erkennen, dass ihr Tier mit Ihrer studentNr als id_erfasser in die Tabelle eingetragen wurde. Vermutlich sehen Sie auch bereits Einträge Ihrer Mit-Studierenden.\nNavigieren Sie im Object Explorer von pgAdmin zur Tabelle “tierarten”.\nÜber das Kontextmenü können ebenfalls die Inhalte der Tabelle angezeigt werden (siehe Abbildung 9.10).\n\nTabelle “tierarten”→Kontextmenü→View/Edit Data→All Rows\n\nEs öffnet sich automatisch das Query Tool und die Inhalte der Tabelle werden angezeigt.\n\n\n\n\n\n\n\nTipp\n\n\n\nAuf diese Weise kann immer nur die komplette Tabelle angezeigt werden. Filter oder sonstige Einschränkungen müssen als SQL Statement abgesetzt werden.\n\n\n\n\n\n\n\n\nAbbildung 9.8: Insert Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.9: Select Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.10: Überprüfen der Tabelleninhalte",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-7-datenimport-in-die-datenbank-mit-einer-sql-datei",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-7-datenimport-in-die-datenbank-mit-einer-sql-datei",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 7: Datenimport in die Datenbank mit einer SQL-Datei",
    "text": "Übung 7: Datenimport in die Datenbank mit einer SQL-Datei\nJedes SQL Statement kann in einer Datei abgespeichert werden. Dadurch lassen sich bequem z.B. gleich mehrere Daten in die Datenbank einlesen.\n\nBleiben Sie in der Datenbank “waelder” im schema “arcgispro_editor”.\nÖffnen Sie das Query Tool.\nLaden Sie die Datei “tierarten.sql” aus dem Moodle und speichern Sie in Ihrem Ordner.\nÖffnen Sie die Datei in einem beliebigen Texteditor und ändern das Wort “studentNr” in Ihre studentNr ab. Denken Sie sich ausserdem ein paar eigene/andere Tierarten aus und schreiben diese ebenfalls in die Datei (siehe Abbildung 9.11).\nÜber das kleine Ordner Symbol (Im Menü des Query Tools links oben) kann eine SQL-Datei geladen werden. Laden Sie die geänderte “tierarten.sql” Datei in pgAdmin.\nDie Auswahl lädt den Inhalt der Datei ins Query Tool (siehe Abbildung 9.12).\nSchliessen Sie die Eingabe mit Klick auf Execute ab.\nSchauen Sie sich erneut den Inhalt der Tabelle “tierarten” an. Die Tabelle sollte jetzt die eigenen Tierarten plus ein paar Einträge Ihrer Mit-Studierenden enthalten.\n\n\n\n\n\n\n\nTipp\n\n\n\nDa der Primärschlüssel der Tabelle nur auf id_tierart gesetzt ist und wir alle zusammen auf derselben Tabelle arbeiten, gibt es einige Tierarten bestimmt doppelt. Das ist normal.\n\n\n\n\n\n\n\n\nAbbildung 9.11: Insert statments\n\n\n\n\n\n\n\n\n\nAbbildung 9.12: Query tool",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-8-geometrieimport-in-die-datenbank",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-8-geometrieimport-in-die-datenbank",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 8: Geometrieimport in die Datenbank",
    "text": "Übung 8: Geometrieimport in die Datenbank\nHerkömmliche GIS Methoden zum Erstellen und Importieren von Geometrien ins GIS sollten Ihnen aus dem GIS Basic Modul bereits bekannt sein. Auch in ArcGIS Pro können Geometrien z.B. über ein Shapefile in eine Geodatenbank importiert werden. Ausserdem können Geometrien z.B. aus einem Luftbild digitalisiert und direkt in der Geodatenbank gespeichert werden.\n\nLaden Sie die Datei “waelder.zip” aus dem Moodle und entpacken Sie die Dateien. Es handelt sich um ein Shapefile mit einigen Wäldern.\nStarten Sie ArcGIS Pro und laden das Projekt “Datenbankzugriff”.\nFügen Sie das Shapefile ein und erfassen Sie mit dem Digitalisierungsmöglichkeiten von ArcGIS Pro zusätzlich ein paar eigene fehlende Wälder.\nÖffnen Sie die Attributtabelle.\nErfassen Sie im Feld “id_erfasser” wiederum Ihre zugewiesene studentNr (Nur die Zahl). Alle weiteren Attribute können Sie beliebig erfassen. Denken Sie sich einfach etwas aus.\nImportieren Sie die Daten anschliessend folgendermassen in die Feature Class “waelder” in der Datenbank auf dem Server.\nKontextmenü der Feature Class “waelder”→Load Data. Es öffnet sich das Werkzeug “Append” (siehe Abbildung 9.13)\n\nInput Dataset: Shapefile “waelder”\nTarget Dataset: waelder.arcgispro_editor.waelder\nField Matching Type: Use the Field Map to reconcile schema differences. Shapefiles können nur Spaltenbezeichnungen mit 10 Zeichen speichern. Alles andere wird abgeschnitten. Das Attribut “beschreibung” ist deshalb in der Datenbank als “beschreibung” gespeichert, im Shapefile aber nur als “beschreibu”. Dies hat zur Folge, dass das Schema beider Feature Classes nicht gleich ist. Aus diesem Grund muss hier explizit die Übereinstimmung der Spalten bestimmt werden. Das gleiche gilt für das Feld “id_erfasser” bzw. “id_erfasse” (siehe Abbildung 9.14).\n\nErstellen Sie eine neue Karte in ArcGIS Pro und laden Sie die Feature Class “waelder” aus der Server Datenbank.\nSie haben jetzt die Wälder in die Datenbank importiert.\nSchauen Sie sich die Wälder auch in pgAdmin an. Machen Sie hierzu eine Select Abfrage im Query Tool. In der Ergebnis Tabelle sehen Sie in der Geometry-Spalte ein kleines Karten-Symbol (View all Geometries in this column). Dies öffnet den “Geometry Viewer”. Sie sollten auch dort die Geometrien der importierten Wälder sehen (siehe Abbildung 9.15).\n\n\n\n\n\n\n\nTipp\n\n\n\nDa wir jetzt alle unsere Wälder in dieselbe Datenbank laden, sind natürlich einige Wälder doppelt vorhanden. Dies ist für unser Vorhaben aber nicht weiter schlimm.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.13: Load data\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.14: Geoprocessing Append\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 9.15: GIS GUI mit Wälder",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-9-geometrieimport-in-die-datenbank-mit-sql-datei",
    "href": "B_Datenbanken_2/3_Uebung_Server_Datenbanken.html#übung-9-geometrieimport-in-die-datenbank-mit-sql-datei",
    "title": "Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin",
    "section": "Übung 9: Geometrieimport in die Datenbank mit SQL-Datei",
    "text": "Übung 9: Geometrieimport in die Datenbank mit SQL-Datei\nAuch Geometrien können ebenso wie Sachdaten über eine SQL-Datei in die Datenbank kopiert werden.\n\nLaden Sie die Datei “sichtungsmeldungen.sql” aus dem Moodle. Es handelt sich um eine SQL-Datei mit Sichtungsmeldungen von Tieren.\nÖffnen Sie die Datei in einem beliebigen Texteditor. Was sehen Sie? Was fällt auf?\nSie werden bemerken, dass die Geometrie über die Funktion ST_GeomFromText lesbar dargestellt werden kann. Der Geometrietyp von ArcGIS Pro wird dann über diese Funktion automatisch umgewandelt. I.d.R. ist es aber sehr viel einfacher Geometrien über ArcGIS Pro zu importieren oder zu erstellen. Sie sollen hier aber einmal sehen, dass es auch direkt über SQL geht.\nDie Attribute (Spalten in der DB) in der Datei sind Kommagetrennt in Klammern nach dem Wert VALUE. Die Reihenfolge ist diesselbe wie in der Klammer vor dem VALUE.\nPassen Sie die Datei an, indem Sie als objectid (erstes Attribut) ihre studentNr gefolgt von einer 0 eintragen und als id_erfasser (letztes Attribut) jeweils Ihre studentNr (Nur die Zahl ohne 0) eintragen. Denken Sie sich auch eine sinnvolle Schweizer-Koordinate in der Nähe der anderen Objekte aus, damit Sie nicht alle denselben Punkt importieren. Die Punkte dürfen, müssen aber nicht im Wald liegen. Variieren Sie etwas. Sie können eine Koordinate einfach im Map-Fenster von ArcGIS Pro ablesen und ebenfalls in der Datei anpassen. Es kommt jetzt hier nicht auf Genauigkeit der Lage des Punktes an. Über die id_tierart können Sie sich ein beliebiges Tier aussuchen. Tragen Sie eine vorhandene id_tierart aus Ihrer Tierarten Tabelle aus Übung 6 ein. Passen Sie zum Schluss auch noch das Datum an (siehe Abbildung 9.16).\nStarten Sie pgAdmin und laden die Datenbank “waelder” im Schema “arcgispro_editor”\nImportieren Sie die Sichtungsmeldung mit Hilfe der SQL-Datei in die Datenbank.\nSchauen Sie sich die Daten in pgadmin und in ArcGIS Pro an. Sie sollten einige Punkte in der Karte sehen (siehe Abbildung 9.17 und Abbildung 9.18).\n\n\n\n\n\n\n\nAbbildung 9.16: Anpassungen INSERT Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.17: pgAdmin Select Statement\n\n\n\n\n\n\n\n\n\nAbbildung 9.18: GIS GUI mit Wälder und Sichtungen",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Arbeiten mit Server Datenbanken in ArcGIS Pro und pgAdmin</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html",
    "href": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html",
    "title": "Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro",
    "section": "",
    "text": "Übung 10: Version erstellen in ArcGIS Pro\nDie Nutzung von Enterprise Server Geodatenbanken wie z.B. PostgreSQL erlaubt einen Mehrbenutzerbetrieb derselben Datenbank. In den vorigen Übungen haben wir jeweils alle Einträge in die Datenbank mehr oder weniger gleichzeitig durchgeführt, ohne auf eine Version zu achten. In solchen Fällen gilt für die Datenbank, dass der letzte Eintrag einen vorangehenden Eintrag überschreiben würde. Macht ein Benutzer Änderungen an einem Objekt, z.B. einem Polygon und gleichzeitig ein anderer Benutzer ebenfalls Änderungen am selben Polygon, so gilt jeweils die letzte Eintragung als aktuell. Alle vorigen Anpassungen werden überschrieben. Um dies zu verhindern, braucht es einen Mechanismus, welcher diese Mehrfachänderungen im Mehrbenutzerbetrieb managen kann. Hierzu wird Versionierung verwendet.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-10-version-erstellen-in-arcgis-pro",
    "href": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-10-version-erstellen-in-arcgis-pro",
    "title": "Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro",
    "section": "",
    "text": "Kehren Sie in das Projekt “Datenbankzugriff” in ArcGIS Pro zurück und verbinden zur Datenbank “waelder” mit Ihrem zugewiesenen Benutzer (studentNr).\nZeigen Sie die Sichtungsmeldungen aus der Datenbank in der Karte an.\nStarten Sie jetzt den Editor und erfassen ein paar beliebige Sichtungsmeldungen. Erfassen Sie auch die Attribute über die Attributtabelle. Speichern Sie anschliessend Ihre neuen Punkte.\nWechseln Sie anschliessend die Ansicht im Contents-Fenster von “List By Drawing Order” auf “List By Data Source” (siehe Abbildung 10.1).\nSchauen Sie sich die Verbindung zum Layer im Contents-Fenster an. Sie sehen dort zu Anfang “sde.DEFAULT”. Dies ist wie der Name vermuten lässt die Standard-Version in welche automatisch alle Änderungen usw. eingespielt werden, sofern keine weiteren Versionen vorhanden sind. “student1@…” zeigt hier auch noch den verbundenen Benutzer. (siehe Abbildung 10.2).\nSelektieren Sie die Verbindung und achten auf die Registerkarten im ArcGIS Pro Hauptmenü (ganz oben). Es wird ein neues Register “Versioning” angezeigt.\nHier sehen Sie alle Werkzeuge zur Verwaltung der Versionen. Erstellen Sie eine neue eigene Version durch Klick auf “New Version”. Achten Sie darauf das Häkchen bei “Change to this new version” zu setzen, damit die neue Version aktiviert wird (siehe Abbildung 10.3).\n\nName: studentNr_name\nDescription: beliebiger Text\nAccess Permission: Protected\n\nPrivate: Alle Änderungen in dieser Version sind privat, d.h. kein anderer Benutzer kann diese Version sehen und/oder benutzen.\nProtected: Alle Änderungen sind privat und niemand kann in dieser Version Daten bearbeiten. Andere Benutzer können aber die Version anzeigen und Änderungen sehen.\nPublic: Öffentliche Nutzung, d.h. auch andere Benutzer können zu dieser Version wechseln und Daten bearbeiten\n\n\nErstellen Sie die neue Version mit “OK”.\nSchauen Sie wiederum die Datenbankverbindung im Contents-Fenster an. Die neue Version student1 ist jetzt aktiv. Ab sofort werden alle Änderungen innerhalb dieser Version gemacht und nicht mehr in der sde.DEFAULT Version (siehe Abbildung 10.4).\nStarten Sie den Editor und löschen einige der bereits von Ihnen erfassten Sichtungsmeldungen und erfassen auch ein paar neue Punkte. Speichern Sie die Änderungen im Editor.\nMerken Sie sich ungefähr die Lage der von Ihnen jetzt digitalisierten Punkte (siehe Abbildung 10.5).\nWechseln Sie jetzt zurück auf die DEFAULT Version. Dies können Sie über das Kontextmenü des Eintrags im Contents-Fenster→Change Version. Alternativ kann die Version auch in der Registerkarte “Versioning” gewechselt werden.\nWechseln Sie die Version zurück auf die sde.DEFAULT Version.\nSchauen Sie sich das Kartenbild an. Was fällt auf?\nAlle Ihre Anpassungen/Änderungen, welche Sie in der Version studentNr gemacht haben, sind in der sde.DEFAULT nicht mehr vorhanden. Dies ist normal, da die Änderungen eben in einer anderen Version gemacht wurden (siehe Abbildung 10.6 und Abbildung 10.7).\nACHTUNG: Es kann natürlich sein, dass Ihre Mit-Studierenden etwas schneller waren und bereits Änderungen auch in die sde.DEFAULT eingespielt haben und Ihr Kartenbild jetzt deshalb trotzdem anders aussieht als vorher.\nSpeichern Sie Ihr ArcGIS Pro Projekt.\n\n\n\n\n\n\n\nAbbildung 10.1: Data Source in Contents-Fenster\n\n\n\n\n\n\n\n\n\nAbbildung 10.2: ArcGIS Pro Versionierung\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.3: ArcGIS neue Version erstellen\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.4: Neue Version in Data Source in Contents-Fenster\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.5: Neue Punkte in ArcGIS GUI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.6: Ändere Version in Contents-Fenster\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.7: Ändere Version in Contents-Fenster",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-11-versionen-zusammenführen-in-arcgis-pro",
    "href": "B_Datenbanken_2/4_Uebung_Versionierung_Mehrbenutzer.html#übung-11-versionen-zusammenführen-in-arcgis-pro",
    "title": "Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro",
    "section": "Übung 11: Versionen zusammenführen in ArcGIS Pro",
    "text": "Übung 11: Versionen zusammenführen in ArcGIS Pro\nIn vielen Anwendungsfällen bearbeiten viele Mitarbeiter die Daten in derselben Datenbank. Z.B. können unterschiedliche Mitarbeiter jeweils einen Teil eines Untersuchungsgebiets kartieren. Durch die Versionierung können alle Arbeiten unabhängig voneinander auf derselben Datenbank durchgeführt werden. Zu einem gewissen Zeitpunkt, spätestens nach Abschluss der Arbeiten sollten alle Arbeiten aber wieder in einer gemeinsamen Version zusammengeführt werden.\n\nBleiben Sie im Projekt “Datenbankzugriff” in ArcGIS Pro und in der Datenbank “waelder” mit Ihrem zugewiesenen Benutzer (studentNr).\nWechseln Sie wiederum auf die “List By Data Source” Ansicht im Contents-Fenster.\nSchauen Sie sich den Versionsmanager an. Sie öffnen diesen über die Registerkarte “Data Source Versioning” über die Schaltfläche “Manage Versions” (siehe Abbildung 10.8).\nHier können Sie alle vorhandenen (sofern berechtigten) Versionen einsehen und verwalten.\nDa Sie Ihre jeweilige Version als “protected” erstellt haben, sollten auch die Versionen Ihrer MitStudierenden sichtbar sein (siehe Abbildung 10.9).\nSchliessen Sie den Versionsmanager wieder.\nWechseln Sie anschliessend für den Sichtungsmeldungen Layer die Version. Wählen Sie diesmal die Version eines anderen Teilnehmers z.B. Ihres Tischnachbarn (siehe Abbildung 10.10).\nSie sollten im Kartenbild wieder eine andere Version mit anderen Punkten sehen.\nStarten Sie den Editor und versuchen ein paar neue Punkte zu erfassen.\nSie bekommen eine Fehlermeldung (siehe Abbildung 10.11).\nWie bereits erwähnt können “fremde” Versionen nicht bearbeitet werden, wenn diese nicht öffentlich sind.\nWechseln Sie wieder zurück zu Ihrer eigenen Version “studentNr”.\nZeigen Sie die Registerkarte “Versioning” an.\nBevor wir unsere eigenen Änderungen zurück in die sde.DEFAULT Version einspielen können, müssen wir auf Fehler bzw. Versionierungsprobleme prüfen, um sicher zu stellen, dass keine Inkonsistenzen entstehen.\nKlicken Sie dazu im Menü auf “Manage Versions”. Selektieren Sie Ihre Version und klicken “Reconcile/Post”. Wählen Sie die Zielversion so wie Einstellungen für das Fehlerhandling. Wählen Sie als Zielversion die sde.DEFAULT Datenbank und als Edit versions Ihre zuvor erstellte Version. Setzen Sie noch den Haken bei “Post versions after reconcile”. Lassen Sie ansonsten die Voreinstellungen (siehe Abbildung 10.12).\nSollte der Prozess ohne Fehler durchgeführt werden, so können im Anschluss die Änderungen in die sde.DEFAULT Datenbank geschrieben werden.\nKlicken Sie auf “Ok”. Alle Ihre Änderungen sollten jetzt auch in die sde.DEFAULT Version importiert worden sein.\nPrüfen Sie dies, indem Sie zurück auf die sde.DEFAULT Version wechseln. Diese sollte jetzt identisch mit Ihrer eigenen Version sein\n\n\n\n\n\n\n\nAbbildung 10.8: “Manage Versions” in Data Source [ArcGIS Pro]\n\n\n\n\n\n\n\n\n\nAbbildung 10.9: Verschiedene Versionen sind verfügbar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.10: Änderung der Version\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.11: Fehlermeldung in ArcGIS Pro\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 10.12: Fehlerbehebung mit Reconcile/Post",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Versionierung und Mehrbenutzerbetrieb in ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html",
    "href": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html",
    "title": "Abfragen in SQL mit pgAdmin und ArcGIS Pro",
    "section": "",
    "text": "(Optional) Übung 12: Abfragen in SQL\nWir haben in der Vorlesung ein paar SQL-Abfragen über die “waelder” Datenbank definiert. Da wir jetzt über die vorigen Übungen ein paar Beispiel Daten in die Datenbank importiert haben, können wir diese Datenbank nutzen, um noch ein paar Abfragen zu üben. Es ist nicht Ziel alle Abfragen gemacht zu haben. Machen Sie einfach so viele Abfragen wie Sie können. Beachten Sie auch, dass es oft mehr als einen Lösungsweg gibt.",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Abfragen in SQL mit pgAdmin und ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html#optional-übung-12-abfragen-in-sql",
    "href": "B_Datenbanken_2/5_Uebung_SQL_Abfragen.html#optional-übung-12-abfragen-in-sql",
    "title": "Abfragen in SQL mit pgAdmin und ArcGIS Pro",
    "section": "",
    "text": "Starten Sie pgAdmin und verbinden mit der Datenbank “waelder” mit Ihrem zugewiesenen Login (studentNr).\nFormulieren Sie die folgenden SQL-Abfragen und führen diese über das Query Tool von pgAdmin aus. Schauen Sie sich anschliessend das Ergebnis in der Attributtabelle und im Geometry Viewer an.\n\n\nNicht räumliche Abfragen:\n\nWelche Sichtungsmeldungen wurden von “id_erfasser_x” erfasst?\nWurden Löwen gesichtet? Wenn ja, wie viele?\nWie viele Tiere von jeder Art wurden jeweils gesichtet. Geben Sie eine Liste mit den Namen der Tierarten und der Anzahl der Sichtungen aus.\nWie viele Hasen wurden gesichtet? Geben Sie eine Zahl aus.\nWelcher Erfasser hat am meisten Meldungen erfasst? Geben Sie die id_erfasser und die Anzahl der erfassten Tiere aus.\nWelcher Erfasser hat am meisten unterschiedliche Tiere erfasst? Geben Sie die id_erfasser und die Anzahl der unterschiedlichen Tiere aus.\nIn welchen Wäldern kommen Rehe vor? Geben Sie die Namen und die Beschreibung der betroffenen Wälder und die Tierart aus.\nWie viele unterschiedliche Tierarten wurden gesichtet und welche sind das? Zeigen Sie jede Tierart mit dem Datum der letzten Sichtung. SQL→MAX(datum).\nWelche Tierarten wurden NICHT gesichtet?\nIn welchen Monaten wurden die meisten Tiere gesichtet? Geben Sie die drei “besten” Monate für Tiersichtungen aus.\n\nRäumliche Abfragen:\n\nWie gross sind die erfassten Wälder? Geben Sie eine Liste mit den Waldflächen in qm aus.\n\nFunktion: ST_AREA\n\nWie viel Fläche in qm haben alle Wälder zusammen?\n\nFunktion: ST_AREA und SUM\n\nWelche Sichtungsmeldungen liegen innerhalb eines Waldes?\n\nFunktion: ST_CONTAINS oder ST_WITHIN\n\nWelche Sichtungsmeldungen liegen ausserhalb des Waldes?\n\nFunktion: ST_UNION und ST_CONTAINS\n\nIn welchem Wald gibt es die meisten Sichtungen?\n\nFunktion: ST_CONTAINS und SUM\n\nWie weit sind die ausserhalb liegenden Sichtungsmeldungen vom Wald entfernt?\n\nFunktion: ST_DISTANCE, ST_UNION und ST_CONTAINS\n\nWelche Tiere wurden ausserhalb vom Wald gesichtet?\n\nFunktion: ST_UNION, ST_CONTAINS + JOIN\n\n\nWeitere Abfragen:\n\nGibt es Tierarten, welche nur im Wald gesichtet wurden? Welche sind das?\nGibt es Tierarten, welche nie im Wald gesichtet wurden? Welche sind das?\nIn welchen Wäldern wurden Füchse gesichtet?\nIn welchen Wäldern kommen Rehe und Füchse gemeinsam vor?\nWo gibt es Hermeline aber keine Mauswiesel?",
    "crumbs": [
      "Datenbanken II",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Abfragen in SQL mit pgAdmin und ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/2_Leistungsnachweis.html",
    "href": "B_Datenbanken_3/2_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Die Ergebnisse dieser folgenden Übungen sollen als Leistungsnachweis aufbereitet und eingereicht werden. In diesem Fall muss zu jeder Übung im Abschnitt 4 “Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL” (Übung 7‐12), ausgenommen optionale und Wiederholungsübungen, eine kurze schriftliche Dokumentation der Lösung abgegeben werden. Die Aufgabe gilt als Einzelarbeit. Eine gemeinsame Abgabe in Gruppen ist nicht erlaubt. Abgeschriebenes gilt sofort als nicht bestanden.\nDie Dokumentation muss Folgendes beinhalten:\n\nName und Vorname der Autoren oder Autorinnen.\nKurze Beschreibung des Lösungsweges inkl. der formulierten SQL‐Statements.\nBeschreiben Sie sowohl das Vorgehen in ArcGIS Pro als auch das Vorgehen in pgAdmin. Betrachten Sie dabei insbesondere die Geometrien und die Sachdaten und gehen Sie auf Unterschiede in den Vorgehensweisen und Ergebnissen ein.\nStellen Sie zum Schluss ArcGIS Pro und SQL/PostGIS gegenüber. Überlegen Sie sich Argumente für und gegen den Einsatz von ArcGIS Pro bzw. von SQL/PostGIS. Wann würden Sie ArcGIS Pro nutzen? Wann eher SQL/PostGIS? Befragen Sie dazu auch einschlägige Literatur und starten Sie eine Web‐Recherche. Dokumentieren Sie Ihre Erkenntnisse in ein paar kurzen Sätzen.\n\n\nAbgabeform und ‐termin:\nReichen Sie Ihre vollständige Dokumentation spätestens bis Freitag 17. November 2023 (2 Wochen nach letztem Input) als PDF über Moodle ein. Ihr findet dies unter der Aufgabenstellung im Abschnitt Geodatenbanken 3.\nAbgabe Leistungsnachweis",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html",
    "href": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html",
    "title": "Datenbankverbindung zum Server aufbauen",
    "section": "",
    "text": "Übung 1: (Wiederholung) Datenbankverbindung zum Server in pgAdmin herstellen\nIn den folgenden Übungen wollen wir mit einer Datenbank auf einem ZHAW‐Server arbeiten. Hierzu erstellen wir zunächst eine Verbindung zu dieser Datenbank über pgAdmin. ACHTUNG: funktioniert nur im ZHAW Netz (VPN).",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Datenbankverbindung zum Server aufbauen</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-1-wiederholung-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "href": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-1-wiederholung-datenbankverbindung-zum-server-in-pgadmin-herstellen",
    "title": "Datenbankverbindung zum Server aufbauen",
    "section": "",
    "text": "Starten Sie pgAdmin.\nIm Dashboard klicken Sie auf NEW Server und geben die folgenden Verbindungsparameter ein:\nRegister General: Name: svma‐s‐01323_modulagi_pdb_studentNr. Verwenden Sie dabei die Nr. Ihres zugewiesenen Benutzers.\nRegister Connection (siehe Abbildung 13.1):\n\nHost name/address: svma‐s‐01323.zhaw.ch\nPort: 5432\nMaintenance database: modulagi_pdb\nstudentNr (Verwenden Sie hier Ihren zugewiesenen Anmeldenamen)\nPasswort: (Verwenden Sie hier Ihr zugewiesenes Passwort)\n\nAlle anderen Einstellungen können belassen werden. Speichern Sie mit Klick auf Save.\nLassen Sie sich nicht davon verunsichern, dass es bereits einige Einträge hat. Da auf dem Server bereits andere Datenbanken installiert sind, sehen Sie auch diese. Navigieren Sie zur Datenbank “modulagi_pdb” und verschaffen sich einen Überblick über die vorhandenen Tabellen usw..\nVerwenden Sie für alle folgenden Übungen diese Datenbankverbindung, wenn nichts anderes angegeben.\n\n\n\n\n\n\n\nAbbildung 13.1: Register Connection pgAdmin",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Datenbankverbindung zum Server aufbauen</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-2-wiederholung-datenbankverbindung-zum-server-in-arcgis-pro-herstellen",
    "href": "B_Datenbanken_3/3_Uebung_Datenbankverbindung.html#übung-2-wiederholung-datenbankverbindung-zum-server-in-arcgis-pro-herstellen",
    "title": "Datenbankverbindung zum Server aufbauen",
    "section": "Übung 2: (Wiederholung) Datenbankverbindung zum Server in ArcGIS Pro herstellen",
    "text": "Übung 2: (Wiederholung) Datenbankverbindung zum Server in ArcGIS Pro herstellen\nIn den folgenden Übungen wollen wir mit einer Datenbank auf einem ZHAW-Server arbeiten. Hierzu erstellen wir zunächst eine Verbindung zu dieser Datenbank über ArcGIS Pro.\n\nStarten Sie ArcGIS Pro und erstellen Sie ein neues Projekt “Pflanzendatenbank_III”.\nSie können alle folgenden Übungen in diesem Projekt durchführen.\nNavigieren Sie im Catalog Fenster zum Eintrag Databases. Über das Kontextmenü (Rechtsklick) können Sie eine neue Datenbankverbindung herstellen.\nVerwenden Sie folgende Parameter (siehe Abbildung 13.2):\n\nDatabase Platform: PostgreSQL\nInstance: svma-s-01323.zhaw.ch\nAuthentication Type: Database authentication\nUser Name: studentNr (Verwenden Sie Ihren zugewiesenen Benutzer)\nPassword: (Verwenden Sie ihr zugewiesenes Passwort)\nDatabase: modulagi_pdb (Achtung, auch hier sehen sie eine Reihe von anderen Datenbanken, Achten Sie darauf die korrekte Datenbank zu wählen)\n\nSpeichern Sie die Einstellungen mit Klick auf OK und geben der neuen Datenbankverbindung einen sinnvollen Namen.\nVerwenden Sie für alle folgenden Übungen diese Datenbankverbindung, wenn nichts anderes angegeben.\n\n\n\n\n\n\n\nAbbildung 13.2: Register Connection ArcGIS Pro",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Datenbankverbindung zum Server aufbauen</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "",
    "text": "Übung 3: Werkzeug “Make Query Table” anwenden\nDas Werkzeug erstellt aus einer beliebigen Datenbankabfrage eine von ArcGIS Pro lesbare temporäre Tabelle. Dies ist immer dann sinnvoll, wenn z.B. nur eine Teilmenge aller Objekte gebraucht wird. Diese Teilmenge wird dabei in eine neue Tabelle geschrieben.",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-3-werkzeug-make-query-table-anwenden",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-3-werkzeug-make-query-table-anwenden",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "",
    "text": "Tipp\n\n\n\nDie Tabelle wird nur temporär in dem Projekt abgelegt, d.h. es wird keine konkrete Datei geschrieben und auch keine neue Tabelle in der Datenbank erstellt, sondern nur die Abfrage im Projekt gespeichert.\n\n\n\nStarten Sie pgAdmin und verbinden Sie mit der Pflanzendatenbank “modulagi_pdb” mit Ihrem Benutzer studentNr.\nProbieren Sie folgende SQL-Abfrage zu formulieren.\nSuchen Sie alle Gattungen der Familie “Asteraceae”. Zeigen Sie den Namen der Familie und den Namen der Gattung an (siehe Abbildung 14.2).\nStarten Sie ArcGIS Pro und öffnen das Projekt “Pflanzendatenbank_III”.\nErstellen Sie eine neue Karte.\nÖffnen Sie das Werkzeug “Make Query Table”\nWählen Sie die beteiligten Tabellen familien und gattungen (über die Datenbankverbindung)\nWählen Sie die anzuzeigenden Felder name_familie und name_gattung\nFiltern Sie die Abfrage über die SQL-Expression nach ‘Asteraceae’.\n\n\n\n\n\n\n\nTipp\n\n\n\nSie brauchen im Werkzeug nur den WHERE Teil der Abfrage ohne das Schlüsselwort WHERE eingeben. Achten Sie auch auf die verknüpften Schlüssel (id_familie) in beiden Tabellen. Sie können den WHERE Teil natürlich aus pgAdmin kopieren. Achten Sie in dem Fall darauf im Werkzeug auf die SQL-Ansicht umzustellen.\n\n\n\nGeben Sie der neuen Tabelle einen Namen.\nPrüfen Sie die Inhalte der neuen Tabelle. Vergleichen Sie mit dem Ergebnis aus pgAdmin.\n\n\n\n\n\n\n\nTipp\n\n\n\n“Make Query Table” erlaubt nur NICHT-räumliche Abfragen. Es können zwar Felder aus räumlichen Tabellen abgefragt werden, das Ergebnis ist aber immer eine einfache Tabelle und keine Feature Class.\n\n\n\n\n\n\n\n\nAbbildung 14.2: Ausschnitt Datenbankschema modulagi_pdb",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-4-werkzeug-make-query-layer-anwenden",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-4-werkzeug-make-query-layer-anwenden",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "Übung 4: Werkzeug “Make Query Layer” anwenden",
    "text": "Übung 4: Werkzeug “Make Query Layer” anwenden\nDas Werkzeug erstellt aus einer beliebigen Datenbankabfrage eine von ArcGIS Pro lesbare temporäre Feature Class.\n\n\n\n\n\n\nTipp\n\n\n\nDie Feature Class wird nur temporär in dem Projekt abgelegt, d.h. es wird keine konkrete Datei geschrieben und auch keine neue Tabelle in der Datenbank erstellt, sondern nur die Abfrage im Projekt gespeichert.\n\n\n\nProbieren Sie folgende SQL-Abfrage in pgAdmin zu formulieren.\nSuchen Sie den Standort aller Eichen (Gattung = Quercus). Zeigen Sie Gattung, Art und den Standort mit der objectid (Attribut shape + objectid) (siehe Abbildung 14.3).\nWechseln Sie zu ArcGIS Pro.\nÖffnen Sie das Werkzeug “Make Query Layer”.\nSchreiben Sie das SQL-Query.\n\n\n\n\n\n\n\nTipp\n\n\n\nSie können die Abfrage aus pgAdmin (Schritt 3) kopieren und hier wieder einfügen. Klicken Sie danach auf eine leere graue Fläche irgendwo im Werkzeug-Fenster damit das Kopierte angenommen wird.\n\n\n\nDie folgenden Einstellungen sollten dadurch dann automatisch gefunden werden.\nAchten Sie auf den korrekten Geometrietyp (Shape Type) und das Koordinatensystem, die SRID Nummer für das Schweizer Koordinatensystem CH1903+_LV95 lautet 2056.\n\n\n\n\n\n\n\nTipp\n\n\n\nEine Abfrage mit dem Werkzeug “Make Query Layer” benötigt immer ein eindeutiges Identifizierungsfeld (Unique identifier Field(s)). In diesem Fall nutzen wir das Attribut “objectid”. Achten Sie auch in den kommenden Abfragen auf ein solches ID-Feld.\n\n\n\nSchauen Sie sich den neuen Layer in der Karte an und werfen Sie auch einen Blick auf die Attributtabelle.\nVergleichen Sie wieder mit dem Ergebnis aus pgAdmin.\n\n\n\n\n\n\n\nTipp\n\n\n\nÜber das Kontextmenü des neuen Layers im Contents Fenster (Data→Export Features) können Sie den Layer auch dauerhaft z.B. als neue Feature Class in eine eigene Datenbank oder als neues Shapefile speichern.\n\n\n\n\n\n\n\n\nAbbildung 14.3: Ausschnitt Datenbankschema modulagi_pdb",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-5-werkzeug-create-database-view-anwenden",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-5-werkzeug-create-database-view-anwenden",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "Übung 5: Werkzeug “Create Database View” anwenden",
    "text": "Übung 5: Werkzeug “Create Database View” anwenden\n“Create Database View” kann dazu benutzt werden, eine Sicht auf eine Tabelle zu erzeugen bzw. eine Abfrage in der Datenbank zu speichern. Hierbei wird dann nur eine Auswahl von Attributspalten und/oder Objekten zurückgegeben. Eine Sicht ist oft auch nützlich, um komplizierte Abfragen aus mehreren Tabellen in eine Tabelle “zusammen zu fassen”, um dann einfacher darauf zugreifen zu können.\n\n\n\n\n\n\nTipp\n\n\n\nDie Sicht wird bei diesem Werkzeug, anders als in den beiden vorigen Werkzeugen, in der Datenbank gespeichert. D.h. es wird eine neue Tabelle bzw. View in der Datenbank erstellt.\n\n\n\nProbieren Sie folgende SQL-Abfrage in pgAdmin zu formulieren.\nMachen Sie eine Liste mit allen Pflanzen des Kurses “UÖ Stauden Gärtnerisch”. Die Liste soll dabei die ID der Spezies, die Gattung, Art und Sorte der Pflanze sowie den Namen des Kurses und den Standort (Attribut shape) enthalten. Speichern Sie diese Abfrage als View mit dem Namen “pdb.view_kursliste_stauden_gaertnerisch_studentNr” in der Datenbank. (CREATE VIEW … AS SELECT…) (siehe Abbildung 14.4).\n\n\n\n\n\n\n\nTipp\n\n\n\nMit zwei Minus Zeichen vor einer Zeile können Sie die Zeile auskommentieren.\n\n\n\nWechseln Sie zu ArcGIS Pro.\nErneuern Sie die Datenbankverbindung (Refresh / F5), damit die neue View sichtbar ist.\nEine View verhält sich wie eine neue Tabelle in ArcGIS Pro. Aus diesem Grund müsste die Tabelle eigentlich mit der Datenbank registriert werden. Sie erkennen dies auch in der Catalog Ansicht an dem nicht ausgefüllten Rechteck (siehe Abbildung 14.5).\nEine Registrierung bewirkt das Freischalten der Geodatenbank-Funktionen für diese Tabelle, damit auch neue Daten erfasst und bearbeitet werden können. Da Ihr Benutzer studentNr keine Berechtigungen zum Schreiben im Datenbankschema auf der Datenbank hat, kann die Tabelle jetzt nicht registriert werden. Da wir aber die Tabelle nur abfragen wollen ist dies nicht weiter schlimm.\nÖffnen Sie das Werkzeug “Create Database View”.\nSpeichern Sie mit dem Werkzeug eine identische Liste für den Kurs “UÖ Gehölze”. Geben Sie der View den Namen “pdb.view_kursliste_gehoelze_studentNr”. Achten Sie auf das “pdb.” vor dem eigentlichen Namen. Dies gibt das Schema an indem die View gespeichert werden soll. Sie können hierzu wieder das SQL-Select-Statement von oben kopieren (ohne den CREATE VIEW Teil) und den Kursnamen entsprechend anpassen.\nSchauen Sie sich das Ergebnis in der Attributtabelle und in der Karte an.\nSie sehen an dieser Übung, dass nur der Datenbankbesitzer neue Tabellen erstellen und hinzufügen kann. Andere Benutzer wie der student1 können nur vorhandene Tabellen und Daten bearbeiten und ändern. Neue Tabellen können nur ohne Schreibberechtigung erstellt werden.\n\n\n\n\n\n\n\nAbbildung 14.4: Ausschnitt Datenbankschema modulagi_pdb\n\n\n\n\n\n\n\n\n\nAbbildung 14.5: Catalog Ansicht in ArcGIS Pro",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-6-optional-werkzeug-make-table-view",
    "href": "B_Datenbanken_3/4_Uebung_Abfragen_einblenden.html#übung-6-optional-werkzeug-make-table-view",
    "title": "Abfragen aus der Datenbank in ArcGIS Pro einbinden",
    "section": "Übung 6: (optional) Werkzeug “Make Table View”",
    "text": "Übung 6: (optional) Werkzeug “Make Table View”\n“Make Table View” kann dazu benutzt werden, um eine reduzierte Sicht auf eine Tabelle zu erzeugen. Hierbei wird dann nur eine Auswahl von Attributspalten (ohne Geometrie-Attribut) angezeigt.\n\n\n\n\n\n\nTipp\n\n\n\nDie Sicht wird nur temporär in dem Projekt abgelegt, d.h. es wird keine konkrete Datei geschrieben und auch keine neue Tabelle in der Datenbank erstellt, sondern nur die Abfrage im Projekt gespeichert.\n\n\n\nStarten Sie ArcGIS Pro und laden das Projekt mit dem Namen “Pflanzendatenbank_III”\nÖffnen Sie das Werkzeug “Make Table View”.\nErstellen Sie eine Abfrage wie in Übung 5 und filtern nach der Art “japonicum”.\nWählen Sie als Input Table die zuvor erstellte View, lassen Sie aber das Geometriefeld (shape) in der Abfrage weg und filtern über eine “new Expression” nach name_art = “japonicum”.\nLassen Sie sich die Attributtabelle der neuen Tabelle anzeigen.",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Abfragen aus der Datenbank in ArcGIS Pro einbinden</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "",
    "text": "Übung 7: Geometrien zusammenführen mit “Dissolve”\nDie importierten Flächen sind alle einem bestimmten Bereich zugeordnet. Um einen Überblick über die Grösse und Ausdehnung der Bereiche zu bekommen, möchten wir alle Flächen (Tabelle pdb.flaechen_shp) mit identischem Bereich (Attribut “name_bereich”) zusammenführen (Abbildung 15.1).",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-7-geometrien-zusammenführen-mit-dissolve",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-7-geometrien-zusammenführen-mit-dissolve",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "",
    "text": "Führen Sie die Geometrien mit identischem Bereichsnamen (Attribut “name_bereich”) zusammen. Verwenden Sie wieder die Verbindung mit dem Benutzer studentNr.\n\nVerwenden Sie das Werkzeug “Dissolve” in ArcGIS Pro. Nutzen Sie dabei Multipart Features. Speichern Sie das Ergebnis als neuen Layer.\nFormulieren Sie jetzt die SQL Anfrage in pgAdmin (Verbindung wieder mit Benutzer studentNr). Verwenden Sie dabei die Funktion ST_UNION. Um nur gewünschte Flächen zu erhalten, sollten Sie das Ergebnis im SQL-Befehl nach dem Namen des Bereichs gruppieren (GROUP BY).\nOptional: Was passiert wenn das GROUP BY weggelassen würde? Probieren Sie es aus.\nLassen Sie das Attribute name_bereich für die Flächen anzeigen.\nZeigen Sie das Ergebnis mit “Make Query Layer” an und vergleichen mit dem ArcGIS Pro Resultat.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDa Ihr Datenbankbenutzer studentNr keine Berechtigungen zum Speichern in der Server Datenbank hat, können Sie das Ergebnis lokal auf Ihrem Rechner in Ihrem Ordner oder einer eigenen Geodatenbank ablegen.\n\n\n\n\n\n\n\n\nAbbildung 15.1: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-8-puffer-um-geometrie-erstellen",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-8-puffer-um-geometrie-erstellen",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 8: Puffer um Geometrie erstellen",
    "text": "Übung 8: Puffer um Geometrie erstellen\nAuf dem Campus sollen die Wege im Päoniengarten auf jeder Seite um 25cm verbreitert werden. Um die neuen Wege darzustellen, erstellen wir einen Puffer. Die Wegflächen finden Sie in der Datenbank in der Feature Class “wege_paeoniengarten” (siehe Abbildung 15.2).\n\nLegen Sie jeweils einen Puffer von beidseitig 25cm um das Wegenetz.\n\nNutzen Sie dazu einmal das Werkzeug “Buffer” in ArcGIS Pro. Speichern Sie hierbei das Ergebnis.\nNutzen Sie jetzt die POSTGIS Funktion ST_BUFFER in pgAdmin. Geben Sie auch die id der Flächen mit aus.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nAchten Sie auf die Einheiten. Welche Einheit nimmt ST_BUFFER? Fragen Sie die Online-Hilfe.\n\n\n\nSkizzieren Sie ihr Vorgehen in ArcGIS Pro und notieren ihren SQL-Befehl.\nUm das Ergebnis der PostGIS Funktion zu visualisieren, nutzen Sie das Werkzeug “Make Query Layer” mit Ihrer SQL Abfrage.\nVergleichen Sie die Ergebnisse. Schauen Sie sich auch die Attribute an. Was fällt auf?\n\n\n\n\n\n\n\nAbbildung 15.2: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-9-geometrien-überschneiden-mit-intersect",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-9-geometrien-überschneiden-mit-intersect",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 9: Geometrien überschneiden mit “Intersect”",
    "text": "Übung 9: Geometrien überschneiden mit “Intersect”\nAn einigen Stellen muss für die Verbreiterung des Weges die Fläche einiger Beete weichen. Ermitteln Sie die betroffenen Beete, welche Fläche für die neuen Wege abgeben müssen (siehe Abbildung 15.3).\n\nBilden Sie die Schnittmenge (Intersection) der gepufferten Wegfläche und der restlichen Flächen aus der Tabelle “pdb.flaechen”.\n\nIn ArcGIS Pro verwenden Sie dazu das Werkzeug “Pairwise Intersect”. Sie können als Input entweder Ihr Ergebnis aus der vorigen Übung benutzen oder Sie verwenden den Datensatz “wege_paeoniengarten_buffer” aus der Datenbank. Speichern Sie das Ergebnis.\nStellen Sie den SQL-Befehl mit Hilfe der Funktion “ST_INTERSECTION” für diese Abfrage in pgAdmin auf und visualisieren das Ergebnis wieder mit “Make Query Layer”. Sie können als Input entweder den gespeicherten Puffer aus der vorigen Übung verwenden oder Sie verwenden den Datensatz “wege_paeoniengarten_buffer” aus der Datenbank. Probieren Sie ebenfalls einmal aus durch eine verschachtelte Abfrage den Puffer mit ST_BUFFER direkt einzubeziehen. Geben Sie in Ihrem SQL-Befehl auch die ID der Fläche mit aus.\n\nSkizzieren Sie ihr Vorgehen in ArcGIS Pro und notieren ihren SQL-Befehl.\nVergleichen Sie die Ergebnisse aus ArcGIS Pro und SQL.\n\n\n\n\n\n\n\nTipp\n\n\n\nDie SQL Funktion ST_INTERSECTION erzeugt immer eine so genannte Geometry Collection, auch wenn zwei Geometrien keine Schnittmenge aufweisen, gibt es einen dann leeren Eintrag. Aus diesem Grund zeigt das Ergebnis immer alle Geometrien an. Haben die Geometrien keine Schnittmenge, so ist die Geometrie leer. Um leere Geometrien auszuschliessen, sollte im WHERE-Abschnitt z.B. mit der Funktion ST_OVERLAPS oder der Funktion ST_INTERSECTS geprüft werden, ob die zwei Eingabe-Geometrien (Gepufferte Wege und sonstige Flächen) überhaupt irgendwo überlappen. Im ArcGIS Pro werden leere Geometrien automatisch vom Ergebnis abgeschnitten.\n\n\n\n\n\n\n\n\nAbbildung 15.3: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-10-flächen-berechnen-in-arcgis-pro-und-sql",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-10-flächen-berechnen-in-arcgis-pro-und-sql",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 10: Flächen berechnen in ArcGIS Pro und SQL",
    "text": "Übung 10: Flächen berechnen in ArcGIS Pro und SQL\nIn der Übung 10 wurden Flächen ausgeschieden, welche von den betroffenen Beeten abgegeben werden müssen. Die genauen Flächengrössen sollen jetzt berechnet werden (Abbildung 15.4).\n\nWelche Beete müssen wie viel Fläche abgeben? Berechnen Sie die Fläche pro Beet in qm.\n\nLegen Sie dazu in ArcGIS Pro ein neues Feld in der Attributtabelle ihres gespeicherten Layers an und berechnen dort die jeweiligen Einzelflächen in qm (Calculate Geometry). Haben Sie das Ergebnis in einer Geodatenbank gespeichert gibt es bereits das Attribut shape_area mit der Fläche in qm.\nErstellen Sie in pgAdmin eine Abfrage in SQL, welche ebenfalls die jeweiligen Einzelflächen in qm ausgibt. Ergänzen Sie dazu die SQL-Abfrage aus Übung 9 mit einem neuen Feld, welches die Fläche ausgibt. Wenden Sie dazu die Funktion ST_AREA auf das Geometriefeld an.\nVisualisieren Sie das Ergebnis erneut mit “Make Query Layer”.\n\n\n\n\n\n\n\n\nAbbildung 15.4: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-11-geometrien-ausschneiden-mit-erase",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-11-geometrien-ausschneiden-mit-erase",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 11: Geometrien ausschneiden mit “Erase”",
    "text": "Übung 11: Geometrien ausschneiden mit “Erase”\nAls nächstes wollen wir die grosse Hauptwege-Achse zu unseren Flächen hinzufügen. Hierzu haben wir eine weitere Feature Class in der Datenbank mit der Hauptwegeachse zur Verfügung. Leider enthält die Feature Class nur die Aussengrenzen des Weges. Da es auf dem Weg auch Beete gibt, wollen wir diese Beetflächen aus der Wegfläche ausschneiden (siehe Abbildung 15.5).\n\nSchneiden Sie die Beetflächen aus der Wegeachse aus. Nutzen Sie dafür:\n\nIn ArcGIS Pro das Werkzeug “Erase” und speichern das Ergebnis als neue Feature Class oder als Shapefile in Ihrem Ordner.\nFormulieren Sie in pgAdmin den SQL-Befehl mit der Funktion ST_DIFFERENCE und zeigen Sie das Resultat mit “Make Query Layer” auf der Karte. Geben Sie dabei zusätzlich die id der Fläche sowie die Attribute name_standort und name_bereich mit aus.\n\nVergleichen Sie die Ergebnisse.\n\n\n\n\n\n\n\nTipp\n\n\n\nDiese Anfrage funktioniert in zwei Schritten mit einer verschachtelten Abfrage (aber trotzdem in einem SQL-Befehl). Um Polygone auszuschneiden, müssen wir zunächst alle Wegeflächen und alle sonstigen Flächen aus der Tabelle “flaechen_shp” zu jeweils einem Polygon zusammenfügen (ST_Union), damit wir nur noch zwei Flächen miteinander vergleichen müssen. Anschliessend werden die beiden Flächen dann mit dem Werkzeug ST_Difference untersucht.\nDie Funktion ST_Difference berechnet für jedes eingeschlossene Polygon einmal die Differenzmenge aus der Wegefläche und allen eingeschlossenen Polygonen. Dadurch hat das Ergebnis eigentlich zu viele Einträge, für jedes eingeschlossene Polygon ein Eintrag, welche aber alle dieselbe Geometrie aufweisen. Der Parameter LIMIT 1 limitiert die Ausgabe auf ein Feature.\n\n\n\n\n\n\n\n\nAbbildung 15.5: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-12-geometrien-ausschneiden-mit-clip",
    "href": "B_Datenbanken_3/5_Uebung_Geoverarbeitung.html#übung-12-geometrien-ausschneiden-mit-clip",
    "title": "Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL",
    "section": "Übung 12: Geometrien ausschneiden mit “Clip”",
    "text": "Übung 12: Geometrien ausschneiden mit “Clip”\nAls nächstes möchten wir alle Pflanzen suchen, welche auf bereits kartierten Flächen stehen. Hierzu nehmen wir den Punktdatensatz der Pflanzen und verschneiden diesen mit den bereits vorhandenen Beet-Flächen (siehe Abbildung 15.6).\n\nSuchen Sie alle Standorte (Punkte) der Pflanzen, welche auf kartierten Flächen stehen.\n\nIn ArcGIS Pro verwenden Sie das Werkzeug “Clip” und schneiden damit überflüssige Punkte weg. Speichern Sie das Resultat in Ihrem Ordner. Alternativ würde auch ein “Select by Location” gehen.\nFormulieren Sie auch hierzu die SQL-Anfrage in pgAdmin, welche alle Punkte auf den Flächen zurückgibt. Sie können dazu wieder die Funktion ST_INTERSECTION nutzen. Achten Sie darauf, dass wir dabei wieder nur diejenigen Punkte haben wollen, welche auch wirklich in Beziehung zu den Flächen stehen. Diesen Filter müssen Sie im WHERE-Abschnitt bereitstellen. Verwenden Sie dafür diesmal die Funktion ST_INTERSECTS. Binden Sie ausserdem noch die Attribute id_pflanze (objectid) und id_spezies in die Ausgabe ein und sortieren die Liste danach anhand der id_pflanze.\n\n\n\n\n\n\n\n\nAbbildung 15.6: Auszug aus Datenbankschema",
    "crumbs": [
      "Datenbanken III",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Geoverarbeitung in der Datenbank mit ArcGIS Pro und SQL</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/2_Python-Command-Prompt.html",
    "href": "C_Programmieren_1/2_Python-Command-Prompt.html",
    "title": "Python Command Prompt",
    "section": "",
    "text": "Um mit R zu Programmieren habt ihr bisher vermutlich in RStudio gearbeitet. RStudio ist eine sogenannte “Integrierte Entwicklungsumgebung” (i.e. IDE), wo ihr eure R-Scripts entwicklen konntet. Zu Beginn werden wir in diesem Kurs ohne Entwicklungsumgebung arbeiten und Python von der Konsole aus bedienen.\nStartet dazu den Python Command Prompt indem ihr Windowstaste drückt und nach dieser Applikation sucht (einfach den Namen eingeben). Nach dem öffnen der Applikation sollte sich ein schwarzes Fenster öffnen und auf eure Eingabe warten (siehe Abbildung 16.1).\n\n\n\n\n\n\nAbbildung 16.1: Python Command Prompt (i.e. “Eingabeaufforderung”)\n\n\n\nDieses Fenster ermöglicht es uns, auf sehr einfache (aber auch etwas trockene) Weise mit Python zu interagieren. Dazu müssen wir aber zuerst noch in das Python Programm einsteigen, indem wir python eintippen und Enter drücken.\n\n\n\n\n\n\nAbbildung 16.2: Python Command Prompt im Python Programm (beachte die drei &gt;&gt;&gt;)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Python Command Prompt</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html",
    "title": "Primitive Datentypen",
    "section": "",
    "text": "Boolean\nHierbei handelt es sich um den einfachsten Datentyp. Er beinhaltet nur zwei Zustände: Wahr oder Falsch. In Python werden diese mit True oder False definiert (diese Schreibweise muss genau beachtet werden). Beispielsweise sind das Antworten auf geschlossene Fragen.\nregen = True # \"es regnet\"\n\nsonne = False # \"die Sonne scheint nicht\"\n\ntype(sonne)\n\nbool\nUm zu prüfen, ob ein bestimmter Wert True oder False ist verwendet man is True. Will man also fragen ob es regnet, wir dies folgendermassen formuliert:\n# regnet es?\nregen is True\n\nTrue\nOb die Sonne scheint, lautet folgendermassen (natürlich müssen dazu die Variabel sonne bereits existieren):\n# scheint die Sonne?\nsonne is True\n\nFalse",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html#string",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html#string",
    "title": "Primitive Datentypen",
    "section": "String",
    "text": "String\nIn sogenannten Strings werden Textinformationen gespeichert. Beispielsweise können das die Namen von Ortschaften sein.\n\nstadt = \"Bern\"\nland = \"Schweiz\"\n\ntype(stadt)\n\nstr\n\n\nStrings können mit + miteinander verbunden werden\n\nstadt + \" ist die Hauptstadt der \" + land\n\n'Bern ist die Hauptstadt der Schweiz'",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html#integer",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html#integer",
    "title": "Primitive Datentypen",
    "section": "Integer",
    "text": "Integer\nIn Integer werden ganzzahlige Werte gespeichert, beispielsweise die Anzahl Einwohner einer Stadt.\n\nbern_einwohner = 133115\n\ntype(bern_einwohner)\n\nint",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/3_Primitive_Datentypen.html#float",
    "href": "C_Programmieren_1/3_Primitive_Datentypen.html#float",
    "title": "Primitive Datentypen",
    "section": "Float",
    "text": "Float\nAls Float werden Zahlen mit Nachkommastellen gespeichert, wie zum Beispiel die Temperatur in Grad Celsius.\n\nbern_flaeche = 51.62\n\ntype(bern_flaeche)\n\nfloat",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Primitive Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html",
    "href": "C_Programmieren_1/4_Uebung_1.html",
    "title": "Übung 1",
    "section": "",
    "text": "Übung 1.1\nErstelle eine Variabel vorname mit deinem Vornamen und eine zweite Variabel nachname mit deinem Nachnamen. Was sind vorname und nachname für Datentypen?\nMusterlösung\nvorname = \"Guido\"\nnachname = \"van Rossum\"\n\ntype(vorname) # es handelt sich um den Datentyp \"str\", also String (Text)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.2",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.2",
    "title": "Übung 1",
    "section": "Übung 1.2",
    "text": "Übung 1.2\n“Klebe” Vor- und Nachname mit einem Leerschlag dazwischen zusammen.\n\n\nMusterlösung\nvorname + \" \" + nachname",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.3",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.3",
    "title": "Übung 1",
    "section": "Übung 1.3",
    "text": "Übung 1.3\nErstelle eine Variabel groesse_cm mit deiner Körpergrösse in Zentimeter. Was ist das für ein Datentyp?\n\n\nMusterlösung\ngroesse_cm = 184\ntype(groesse_cm) # es handelt sich hierbei um den Datentyp \"integer\"",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.4",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.4",
    "title": "Übung 1",
    "section": "Übung 1.4",
    "text": "Übung 1.4\nErmittle deine Grösse in Fuss auf der Basis von groesse_cm (1 Fuss entspricht 30.48 cm). Was ist das für ein Datentyp?\n\n\nMusterlösung\ngroesse_fuss = groesse_cm / 30.48\ntype(groesse_fuss) # es handelt sich um den Datentyp \"float\"",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.5",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.5",
    "title": "Übung 1",
    "section": "Übung 1.5",
    "text": "Übung 1.5\nErstelle eine boolsche Variable blond und setzte sie auf True wenn diese Eigenschaft auf dich zutrifft und False falls nicht.\n\n\nMusterlösung\nblond = False",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.6",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.6",
    "title": "Übung 1",
    "section": "Übung 1.6",
    "text": "Übung 1.6\nErstelle eine Variabel einwohner mit der Einwohnerzahl der Schweiz (8’603’900, per 31. Dezember 2019). Erstelle eine zweite Variabel flaeche (ohne Umlaute!) mit der Flächengrösse der Schweiz (41’285 km\\(^2\\)). Berechne nun die Einwohnerdichte.\n\n\nMusterlösung\neinwohner = 8603900\nflaeche = 41285\n\ndichte = einwohner / flaeche\n\ndichte",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/4_Uebung_1.html#übung-1.7",
    "href": "C_Programmieren_1/4_Uebung_1.html#übung-1.7",
    "title": "Übung 1",
    "section": "Übung 1.7",
    "text": "Übung 1.7\nErstelle eine Variabel gewicht_kg (kg) und groesse_m (m) und berechne aufgrund von gewicht_kg und groesse_m ein BodyMassIndex (\\(BMI=\\frac{m}{l^2}\\), \\(m\\): Körpermasse in Kilogramm, \\(l\\): Körpergrösse in Meter).\n\n\nMusterlösung\ngewicht_kg = 85\ngroesse_m = groesse_cm / 100\n\ngewicht_kg / (groesse_m * groesse_m)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Übung 1</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/5_Komplexe_Datentypen.html",
    "href": "C_Programmieren_1/5_Komplexe_Datentypen.html",
    "title": "Komplexe Datentypen",
    "section": "",
    "text": "Im letzten Kapitel haben wir primitive Datentypen angeschaut. Diese stellen eine gute Basis dar, in der Praxis haben wir aber meistens nicht einen Temperaturwert, sondern eine Liste von Temperaturwerten. Wir haben nicht einen Vornamen sondern eine Tabelle mit Vor- und Nachnamen. Dafür gibt es in Python komplexere Datenstrukturen die als Gefässe für primitive Datentypen betrachtet werden können. Auch hier finden wir viele Ähnlichkeiten mit R:\n\n\n\n\n\n\n\n\n\n\nPython\nR\nBeschreibung\nBeispiel\n\n\n\n\n\nList\n(Vector)\nwerden über die Position abgerufen\nBeachtet die eckigen Klammern: hexerei = [3,2,1]\n\n\n\nDict\nList\nwerden über ein Schlüsselwort abgerufen\nBeachtet die geschweiften Klammern: langenscheidt = {\"trump\":\"erdichten\"}\n\n\n\nDataFrame\nDataframe\nTabellarische Daten\nSpezialfall einer dict pd.DataFrame({\"x\":[1,2,3], \"y\": [3,4,5]}\n\n\n\n\nIn Python gibt es noch weitere komplexe Datentypen wie Tuples und Sets. Diese spielen in unserem Kurs aber eine untergeordnete Rolle. Ich erwähne an dieser Stelle zwei häufig genannte Typen, damit ihr sie schon mal gehört habt:\n\nTuples:\n\nsind ähnlich wie Lists, nur können sie nachträglich nicht verändert werden. Das heisst, es ist nach der Erstellung keine Ergänzung von neuen Werten oder Löschung von bestehenden Werten möglich.\nsie werden mit runden Klammern erstellt: mytuple = (2,2,1)\n\nSets\n\nsind ähnlich wie Dicts, verfügen aber nicht über keys und values\njeder Wert wird nur 1x gespeichert (Duplikate werden automatisch entfernt)\nsie werden mit geschweiften Klammern erstellt: myset = {3,2,2}\n\n\nWohl das einfachste Gefäss, um mehrere Werte zu speichern sind Python-Listen, sogenannte Lists. Diese Lists werden mit eckigen Klammern erstellt. Die Reihenfolge, in denen die Werte angegeben werden, wird gespeichert. Das erlaubt es uns, bestimmte Werte aufgrund ihrer Position abzurufen.\nEine List wird folgendermassen erstellt:\n\nhexerei = [3,1,2]\n\nDer erste Wert wird in Python mit 0 (!!!) aufgerufen:\n\nhexerei[0]\n\n3\n\n\n\ntype(hexerei)\n\nlist\n\n\nIm Prinzip sind Lists ähnlich wie Vectors in R, mit dem Unterschied das in Python-Lists unterschiedliche Datentypen abgespeichert werden können. Zum Beispiel auch weitere, verschachtelte Lists:\n\nchaos = [23, \"ja\", [1,2,3]]\n\n\n# Der Inhalt vom ersten Wert ist vom Typ \"Int\"\ntype(chaos[0])\n\nint\n\n\n\n# Der Inhalt vom dritten Wert ist vom Typ \"List\"\n\ntype(chaos[2])\n\nlist",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Komplexe Datentypen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html",
    "href": "C_Programmieren_1/6_Uebung_2.html",
    "title": "Übung 2",
    "section": "",
    "text": "Übung 2.1\nMusterlösung\nvornamen = [\"Christopher\", \"Henning\", \"Severin\"]\nnachnamen = [\"Annen\", \"May\", \"Kantereit\"]\n\ngroessen = [174, 182, 162]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.1",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.1",
    "title": "Übung 2",
    "section": "",
    "text": "Erstelle eine Variable vornamen bestehend aus einer List mit 3 Vornamen\nErstelle eine zweite Variable nachnamen bestehend aus einer List mit 3 Nachnamen\nErstelle eine Variable groessen bestehend aus einer List mit 3 Grössenangaben in Zentimeter.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.2",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.2",
    "title": "Übung 2",
    "section": "Übung 2.2",
    "text": "Übung 2.2\nWie erhältst du den ersten Eintrag in der Variable vornamen?\n\n\nMusterlösung\nvornamen[0]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.3",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.3",
    "title": "Übung 2",
    "section": "Übung 2.3",
    "text": "Übung 2.3\nListen können durch die Methode append ergänzt werden (s.u.). Ergänze die Listen vornamen, nachnamen und groessen durch je einen Eintrag.\n\nvornamen.append(\"Malte\")\n\n\n\nMusterlösung\nnachnamen.append(\"Huck\")\n\ngroessen.append(177)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.4",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.4",
    "title": "Übung 2",
    "section": "Übung 2.4",
    "text": "Übung 2.4\nErmittle die Summe aller Werte in groessen. Tip: Nutze dazu sum()\n\n\nMusterlösung\nsum(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.5",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.5",
    "title": "Übung 2",
    "section": "Übung 2.5",
    "text": "Übung 2.5\nErmittle die Anzahl Werte in groessen . Tip: Nutze dazu len()\n\n\nMusterlösung\nlen(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#sec-mittelwert",
    "href": "C_Programmieren_1/6_Uebung_2.html#sec-mittelwert",
    "title": "Übung 2",
    "section": "Uebung 2.6",
    "text": "Uebung 2.6\nBerechne die durchschnittliche Grösse aller Personen in groessen. Tip: Nutze dazu len() und sum().\n\n\nMusterlösung\nsum(groessen) / len(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/6_Uebung_2.html#übung-2.7",
    "href": "C_Programmieren_1/6_Uebung_2.html#übung-2.7",
    "title": "Übung 2",
    "section": "Übung 2.7",
    "text": "Übung 2.7\nErmittle nun noch die Minimum- und Maximumwerte aus groessen (finde die dazugehörige Funktion selber heraus).\n\n\nMusterlösung\nmin(groessen)\nmax(groessen)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Übung 2</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/7_JupyterNotebook.html",
    "href": "C_Programmieren_1/7_JupyterNotebook.html",
    "title": "JupyterLab",
    "section": "",
    "text": "Bisher haben wir ohne Enwicklungsumgebung (IDE) gearbeitet, was auf die Dauer sehr mühsam sein kann. Erstens wird unser Code nirgens gespeichert und zweitens wird bei der Entwicklung des Codes wenig unterstützt (z.B. keine Autovervollständigung).\nDeshalb arbeiten wir von nun an in einer ordentlichen Entwicklungsumgebung, und zwar in JupyterLab. JupyterLab ist eine unter Data Scientists sehr beliebte Entwicklungsumgebung. Sie hat zwei Eigenheiten, die anfänglich zu etwas Verwirrung sorgen können. JupyterLab wird:\n\nmit dem “Command Prompt” gestartet\nüber den Webbrowser bedient\n\nUm JupyterLab zu starten verlässt ihr Python im Command Prompt in dem ihr exit() oder quit() eintippt und mit Enter bestätigt. Danach könnt ihr mit dem Befehl jupyter lab eben diesen starten.\n\n\n\n\n\n\nAbbildung 21.1: Beendet den Python mit dem Befehl quit() oder exit()\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\nJupyterLab wird nun in eurem Browser angezeigt, das Programm läuft aber in eurer Konsole. Das heisst:\n\nihr düft die Konsole nicht schliessen, während ihr mit JupyterLab arbeitet\num JupyterLab zu beenden verwendet ihr in der Konsole die Tastenkombination Ctrl + C\n\nBeachtet den Pfad, der in Python Command Prompt dargestellt wird (in Abbildung 21.1 wird der Pfad C:\\Users\\bako\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone2 angezeigt)\n\nDieser Pfad ist das “Arbeitsverzeichnis”, in welchem JupyterLab gestartet wird\nDieser Pfad ist nicht sinnvoll, wir werden ihn in einem nächsten Schritt ändern.\n\n\n\n\nWie erwähnt ist das automatisch gewählte Arbeitsverzeichnis (im Beispiel C:\\Users\\bako\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone2) nicht ideal. Es macht viel mehr Sinn, ein vertrautes Verzeichnis zu wählen (z.B. den Desktop oder wo ihr eure Unterrichtsunterlagen abspeichert). Dieses Verzeichnis müssen wir wählen, bevor wir JupyterLab starten. Schliesst deshalb JupyterLab wieder in dem ihr in der Konsole die Tastenkombination Ctrl + C verwendet.\nWählt nun ein sinvolleres Verzeichnis und kopiert dessen Pfad aus dem File Explorer. Gebt nun in der Konsole den Befehl cd (change directory), gefolgt von dem Pfad zu dem von uns gewünschten Verzeichnis. Im Beispiel werden wir auf den Desktop wechseln cd C:\\Users\\bako\\Desktop (siehe Abbildung 21.2).\nNun sollte sich der angezeigte Pfad (vor dem &gt;) in eurer Konsole ändern. Ist dies nicht der Fall, hat das Wechseln des Verzeichnisses nicht funktioniert. War das wechseln des Verzeichnisses erfolgreich, könnt ihr erneut JupyterLab starten: Im Unterschied zu vorher sollten die Dateien, die Ihr nun seht (siehe Abbildung 21.3) vertrauter sein.\n\n\n\n\n\n\nAbbildung 21.2: JupyterLab starten\n\n\n\nÖffnet nun ein neues Jupyter Notebook File in dem ihr auf New &gt; Python 3 klickt (siehe Abbildung 21.2).\n\n\n\n\n\n\nAbbildung 21.3: Öffnen eines neuen Jupyter Notebook Files\n\n\n\nDas Bedienen von JupyterLab lässt sich nicht gut in Worte fassen. Wir wollen diese deshalb in einer kurzen Demo vorzeigen, alternativ (falls du selbständig arbeitest) kannst du dir auch nachstehenden Video anschauen (ab 1:46):",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>JupyterLab</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/8_Dictionary.html",
    "href": "C_Programmieren_1/8_Dictionary.html",
    "title": "Dictionaries",
    "section": "",
    "text": "In den letzten Übungen haben wir einen Fokus auf Listen gelegt. Nun wollen wir ein besonderen Fokus auf den Datentyp Dictionary legen.\nÄhnlich wie eine List, ist eine Dictionary ein Behälter wo mehrere Elemente abgespeichert werden können. Wie bei einem Wörterbuch bekommt jedes Element ein “Schlüsselwort”, mit dem man den Eintrag finden kann. Unter dem Eintrag “trump” findet man im Langenscheidt Wörterbuch (1977) die Erklärung “erdichten, schwindeln, sich aus den Fingern saugen”.\n\nIn Python würde man diese Dictionary folgendermassen erstellen:\n\nlangenscheidt = {\"trump\":\"erdichten- schwindeln- sich aus den Fingern saugen\"}\n\nSchlüssel (von nun an mit Key bezeichnet) des Eintrages lautet “trump” und der dazugehörige Wert (Value) “erdichten- schwindeln- aus den Fingern saugen”. Beachte die geschweiften Klammern ({ und }) bei der Erstellung einer Dictionary.\nEine Dictionary besteht aber meistens nicht aus einem, sondern aus mehreren Einträgen: Diese werden Kommagetrennt aufgeführt.\n\nlangenscheidt = {\"trump\":\"erdichten- schwindeln- sich aus den Fingern saugen\", \"trumpery\":\"Plunder- Ramsch- Schund\"}\n\nDer Clou der Dictionary ist, dass man nun einen Eintrag mittels dem Key aufrufen kann. Wenn wir also nun wissen wollen was “trump” heisst, ermitteln wir dies mit der nachstehenden Codezeile:\n\nlangenscheidt[\"trump\"]\n\n'erdichten- schwindeln- sich aus den Fingern saugen'\n\n\nUm eine Dictionary mit einem weiteren Eintrag zu ergänzen, geht man sehr ähnlich vor wie beim Abrufen von Einträgen.\n\nlangenscheidt[\"trumpet\"] = \"trompete\" \n\nEin Key kann auch mehrere Einträge enthalten. An unserem Langenscheidts Beispiel: Das Wort “trump” ist zwar eindeutig, doch “trumpery” hat vier verschiedene Bedeutungen. In so einem Fall können wir einem Eintrag auch eine List von Werten zuweisen. Beachte die Eckigen Klammern und die Kommas, welche die Listeneinträge voneinander trennt.\n\nlangenscheidt[\"trumpery\"] = [\"Plunder- Ramsch- Schund\", \n                             \"Gewäsch- Quatsch\", \n                             \"Schund- Kitsch\", \n                             \"billig- nichtssagend\"]    \nlangenscheidt[\"trumpery\"]\n\n['Plunder- Ramsch- Schund',\n 'Gewäsch- Quatsch',\n 'Schund- Kitsch',\n 'billig- nichtssagend']\n\n\n\nlen(langenscheidt[\"trumpery\"])\n\n4",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Dictionaries</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html",
    "href": "C_Programmieren_1/9_Uebung_3.html",
    "title": "Übung 3",
    "section": "",
    "text": "Übung 3.1\nErstelle eine Dictionary mit folgenden Einträgen: Vorname und Nachname von (d)einer Person. Weise diese Dictionary der Variable me zu.\nMusterlösung\nme = {\"vorname\": \"Guido\", \"nachname\": \"van Rossum\"}",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.2",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.2",
    "title": "Übung 3",
    "section": "Übung 3.2",
    "text": "Übung 3.2\nRufe verschiedene Elemente aus der Dictionary via dem Key ab.\n\n\nMusterlösung\nme[\"nachname\"]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.3",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.3",
    "title": "Übung 3",
    "section": "Übung 3.3",
    "text": "Übung 3.3\nNutze me um nachstehenden Satz (mit deinen Values) zu erstellen:\n\n\nMusterlösung\n\"Mein Name ist \"+me[\"nachname\"] +\", \"+ me[\"vorname\"]+\" \"+me[\"nachname\"]\n\n\n'Mein Name ist van Rossum, Guido van Rossum'",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.4",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.4",
    "title": "Übung 3",
    "section": "Übung 3.4",
    "text": "Übung 3.4\nErgänze die Dictionary me durch einen Eintrag “groesse” mit (d)einer Grösse.\n\n\nMusterlösung\nme[\"groesse\"] = 181",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.5",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.5",
    "title": "Übung 3",
    "section": "Übung 3.5",
    "text": "Übung 3.5\nErstelle eine neue Dictionary people mit den Keys “vornamen”, “nachnamen” und “groesse” und jeweils 3 Einträgen pro Key.\n\n\nMusterlösung\npeople = {\"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \"groessen\": [174, 182, 162]}",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.6",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.6",
    "title": "Übung 3",
    "section": "Übung 3.6",
    "text": "Übung 3.6\nRufe den ersten Vornamen deiner Dict auf. Dazu musst du dein Wissen über Listen und Dictionaries kombinieren.\n\n\nMusterlösung\npeople[\"vornamen\"][0]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.7",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.7",
    "title": "Übung 3",
    "section": "Übung 3.7",
    "text": "Übung 3.7\nRufe den dritten Nachname deiner Dict auf.\n\n\nMusterlösung\npeople[\"nachnamen\"][2]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/9_Uebung_3.html#übung-3.8",
    "href": "C_Programmieren_1/9_Uebung_3.html#übung-3.8",
    "title": "Übung 3",
    "section": "Übung 3.8",
    "text": "Übung 3.8\nBerechne den Mittelwert aller grössen in deiner Dict\n\n\nMusterlösung\nsum(people[\"groessen\"])/len(people[\"groessen\"])",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Übung 3</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/10_Tabellarische_Daten.html",
    "href": "C_Programmieren_1/10_Tabellarische_Daten.html",
    "title": "DataFrames",
    "section": "",
    "text": "Schauen wir uns nochmals die Dictionary people aus der letzten Übung an. Diese ist ein Spezialfall einer Dictionary: Jeder Eintrag besteht aus einer Liste von gleich vielen Werten. Wie bereits erwähnt, kann es in einem solchen Fall sinnvoll sein, die Dictionary als Tabelle darzustellen.\n\npeople = {\"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \"groessen\": [174, 182, 162]}\n\n\nimport pandas as pd # Was diese Zeile beudeutet lernen wir später\n\npeople_df = pd.DataFrame(people)\n\npeople_df\n\n\n\n\n\n\n\n\nvornamen\nnachnamen\ngroessen\n\n\n\n\n0\nChristopher\nAnnen\n174\n\n\n1\nHenning\nMay\n182\n\n\n2\nSeverin\nKantereit\n162",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>DataFrames</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html",
    "href": "C_Programmieren_1/11_Uebung_4.html",
    "title": "Übung 4",
    "section": "",
    "text": "Übung 4.1\nImportiere pandas und nutze die Funktion DataFrame um people in eine DataFrame umzuwandeln (siehe dazu das Beispiel unten). Weise den Output der Variable people_df zu und schau dir people_df an.\nimport pandas as pd\n\npeople = {\"vornamen\": [\"Christopher\", \"Henning\", \"Severin\"], \"nachnamen\": [\"Annen\",\"May\", \"Kantereit\"], \"groessen\": [174, 182, 162]}\n\n\npeople_df = pd.DataFrame(people)",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-to-csv",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-to-csv",
    "title": "Übung 4",
    "section": "Übung 4.2",
    "text": "Übung 4.2\nIn der Praxis kommen Tabellarische Daten meist als “csv” Dateien daher. Wir können aus unserer eben erstellten DataFrame sehr einfach eine csv Datei erstellen. Führe das mit folgendem Code aus und suche anschliessend die erstellte csv-Datei.\n\npeople_df.to_csv(\"people.csv\")\n\n\n\n\n\n\n\nAchtung!\n\n\n\nFalls ihr nicht wisst, wo das csv abgespeichet ist solltet ihr das Kapitel JupyterLab nochmals durchlesen.\nDie Working Directory zu kennen ist wichtig, besonders auch für die nächste Aufgabe. Falls ihr die aktuelle Working Directory neu setzen und dafür JupyterLab schliessen müsst, denkt daran die Notebook vorgängig zu speichern und im File Explorer aufzusuchen.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-import-zeckenstiche",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-import-zeckenstiche",
    "title": "Übung 4",
    "section": "Übung 4.3",
    "text": "Übung 4.3\nGenau so einfach ist es eine csv zu importieren. Lade die Datei “zeckenstiche.csv” (siehe Tabelle 1) herunter und speichere es im aktuellen Arbeitsverzeichnis ab. Importiere mit folgendem Code die Datei “zeckenstiche.csv”.\n\n# ich habe die Daten in einem Unterordner \"data\" abgespeichert\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-scatterplot",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-scatterplot",
    "title": "Übung 4",
    "section": "Übung 4.4",
    "text": "Übung 4.4\nDie DataFrame zeckenstiche beinhaltet x und y Koordinaten für jeden Unfall in den gleichnamigen Spalten. Wir können die Stiche mit einem Scatterplot räumlich visualisieren. Führe dazu folgenden Code aus.\n\nfig = zeckenstiche.plot.scatter(\"x\",\"y\")\n\nfig.axis(\"equal\")\n# \"equal\" stellt sicher, das die x und y Achsen gleich skaliert sind\n# dies ist sinnvoll, da es sich ja um Schweizer Koordinaten (Meter) handelt",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-sel-col",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-sel-col",
    "title": "Übung 4",
    "section": "Übung 4.5",
    "text": "Übung 4.5\nUm eine einzelne Spalte zu selektieren (z.B. die Spalte “ID”), kann man gleich vorgehen wie bei der Selektion eines Eintrags in einer Dictionary. Probiere es aus.\n\n\nMusterlösung\nzeckenstiche[\"ID\"]",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/11_Uebung_4.html#sec-ex-new-col",
    "href": "C_Programmieren_1/11_Uebung_4.html#sec-ex-new-col",
    "title": "Übung 4",
    "section": "Übung 4.6",
    "text": "Übung 4.6\nAuch das Erstellen einer neuen Spalte ist identisch mit der Erstellung eines neuen Dictionary Eintrags. Erstelle eine neue Spalte “Stichtyp” mit dem Wert “Zecke” auf jeder Zeile (s.u.).\n\nzeckenstiche[\"Stichtyp\"] = \"Zecke\"\n\n\n\nMusterlösung\nzeckenstiche",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Übung 4</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/12_Uebung_5.html",
    "href": "C_Programmieren_1/12_Uebung_5.html",
    "title": "Übung 5",
    "section": "",
    "text": "Übung 5.1 Neue Conda Umgebung erstellen",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/12_Uebung_5.html#übung-5.1-neue-conda-umgebung-erstellen",
    "href": "C_Programmieren_1/12_Uebung_5.html#übung-5.1-neue-conda-umgebung-erstellen",
    "title": "Übung 5",
    "section": "",
    "text": "Starte Python Command Prompt (siehe Python Command Prompt)\nFühre den Befehl: conda create --name geopython2 aus\nBestätige die Installation mit y\nPrüfe, ob u.a. folgende Meldung im Terminal erscheint (melde dich falls nicht):\n#\n# To activate this environment, use\n#\n#     $ activate geopython2\n#\n# To deactivate an active environment, use\n#\n#     $ deactivate\nFühre den Befehl aus, der in der Meldung steht:\nactivate geopython2               # (Windows) \nconda activate geopython2         # (MacOS, Linux)\nPrüfe, ob die Eingabeforderung im Terminal nun mit (geopython2) beginnt (melde dich falls nicht)\n# ↓ vorher\n(arcgispro-py3) C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3&gt;\n\n# ↓ nachher\n(geopython2)  C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\geopython&gt;\nFühre den folgenden Befehl aus:\nconda install -c conda-forge jupyterlab geopandas matplotlib descartes\nBestätige die Installation mit y\nPrüfe, ob die installation erfolgreich war (erscheint folgende Meldung im Terminal?):\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\nRetrieving notices: ...working... done",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/12_Uebung_5.html#sec-jupyterlab-desktop",
    "href": "C_Programmieren_1/12_Uebung_5.html#sec-jupyterlab-desktop",
    "title": "Übung 5",
    "section": "Übung 5.2 JupyterLab Desktop installieren",
    "text": "Übung 5.2 JupyterLab Desktop installieren\nDie Tatsache, dass JupyterLab via dem Command Prompt gestartet wird und im Browser läuft, ist ungewohnt und auch etwas umständlich. Um nur schon eines der soeben erstellten Jupyter Notebooks (*.ipynb File) zu betrachten muss (1) der Terminal geöffnet, (2) in den richtigen Ordner navigiert (3) die richtige Conda Umgebung aktiviert und (4) JupyterLab gestartet werden.\nDeshalb empfehlen wir die Installation von JupyterLab Desktop, welches JupyterLab als Desktop Applikation zur Verfügung stellt. JupyterLab Desktop kann man gemäss folgender Anleitung installieren: https://github.com/jupyterlab/jupyterlab-desktop#installation.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/13_Anhang.html",
    "href": "C_Programmieren_1/13_Anhang.html",
    "title": "Anhang",
    "section": "",
    "text": "Anhang 1: Arbeiten mit GoogleCollab\nIn diesem Modul fokussieren wir uns darauf, dass ihr eure Lokale Programmierumgebung aufsetzen und pflegen könnt. Falls das nicht möglich ist, könnt ihr auch mit GoogleCollab arbeiten. GoogleCollab ist eine kostenlose Online-Plattform, die euch die Möglichkeit gibt, Python-Notebooks zu erstellen und auszuführen. Ihr könnt dort auch eure Notebooks speichern und mit anderen teilen.",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_1/13_Anhang.html#anhang-1-arbeiten-mit-googlecollab",
    "href": "C_Programmieren_1/13_Anhang.html#anhang-1-arbeiten-mit-googlecollab",
    "title": "Anhang",
    "section": "",
    "text": "Daten auf GoogleDrive Hochladen: Erstellt einen Ordner auf GoogleDrive mit dem Namen Modul-AGI und ladet die Daten (siehe Tabelle 1) dort hoch.\nGoogleCollab öffnen: Öffnet GoogleCollab unter https://colab.research.google.com/ und clickt auf den Button “New Notebook” / “Neues Notebook”.\nGoogle Drive Mounten: Mountet GoogleDrive, indem ihr folgenden Code in die erste Zelle eures Notebooks schreibt und ausführt:\nfrom google.colab import drive\ndrive.mount('/content/drive')\nLibraries laden: Auf GoogleCollab sind die meisten Libraries bereits installiert. Ihr müsst sie nur noch laden. Fügt dazu folgenden Code in die nächste Zelle ein und führt ihn aus:\nimport pandas as pd\nimport geopandas as gpd\nUnter Umständen müsst ihr zusätzliche Libraries installieren. GoogleCollab wird euch darauf hinweisen und liefert auch den passenden pip-Befehl (pip ist eine alternative zu conda). Um diesen Befehl auf GoogleCollab auszuführen, führt ihr den Befehl in eurem Notebook mit vorangestelltem Ausrufezeichen aus. Z.B:\n!pip install folium matplotlib mapclassify\nDaten laden: Ladet die Daten, indem ihr folgenden Code in die nächste Zelle einfügt und ausführt:\n# Solltet ihr der Ordner nicht Modul-AGI benannt haben, Pfad anpassen\nzeckenstiche = pd.read_csv(\"/content/drive/MyDrive/Modul-AGI/zeckenstiche.csv\")",
    "crumbs": [
      "Programmieren I",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/2_Conda.html",
    "href": "C_Programmieren_2/2_Conda.html",
    "title": "Conda",
    "section": "",
    "text": "Was ist Conda?\nConda ist ein (von im Wesentlichen zwei1) Verwaltungssystem für Python2 Bibliotheken welches unter Windows, macOS und Linux läuft. Mit Conda lassen sich diese Libraries und deren Abhängigkeiten schnell installieren, ausführen und aktualisieren. Ein zusätzliches, wichtiges Feature von Conda ist die Verwaltung von sogenannten “Virtuellen Umgebungen”. Diese Umgebungen ermöglichen es, dass Package Installationen in abgeschottenen “Container” erfolgen. Das heisst, dass man unterschiedliche Versionen des gleichen Packages installieren kann, ohne das dies Probleme bereitet.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/2_Conda.html#conda-installieren",
    "href": "C_Programmieren_2/2_Conda.html#conda-installieren",
    "title": "Conda",
    "section": "Conda installieren",
    "text": "Conda installieren\nMit der Installation von ArcGIS wird (Mini-) Conda bereits mitgeliefert. Wer ArcGIS also schon hat, muss Conda nicht mehr installieren. Wer aber auf einem anderen Betriebssystem arbeiten möchte (oder ArcGIS auf Windows nicht installiert hat), kann Conda sehr einfach herunterladen und installieren: https://docs.conda.io/en/latest/miniconda.html.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/2_Conda.html#conda-environment-erstellen",
    "href": "C_Programmieren_2/2_Conda.html#conda-environment-erstellen",
    "title": "Conda",
    "section": "Conda environment erstellen",
    "text": "Conda environment erstellen\nWenn man den Python Command Prompt startet, ist Conda bereits aktiviert. Dies ist daran erkennbar, dass vor dem Pfad (C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3) noch etwas in Klammern steht (arcgispro-py3, siehe Abbildung 28.1).\narcgispro-py3 ist der Name des Conda Environments, das automatisch aktiviert wurde. Gleichzeitig ist dies das “default Python Environment”, welches ArcGIS Pro jeweils nutzt (siehe Abbildung 28.2). Das heisst, dieses Environment wird verwendet wenn man Python innerhalb von ArcGIS nutzen möchte und hat dafür gewisse Libraries vorinstalliert. Dabei macht ArcGIS aber folgenden Hinweis: Note: Cannot modify the default Python environment (arcigspro-py3). Clone then activate a new environment first. Genau diese Freiheit wollen wir aber haben und erstellen deswegen ein eigenes Environment.\nUm ein neues Environment mit dem Namen geopython2 zu erstellen und aktivieren geht man wie folgt vor:\nconda create --name geopython2           # erstellt das Environment\nactivate geopython                       # aktiviert das Environment (Windows)\nconda activate geopython                 # aktiviert das Environment (Mac / Linux)\nNun sollte in der Klammer der Name des eben erstellten Environment erscheinen (geopython). Selbstverständlich kann man den Namen des Environments selbst wählen, dabei sollten aber Umlaute, Sonderzeichen und Grossbuchstaben vermieden werden.\n\n\n\n\n\n\nAbbildung 28.1: Python Command Prompt (i.e. “Eingabeaufforderung”)\n\n\n\n\n\n\n\n\n\nAbbildung 28.2: ArcGIS nutzt ebenfalls Conda. Welches Conda Environment in der aktuellen ArcGIS Session benutzt wird ist ersichtlich, wenn man in ArcGIS zu Projekt &gt; Python navigiert.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/2_Conda.html#conda-packages-installieren",
    "href": "C_Programmieren_2/2_Conda.html#conda-packages-installieren",
    "title": "Conda",
    "section": "Conda packages installieren",
    "text": "Conda packages installieren\nJetzt wo wir ein eigenes Conda Environment erstellt haben (geopython) müssen wir dieses mit Libraries befüllen. Aktuell ist es nämlich noch ziemlich leer, wie ihr mit conda list sehen könnt (versucht es aus!).\nLetzte Woche hatten wir die Packages pandas sowie jupyter lab gebraucht. Diese Packages waren im Environment arcgispro-py3 bereits vorinstalliert.\n\nconda install -c conda-forge jupyterlab   # installiert jupyterlab \nconda install -c conda-forge pandas       # installiert pandas\n-c ist in den obigen install Befehlen ein sogenannter Flag welcher ankündigt, dass gleich der “Channel” angegeben wird. In beiden Fällen nutzen wir den “Channel” conda-forge, d.h. die Packages werden von conda-forge geladen. Welcher Channel angegeben werden muss kann über eine kurze Internetsuche in Erfahrung gebracht werden (z.B. nach “conda install pandas” suchen).\nBestätigt die Rückfragen (Proceed ([y]/n)?) mit y + Enter. Schaut euch nun euer Environment mit conda list an und startet danach jupyter lab indem ihr eben diesen Befehl in der Konsole eingebt. Wechselt aber vorher das Verzeichnis zu einem sinvolleren Ort (wie in Kapitel JupyterLab beschrieben).",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/2_Conda.html#sec-conda-cheat-sheet",
    "href": "C_Programmieren_2/2_Conda.html#sec-conda-cheat-sheet",
    "title": "Conda",
    "section": "Conda cheat sheet",
    "text": "Conda cheat sheet\nIn der folgenden Tabelle werden die Einzelschritte in der Verwendung von Conda nochmal zusammengefasst. Wichtig ist vor allem, wann dieser Schritt nötig ist und wie er ausgeführt wird. Um die Tabelle kompakt zu halten werden gewisse Details als Fussnote verlinkt.\n\n\n\nSchritt\nWann ist dies nötig?\nDetails zum Vorgehen / Befehl für die Konsole3\n\n\n\n\n1. Conda installieren (installiert das Program conda)\neinmalig (ist nicht nötig, wenn ArcGIS Pro installiert ist)\nMiniconda (empfohlen) oder anaconda herunterladen und installieren\n\n\n2. Virtual environment erstellen (erstellt eine neue Arbeitsumgebung)\neinmal pro Projekt nötig (wobei eine environment auch wiederverwendet werden kann)\nin der Konsole: conda create --name geopython\n\n\n3. Virutal environment aktivieren (schaltet den “Bearbeitungsmodus” ein)\njedes mal nöig wenn ein *Erweiterung installiert oder jupyter lab gestartet** werden soll\nin der Konsole 4: activate geopython\n\n\n4. Jupyter lab installieren (fügt der virtuellen Umgebung diese IDE hinzu)\n1x pro environment*\nin der Konsole 5: conda install -c conda-forge jupyterlab\n\n\n5. Jupyter lab starten (startet die IDE “JupyterLab”)\njedes mal, wenn am Projekt gearbeitet wird\nin der Konsole 6: jupyter lab\n\n\n6. Jupyter lab (JL) beenden (beendet “JupyterLab” in der Console)\nwenn ihr die Konsole wieder braucht\nWährend JL läuft, ist die Konsole blockiert. Um JL zu beenden und die Konsole freizugeben: Tastenkombination CTRL + C\n\n\n7. weitere Module 7 installieren (fügt der environment zB pandas hinzu)\njedes mal nötig, wenn ein Modul in einer Environment fehlt8\nin der Konsole 9,10: conda install -c conda-forge pandas",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/2_Conda.html#footnotes",
    "href": "C_Programmieren_2/2_Conda.html#footnotes",
    "title": "Conda",
    "section": "",
    "text": "Neben Conda gibt es noch den “Package Manager” pip, welchen wir im Unterricht aber nicht nutzen werden.↩︎\nGenau genommen ist Conda universell einsetzbar und kann auch Libraries von R und weiteren Programmiersprachen installieren.↩︎\nMit Konsole ist unter Windows cmd gemeint (Windowstaste &gt; cmd). Unter Linux wird bash, auf Mac der Terminal verwendet.↩︎\nUnter Linux: conda activate geopython↩︎\nFalls die richtige environment noch nicht aktiviert ist, muss dies zuerst noch erfolgen (z.B activate geopython).↩︎\nFalls die richtige environment noch nicht aktiviert ist, muss dies zuerst noch erfolgen (z.B activate geopython).↩︎\nIn Programmieren I - III brauchen wir die Module pandas, matplotlib, geopandas und descartes↩︎\nDies macht sich bemerkbar duch die Fehlermeldung ModuleNotFoundError: No module named 'pandas'↩︎\nFalls die richtige environment noch nicht aktiviert ist, muss dies zuerst noch erfolgen (z.B activate geopython).↩︎\nFalls JupyterLabs läuft und dadurch die Konsole blockiert ist, startet ihr am besten eine neue Konsole und aktiviert dort die entsprechende environment. Danach könnt ihr das Modul installieren↩︎",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html",
    "href": "C_Programmieren_2/3_Python_Module.html",
    "title": "Python Modules",
    "section": "",
    "text": "Vergleich R vs. Python\nDer Umgang mit Modulen ist in Python in vielerlei Hinsicht ähnlich wie in R. An dieser Stelle möchten wir die Unterschiede in einem Direktvergleich beleuchten. Dafür verwenden wir ein fiktives Modul namens maler, in Anlehnung an die Analogie des Hausbauens mit Spezialisten (siehe Vorlesungsfolien). Nehmen wir an, dieses Modul existiert als Python Modul wie auch als R Library.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html#vergleich-r-vs.-python",
    "href": "C_Programmieren_2/3_Python_Module.html#vergleich-r-vs.-python",
    "title": "Python Modules",
    "section": "",
    "text": "Erweiterung installieren\nIn R ist die Installation einer Library selbst ein R-Befehl und wird innerhalb von R ausgeführt. Wenn wir keine Quelle angeben, woher die Library heruntergeladen werden soll, wird eine Default-Quelle verwendet, die im System hinterlegt ist (z.B. “https://cloud.r-project.org”).\nIn Python ist dies leider etwas komplizierter, es braucht für die Installation einer Python Library eine Zusatzsoftware wie zum Beispiel conda (siehe dazu das Kapitel Conda). Es gibt auch noch andere Wege, wie zum Beispiel pip, aber diese lassen wir der Einfachheit an dieser Stelle weg.\n\n\nin R:\ninstall.packages(\"maler\")\n\n\n\nIn Python:\nconda install -c conda-foge maler \n\n\n\n\nErweiterung laden\nUm eine Erweiterung nutzen zu können, müssen wir diese sowohl in R wie auch in Python in die aktuelle Session importieren. In R und Python sehen die Befehle folgendermassen aus:\n\n\nin R:\nlibrary(maler)\n\n\n\nin Python:\nimport maler\n\n\n\n\nErweiterung verwenden\nUm eine Funktion aus einer Library in R zu verwenden, kann ich diese Function direkt aufrufen. In Python hingegen muss ich entsprechende Erweiterung der Function mit einem Punkt voranstellen.\nDas ist zwar umständlicher, dafür aber weniger fehleranfällig. Angenommen zwei leicht unterschiedliche Funktionen heissen beide wand_bemalen(). Die eine stammt aus der Erweiterung maler, die andere aus der Erweiterung maurer. Wenn die Funktion in R aufgerufen wird ist nicht klar, aus welcher Library die Funktion verwendet werden soll. In Python ist im nachstehenden Beispiel unmissverständlich, dass wand_bemalen() aus dem Modul maler gemeint ist.\n\n\nin R:\nwand_bemalen()\n\n\n\nin Python:\nmaler.wand_bemalen()",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_Python_Module.html#python-eigenheiten",
    "href": "C_Programmieren_2/3_Python_Module.html#python-eigenheiten",
    "title": "Python Modules",
    "section": "Python Eigenheiten",
    "text": "Python Eigenheiten\nIn Python gibt es in Bezug auf die Verwendung von Modulen ein paar Eigenheiten, die wir aus der R Welt nicht kennen. Es ist wichtig diese Eigenheiten zu kennen, denn man trifft sie immer wieder an.\n\nModul mit Alias importieren\nDa es umständlich sein kann, jedesmal maler.wand_bemalen() voll auszuschreiben, können wir dem Modul beim Import auch einen “Alias” vergeben. Für gewisse populäre Module haben sich solche Aliasse eingebürgert. Beispielsweise wird pandas meist mit dem Alias pd importiert. Es ist sinnvoll, sich an diese Konventionen zu halten. Übertragen auf unser maler beispiel sieht der Import mit einem Alias folgendermassen aus:\nimport maler as m               # importiert \"maler\" mit dem Alias \"m\"\nm.wand_bemalen()                # nun wird \"m.\" vorangestellt statt \"maler.\"\n\n\nEinzelne Function importieren\nEs gibt noch die Variante, explizit eine spezifische Function aus einem Modul zu laden. Wenn man dies macht, kann man die Funktion ohne vorangestelltes Modul nutzen (genau wie in R). Dies sieht folgendermassen aus:\nfrom maler import wand_bemalen  # importiert nur die Funktion \"wand_bemalen\"\nwand_bemalen()                  # das Voranstellen von \"maler.\" ist nun nicht nötig\n\n\nAlle Functions importieren\nZusätzlich ist es möglich, alle Functions aus einem Modul so zu importieren, dass der Modulname nicht mehr erwähnt werden muss. Diese Notation wird nicht empfohlen, aber es ist wichtig sie zu kennen.\nfrom maler import *             # importier alle Funktionen (*) von \"maler\"\nwand_bemalen()                  # das Voranstellen von \"maler.\" ist nun nicht nötig",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Python Modules</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/3_JupyterLab-Desktop.html",
    "href": "C_Programmieren_2/3_JupyterLab-Desktop.html",
    "title": "JupyterLab Desktop",
    "section": "",
    "text": "Letzte Woche haben wir JupyterLab von der Konsole aus gestartet und im Browser verwendet. Dies was für den Einstieg sehr praktisch, da nichts installiert werden musste. Die Erfahrung hat aber gezeigt, dass die Verwendung von JupyterLab im Browser gerade für Einsteiger sehr verwirrend sein kann, weshalb wir euch letzte Woche in Auftrag gegeben haben, JupyterLab Desktop zu installieren.\nUm diese Woche in Python zu coden, könnt ihr als erstes JupyterLab Desktop starten. Diese Anwendung solltet ihr in eurem Startmenü finden.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>JupyterLab Desktop</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/4_Functions_I.html",
    "href": "C_Programmieren_2/4_Functions_I.html",
    "title": "Function Basics",
    "section": "",
    "text": "Ein Grundprinzip von Programmieren ist “DRY” (Don’t repeat yourself). Wenn unser Script viele ähnliche Codezeilen enthält ist das ein Zeichen dafür, dass man besser eine Function schreiben sollte. Das hat viele Vorteile: Unter anderem wird der Code lesbarer, einfacher zu warten und kürzer.\nUm mit Python gut zurechtzukommen ist das Schreiben von eigenen Functions unerlässlich. Dies ist auch nicht weiter schwierig: Eine Function wird mit def eingeleitet, braucht einen Namen, einen Input und einen Output.\nWenn wir zum Beispiel eine Function erstellen wollen die uns grüsst, so geht dies folgendermassen:\n\ndef sag_hallo():\n    return \"Hallo!\"\n\n\nMit def sagen wir: “Jetzt definiere ich eine Function”.\nDanach kommt der Name der Function, in unserem Fall sag_hallo (mit diesem Namen können wir die Function später wieder aufrufen).\nAls Drittes kommen die runden Klammern, wo wir bei Bedarf Inputvariablen (sogenannte Parameter) festlegen können. In diesem ersten Beispiel habe ich keine Parameter festgelegt.\nNach der Klammer kommt ein Doppelpunkt was bedeutet: “jetzt wird gleich definiert, was die Funktion tun soll”.\nAuf einer neuen Zeile wird eingerückt festgelegt, was die Function eben tun soll. Meist sind hier ein paar Zeilen Code vorhanden.\nDie letzte eingerückte Zeile (in unserem Fall ist das die einzige Zeile) gibt mit return an, was die Function zurück geben soll (der Output). In unserem Fall soll sie “Hallo!” zurück geben.\n\nDas war’s schon! Jetzt können wir diese Function schon nutzen:\n\nsag_hallo()\n\n'Hallo!'\n\n\nDiese Function ohne Input ist wenig nützlich. Meist wollen wir der Function etwas - einen Input - übergeben können. Beispielsweise könnten wir der Function unseren Vornamen übergeben, damit wir persönlich gegrüsst werden:\n\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname + \"!\" \n\nNun können wir der Function ein Argument übergeben. In folgendem Beispiel ist vorname ein Parameter, “Guido” ist sein Argument.\n\nsag_hallo(vorname = \"Guido\")\n\n'Hallo Guido!'\n\n\nWir können auch eine Function gestalten, die mehrere Parameter annimmt. Beispielweise könnte sag_hallo() zusätzlich noch einen Parameter nachname erwarten:\n\ndef sag_hallo(vorname, nachname):\n    return \"Hallo \" + vorname + \" \" + nachname + \"!\" \n\n\nsag_hallo(vorname = \"Guido\", nachname = \"van Rossum\")\n\n'Hallo Guido van Rossum!'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>*Function* Basics</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_5.html",
    "href": "C_Programmieren_2/5_Uebung_5.html",
    "title": "Übung 5",
    "section": "",
    "text": "Übung 5.1\nErstelle eine Function, die gruezi heisst, einen Nachnamen als Input annimmt und per Sie grüsst.\nMusterlösung\ndef gruezi(nachname):\n    return \"Guten Tag, \" + nachname\n# Das Resultat soll in etwa folgendermassen aussehen:\ngruezi(nachname = \"van Rossum\")\n\n'Guten Tag, van Rossum'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_5.html#sec-gruezi2",
    "href": "C_Programmieren_2/5_Uebung_5.html#sec-gruezi2",
    "title": "Übung 5",
    "section": "Übung 5.2",
    "text": "Übung 5.2\nErstelle eine neue Funktion gruezi2 welche im Vergleich zu gruezi einen weiteren Parameter namens anrede annimmt.\n\n\nMusterlösung\ndef gruezi2(nachname, anrede):\n    return \"Guten Tag, \" + anrede + \" \" + nachname\n\n\n\n# Das Resultat soll in etwa folgendermassen aussehen:\ngruezi2(nachname = \"van Rossum\", anrede = \"Herr\")\n\n'Guten Tag, Herr van Rossum'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_5.html#übung-5.3",
    "href": "C_Programmieren_2/5_Uebung_5.html#übung-5.3",
    "title": "Übung 5",
    "section": "Übung 5.3",
    "text": "Übung 5.3\nErstelle eine Funktion add die zwei Zahlen summiert.\n\n\nMusterlösung\ndef add(zahl1, zahl2):\n    return zahl1 + zahl2\n\n\n\n# Das Resultat sollte folgendermassen aussehen:\nadd(zahl1 = 2, zahl2 = 10)\n\n12",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_5.html#übung-5.4",
    "href": "C_Programmieren_2/5_Uebung_5.html#übung-5.4",
    "title": "Übung 5",
    "section": "Übung 5.4",
    "text": "Übung 5.4\nErstelle eine Funktion square, welche den Input quadriert.\n\n\nMusterlösung\ndef square(zahl):\n    return zahl * zahl\n\n# oder\n\ndef square(zahl):\n    return zahl**2\n\n\n\n# Das Resultat sollte folgendermassen aussehen:\nsquare(zahl = 5)\n\n25",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/5_Uebung_5.html#übung-5.5",
    "href": "C_Programmieren_2/5_Uebung_5.html#übung-5.5",
    "title": "Übung 5",
    "section": "Übung 5.5",
    "text": "Übung 5.5\nErstelle eine Funktion meter_zu_fuss, die eine beliebige Zahl von Meter in Fuss konvertiert. Zur Erinnerung: 30.48 cm ergeben 1 Fuss.\n\n\nMusterlösung\ndef meter_zu_fuss(meter):\n    fuss = meter * 100 / 30.48\n    return fuss\n\n\n\n# Das Resultat sollte folgendermassen aussehen:\n\nmeter_zu_fuss(meter = 1.80)\n\n5.905511811023622",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Übung 5</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html",
    "href": "C_Programmieren_2/6_Functions_II.html",
    "title": "Function Advanced",
    "section": "",
    "text": "Standart-Werte\nMan kann für einzelne (oder alle) Parameter auch Standardwerte festlegen. Das sind Werte die dann zum Zug kommen, wenn der Nutzer der Funktion das entsprechende Parameter leer lässt. Schauen wir dazu nochmals sag_hallo() an.\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname + \"!\"\nUm diese Funktion zu nutzen muss dem Parameter vorname ein Argument übergeben werden, sonst erhalten wir eine Fehlermeldung.\nsag_hallo()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 sag_hallo()\n\nTypeError: sag_hallo() missing 1 required positional argument: 'vorname'\nWenn wir möchten, dass gewisse Parameter auch ohne Argument auskommen, dann könnnen wir einen Standartwert festlegen. So wird der Parameter optional. Bespielsweise könnte sag_hallo() einfach Hallo Du! zurückgeben, wenn kein Vorname angegeben wird. Um dies zu erreichen, definieren wir den Standartwert bereits innerhalb der Klammer, und zwar folgendermassen:\ndef sag_hallo(vorname = \"Du\"):\n    return \"Hallo \" + vorname + \"!\" \n\n# Wenn \"vorname\" nicht angegeben wird:\nsag_hallo()\n\n'Hallo Du!'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#standart-werte",
    "href": "C_Programmieren_2/6_Functions_II.html#standart-werte",
    "title": "Function Advanced",
    "section": "",
    "text": "Wichtig\n\n\n\nWenn mehrere Parameter in einer Funktion definiert werden, dann kommen die optionalen Parameter immer zum Schluss.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#reihenfolge-der-argumente",
    "href": "C_Programmieren_2/6_Functions_II.html#reihenfolge-der-argumente",
    "title": "Function Advanced",
    "section": "Reihenfolge der Argumente",
    "text": "Reihenfolge der Argumente\nWenn die Argumente in der gleichen Reihenfolge eingegeben werden, wie sie in der Function definiert sind, müssen die Parameter nicht spezifiziert werden (z.B: anrede=, nachname=).\n\ndef gruezi2(nachname, anrede):\n    return \"Guten Tag, \" + anrede + \" \"+nachname\n\ngruezi2(\"van Rossum\", \"Herr\")\n\n'Guten Tag, Herr van Rossum'\n\n\nWenn wir die Reihenfolge missachten, ist der Output unserer Funktion fehlerhaft:\n\ngruezi2(\"Herr\", \"van Rossum\")\n\n'Guten Tag, van Rossum Herr'\n\n\nAber wenn die Parameter der Argumente spezifiziert werden, können wir sie in jeder beliebigen Reihenfolge auflisten:\n\ngruezi2(anrede = \"Herr\", nachname = \"van Rossum\")\n\n'Guten Tag, Herr van Rossum'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#funktionen-auf-mehreren-zeilen",
    "href": "C_Programmieren_2/6_Functions_II.html#funktionen-auf-mehreren-zeilen",
    "title": "Function Advanced",
    "section": "Funktionen auf mehreren Zeilen",
    "text": "Funktionen auf mehreren Zeilen\nBisher waren unsere Funktionen sehr kurz und einfach und wir benötigten dafür immer nur zwei Zeilen: Die erste Zeile begann die Function-Definition (def..) und die zweite Zeile retournierte bereits die Lösung return(...).\nZwischen diesen beiden Komponenten haben wir aber viel Platz, den wir uns zu Nutze machen können. Wir können hier Kommentare hinzufügen wie auch unsere Funktion in Einzelschritte aufteilen um den Code lesbarer zu machen.\n\ndef gruezi2(nachname, anrede):\n    \"\"\" \n    Meine coole Grüezi funktion\n    Diese Funktion soll Menschen freundlich grüssen. \n    Sie nimmt zwei Inputs: nachname und andrede, beides \"strings\"\n    \"\"\"\n    gruss = \"Guten Tag, \" + anrede + \" \"+nachname\n    return gruss\n\nAllgemeine Kommentare werden in Python mit # hinzugefügt, Funktionen werden aber mit drei Anführungs- und Schlusszeichen kommentiert. Diese Kommentare erscheinen eleganterweise wenn man die Hilfe zu dieser Funktion mit help() aufruft:\n\nhelp(gruezi2)\n\nHelp on function gruezi2 in module __main__:\n\ngruezi2(nachname, anrede)\n    Meine coole Grüezi funktion\n    Diese Funktion soll Menschen freundlich grüssen.\n    Sie nimmt zwei Inputs: nachname und andrede, beides \"strings\"",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#globale-und-lokale-variabeln",
    "href": "C_Programmieren_2/6_Functions_II.html#globale-und-lokale-variabeln",
    "title": "Function Advanced",
    "section": "Globale und Lokale Variabeln",
    "text": "Globale und Lokale Variabeln\nInnerhalb einer Function können nur die Variabeln verwendet werden, die der Function als Argumente übergeben (oder innerhalb der Funktion erstellt) werden. Diese nennt man “lokale” Variabeln und sind nur lokal in der Function vorhanden. Im Gegensatz dazu stehen “globale” Variabeln, welche Teil der aktuellen Session sind.\nVersuchen wir das mit einem Beispiel zu verdeutlichen. Angenommen wir definieren gobal die Variabel vorname:\n\n# Wir definieren globale Variabel\nvorname = \"Guido\"\n\n# Nun erstellen wir eine Function, welche diese Variabel (\"vorname\") nutzen soll:\ndef sag_hallo(vorname):\n    return \"Hallo \" + vorname\n\n# Wenn wir jetzt aber die Function ausführen wollen, entsteht die Fehlermeldung,\n# dass \"vorname\" fehlt (obwohl wir vorname ja schon definiert haben)\nsag_hallo()\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[9], line 10\n      6     return \"Hallo \" + vorname\n      8 # Wenn wir jetzt aber die Function ausführen wollen, entsteht die Fehlermeldung,\n      9 # dass \"vorname\" fehlt (obwohl wir vorname ja schon definiert haben)\n---&gt; 10 sag_hallo()\n\nTypeError: sag_hallo() missing 1 required positional argument: 'vorname'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/6_Functions_II.html#sec-functions-lambda",
    "href": "C_Programmieren_2/6_Functions_II.html#sec-functions-lambda",
    "title": "Function Advanced",
    "section": "Lambda-Function",
    "text": "Lambda-Function\nMit dem Begriff lambda kann eine Function verkürzt geschrieben werden. Wir werden dies im Unterricht kaum verwenden, es ist aber doch gut davon gehört zu haben. Nachstehend wird die Funktion sag_hallo() in der bekannten, wie auch in der verkürzten Form definiert.\n\n\nHerkömmliche Weise:\ndef sag_hallo(vorname):\n    return \"Hi \"+vorname\n\n\n\nVerkürzt mit lambda:\nsag_hallo = lambda vorname: \"Hi \"+vorname",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>*Function* Advanced</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_6.html",
    "href": "C_Programmieren_2/7_Uebung_6.html",
    "title": "Übung 6",
    "section": "",
    "text": "Übung 6.1\nErstelle eine Funktion namens times, die zwei Zahlen miteinander multipliziert.\nMusterlösung\ndef times(x, y):\n    return x * y\nMusterlösung\ntimes(2, 2)",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_6.html#übung-6.2",
    "href": "C_Programmieren_2/7_Uebung_6.html#übung-6.2",
    "title": "Übung 6",
    "section": "Übung 6.2",
    "text": "Übung 6.2\nDie eben erstellte Funktion times benötigt 2 Argumente (die miteinander multipliziert werden). Wandle den zweiten Parameter in einen optionalen Parameter um (mit dem Defaultwert 1).\nZusatzaufgabe: Was passiert, wenn du den ersten Parameter in einen optionalen Parameter umwandelst?\n\n\nMusterlösung\ndef times(x, y = 1):\n    return x * y\n\n\n\n\nMusterlösung\ntimes(3)\n\n\n\n\nMusterlösung\n# (Zusatzaufgabe)\ndef times(x = 1, y):\n    return x * y",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_6.html#sec-ex-functions-bmi",
    "href": "C_Programmieren_2/7_Uebung_6.html#sec-ex-functions-bmi",
    "title": "Übung 6",
    "section": "Übung 6.3",
    "text": "Übung 6.3\nErstelle eine Funktion namens bmi, die aus Grösse und Gewicht einen BodyMassIndex berechnet (\\(BMI=\\frac{m}{l^2}\\), \\(m\\): Körpermasse in Kilogramm, \\(l\\): Körpergrösse in Meter). Das Resultat soll etwa folgendermassen aussehen:\n\n\nMusterlösung\ndef bmi(groesse_m, gewicht_kg):\n    return gewicht_kg / (groesse_m * groesse_m)\n\n\n\nbmi(groesse_m = 1.8, gewicht_kg = 88)\n\n27.160493827160494",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_6.html#übung-6.4",
    "href": "C_Programmieren_2/7_Uebung_6.html#übung-6.4",
    "title": "Übung 6",
    "section": "Übung 6.4",
    "text": "Übung 6.4\nErstelle eine Funktion mittelwert(), welche den Mittelwert aus einer Liste (List) von Zahlen berechnet. Nutze dazu sum() und len() analog Uebung 2.6. Das Resultat sollte folgendermassen aussehen:\n\n\nMusterlösung\ndef mittelwert(zahlen):\n    return sum(zahlen) / len(zahlen)\n\n\n\nmeine_zahlen = [50, 100, 550, 1000]\nmittelwert(meine_zahlen)\n\n425.0",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_6.html#übung-6.5",
    "href": "C_Programmieren_2/7_Uebung_6.html#übung-6.5",
    "title": "Übung 6",
    "section": "Übung 6.5",
    "text": "Übung 6.5\nErstelle eine Funktion celsius_zu_farenheit, welche eine beliebige Zahl von Grad Celsius in Grad Farenheit konvertiert. Zur Erinnerung: Temperatur in °F = Temperatur in °C x 1,8 + 32.\n\n\nMusterlösung\ndef celsius_zu_farenheit(celsius):\n    farenheit = celsius * 1.8 + 32\n    return farenheit\n\n\nDas Resultat sollte folgendermassen aussehen:\n\ncelsius_zu_farenheit(celsius = 25)\n\n77.0",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/7_Uebung_6.html#übung-6.6",
    "href": "C_Programmieren_2/7_Uebung_6.html#übung-6.6",
    "title": "Übung 6",
    "section": "Übung 6.6",
    "text": "Übung 6.6\nSchreibe die letzte Funktion celsius_zu_farenheit in der lambda Notation.\n\n\nMusterlösung\ncelsius_in_farenheit2 = lambda celsius: celsius * 1.8 + 32",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Übung 6</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/8_If_else.html",
    "href": "C_Programmieren_2/8_If_else.html",
    "title": "If / Else",
    "section": "",
    "text": "Ein wichtiger Bestandteil von Programmieren sind Fallunterscheidungen. Mit Fallunterscheidungen können wir mit unterschiedlichen Situationen verschieden umgehen.\nDie einfache Fallunterscheidung ist die bedingte Verzweigung. Die Syntax der einfachen if-Anweisung lautet folgendermassen:\nif Bedingung:\n    # Anweisungen 1\nelse:\n    # Anweisungen 2\nZum Beispiel:\n\n# hier alter eingeben:\nalter = 35\n\nif alter &lt; 40:\n    print(\"Backstreet Boys: 'I want it that way'\")\nelse:\n    print(\"The Jackson 5: 'I want you back'\")\n\nBackstreet Boys: 'I want it that way'\n\n\nWenn wir mehr als zwei verschiedene Fälle haben, können diese mit elif dazwischen geschaltet werden.\nif Bedingung1:\n    # Anweisungen 1\nelif Bedingung2:\n    # Anweisungen 2\nelif Bedingung3:\n    # Anweisungen 3\nelse:\n    # Anweisungen 4\nZum Beispiel:\n\n# hier alter eingeben:\nalter = 35\n\nif alter &lt; 20:\n    print(\"Kesha: 'Tik Tok'\")\nelif alter &lt; 30:\n    print(\"Destiny's Child: 'Say My Name'\")\nelif alter &lt; 40:\n    print(\"Mariah Carey: 'Vision of love'\")\nelse:\n    print(\"Blondie: 'Call me'\")\n\nMariah Carey: 'Vision of love'\n\n\nSolche Fallunterscheidungen sind vor allem in Funktionen sehr praktisch. Aus dem obigen Beispiel können wir beispielsweise eine Funktion erstellen, die uns ein Lied in Abhängigkeit zu unserem Alter vorschlägt:\n\ndef suggest_song(alter):\n    if alter &lt; 20:\n        song = \"Kesha: 'Tik Tok'\"\n    elif alter &lt; 30:\n        song = \"Destiny's Child: 'Say My Name'\"\n    elif alter &lt; 40:\n        song = \"Mariah Carey: 'Vision of love'\"\n    else:\n        song = \"Blondie: 'Call me'\"\n    return \"I suggest the song \" + song + \". Enjoy!\"\n\nsuggest_song(24)\n\n\"I suggest the song Destiny's Child: 'Say My Name'. Enjoy!\"\n\n\nDabei ist wichtig, dass man sich jeweils die Ausführungslogik vor Augen führt.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>If / Else</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/9_Uebung_7.html",
    "href": "C_Programmieren_2/9_Uebung_7.html",
    "title": "Übung 7",
    "section": "",
    "text": "Übung 7.1\nErstelle eine neue Funktion gruezi3 die gruezi (aus Übung 5.1) um einem weiteren Parameter uhrzeit erweitert. Die Funktion soll vor 18 Uhr (uhrzeit &lt; 18) mit “Guten Tag” und sonst mit “Guten Abend” grüssen. Um es einfach zu halten: Die Zeitangbe muss in Dezimalzahlen erfolgen (also nicht 20:15 Uhr sondern 20.25).\nMusterlösung\ndef gruezi3(nachname, uhrzeit):\n    if(uhrzeit &lt; 18):\n        grussform = \"Tag\"\n    else:\n        grussform = \"Abend\"\n\n    return \"Guten \" + grussform + \" \" + nachname\n# die Lösung sollte etwa folgendermasssen funktionieren:\n\ngruezi3(\"Guido\", uhrzeit = 21)\n\n'Guten Abend Guido'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/9_Uebung_7.html#übung-7.2",
    "href": "C_Programmieren_2/9_Uebung_7.html#übung-7.2",
    "title": "Übung 7",
    "section": "Übung 7.2",
    "text": "Übung 7.2\nErweitere die Funktion gruezi2 so, dass zwischen folgende Uhrzeiten berücksichtigt werden:\n\n\n\nTabelle 36.1: Uhrzeiten und ihre Begrüssungsformen\n\n\n\n\n\nUhrzeit\nBegrüssungsform\n\n\n\n\n\n5 bis 11 Uhr\nGuten Morgen\n\n\n\n11 bis 18 Uhr\nGuten Tag\n\n\n\n18 bis 22 Uhr\nGuten Abend\n\n\n\n22 bis 5 Uhr\nGute Nacht\n\n\n\n\n\n\n\nDas Problem ist etwas schwierig zu Packen weil wir die “von - bis” Uhrzeiten in eine Ja/Nein Logik überführen müssen. Überlege dir zuerst eine Ausführungslogik und schreibe danach die if, elifund else Operationen. Im Dropdown unten ist unser Vorschlag.\n\n\n\n\n\n\nHinweis\n\n\n\n\n\n\n\n\n\n\n\nMusterlösung\ndef gruezi2(nachname, anrede, uhrzeit):\n    if(uhrzeit &lt; 5):\n        was = \"Gute Nacht\"\n    elif(uhrzeit &lt; 11):\n        was = \"Guten Morgen\"\n    elif(uhrzeit &lt; 18):\n        was = \"Guten Tag\"\n    elif(uhrzeit &lt; 22):\n        was = \"Guten Abend\"\n    else:\n        was = \"Gute Nacht\"\n\n    return was + \", \" + anrede + \" \"+ nachname\n\n\nTeste die Funktion mit verschiedenen Optionen um sicherzustellen, dass sie richtig funktioniert.",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/9_Uebung_7.html#übung-7.2-1",
    "href": "C_Programmieren_2/9_Uebung_7.html#übung-7.2-1",
    "title": "Übung 7",
    "section": "Übung 7.2",
    "text": "Übung 7.2\nErweitere die Funktion bmi aus Übung 6.3 so, dass statt dem berechneten BMI der “Nutritional status” aufgrund der WHO Klassifizierung ausgegeben wird:\n\n\n\nTabelle 36.2: WHO Nutritional status\n\n\n\n\n\nBMI\nNutritional status\n\n\n\n\nBelow 18.5\nUnderweight\n\n\n18.5–24.9\nNormal weight\n\n\n25.0–29.9\nPre-obesity\n\n\n30.0–34.9\nObesity class I\n\n\n35.0–39.9\nObesity class II\n\n\nAbove 40\nObesity class III\n\n\n\n\n\n\n\n\nMusterlösung\ndef bmi2(groesse_m, gewicht_kg):\n    bmi = gewicht_kg / (groesse_m * groesse_m)\n    if(bmi &lt; 18.5):\n        cat = \"Underweight\"\n    elif(bmi &lt;= 24.9):\n        cat = \"Normal weight\"\n    elif(bmi &lt;= 29.9):\n        cat = \"Pre-obesity\"\n    elif(bmi &lt;= 34.9):\n        cat = \"Obesity class I\"\n    elif(bmi &lt;= 39.9):\n        cat = \"Obesity class II\"\n    else:\n        cat = \"Obesity class III\"\n    return \"Who classification: \" + cat\n\n\n\n# Der Output sollte etwa folgedermassen aussehen\nbmi2(1.7, 70)\n\n'Who classification: Normal weight'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Übung 7</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/10_Zufallzahlen.html",
    "href": "C_Programmieren_2/10_Zufallzahlen.html",
    "title": "Zufallszahlen generieren",
    "section": "",
    "text": "Im Block “Datenqualität und Unsicherheit” habt ihr euch bereits mit Zufallszahlen und Simulationen auseinandergesetzt. Programmiersprachen sind für eine solche Anwendung sehr gut geeignet, und deshalb werden wir in diesem Abschnitt eine Erweiterung zur Erstellung von Zufallszahlen kennenlernen. Diese Erweiterung lautet random und ist Teil der “Python Standard Library”, was bedeutet das dieses Erweiterung bereits installiert ist, und wir sie nicht installieren müssen.\n\nimport random\n\n\nrandom.seed(2)\n\nInnerhalb vom random gibt es zahlreiche Funktionen um Zufallszahlen zu generieren, je nachdem was unsere Anforderungen an die Zufallszahl ist. Eine Anforderung könnte zum Beispiel sein, dass die Zahl innerhalb eines bestimmten Bereichs luegen soll (z.B. “generiere eine Zufallszahl zwischen 1 und 9”). Oder aber, dass sie eine ganze Zahl sein muss. Weiter könnte die Anforderung sein, dass sie aus einer bestimmten Verteilung kommen sollte, zum Beispiel einer Normalverteilung. In diesem letzten Fall müssen wir den Mittlwert sowie die Standartabweichung unserer Verteilung angeben.\nUm eine ganzzahlige Zufallszahl zwischen 1 und 9 zu generieren, können wir die Funktion randrange() nutzen:\n\nrandom.randrange(start = 1, stop = 10)\n\n1\n\n\nWenn wir auf diese Weise mit randrange() immer wieder neue Zufallszahlen generieren fällt auf, dass die Verteilung der Zahlen ziemlich gleichmässig ist. Es ist also gleich wahrscheinlich eine 9 zu bekommen, wie eine 1 oder eine 5. Die Zahlen kommen also aus einer “uniformen” Verteilung. Um dies zu verdeutlichen generiere ich in den folgenden Codezeilen 500 Zufallszahlen zwischen 1 und 9 mit der Funktion randrange und visualisiere die Häufigkeit der einzelnen Zahlen in einem Histogramm.\n\n# erstellt eine Liste von Zufallszahlen 1 - 9\n# (lernen wir zu einem späteren Zeitpunkt)\na = [random.randrange(1, 10) for x in range(500)]\n\nimport pandas as pd\n\n# visualisiert die zufällig generierten Zahl in Form \n# eines Histogramms (lernen wir ebenfalls später)\npd.Series(a).plot(kind = \"hist\", bins = range(1, 11), edgecolor = \"black\", align = \"left\", xticks = range(1, 10))\n\n\n\n\n\n\n\n\nDie Funktion randrange() generiert nur ganzzahlige Zufallszahlen. Wenn wir aber eine Zufallszahl mit Nachkommastellen brauchen, verwenden wir die Funktion uniform().\nUm Zufallszahlen aus einer “Normalverteilung” zu erhalten, verwenden wir die Funktion normalvariate. Hier müssen wir den Mittelwert und die Standartabweichung dieser Verteilung angeben. Tatsächlich können wir bei dieser Variante keine Minimum- und Maximumwerte festlegen: Theoretisch könnte der Generator jeden erdenklichen Zahlenwert rausspucken, am wahrscheinlichsten ist jedoch eine Zahl nahe am angegebenen Mittelwert.\n\n# mu = Mittelwert, sigma = Standartabweichung\nrandom.normalvariate(mu = 5, sigma = 2)\n\n2.5056884809480864\n\n\nWenn wir die obige Funktion 10’000x laufen lassen und uns das Histogramm der generierten Zahlen anschauen, dann zeichnet sich folgendes Bild ab.\n\nb = [random.normalvariate(mu = 5, sigma = 2) for b in range(10000)]\npd.Series(b).plot(kind = \"hist\", bins = 30, edgecolor = \"black\")",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Zufallszahlen generieren</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_8.html",
    "href": "C_Programmieren_2/11_Uebung_8.html",
    "title": "Übung 8",
    "section": "",
    "text": "Übung 8.1\nBevor wir mit Koordinaten arbeiten wollt ihr euch zuerst mit dem Modul random vertraut machen. Importiere das Modul random und generiere eine Zufallszahl zwischen -100 und +100 aus einer uniformen Verteilung sowie aus einer Normalverteilung mit Mittelwert 100 und Standartabweichung 20.\nMusterlösung\nimport random\n\nrandom.uniform(-100, 100)\n\nrandom.normalvariate(100, 20)",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_8.html#übung-8.2",
    "href": "C_Programmieren_2/11_Uebung_8.html#übung-8.2",
    "title": "Übung 8",
    "section": "Übung 8.2",
    "text": "Übung 8.2\nNun wollen wir uns den Koordinaten zuwenden. Erstelle als erstes zwei Dummykoordinaten x_start und y_start mit jeweils dem Wert 0. Diese sollen als “Ursprungskoordinaten” dienen.\n\n\nMusterlösung\nx_start = 0\ny_start = 0",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_8.html#übung-8.3",
    "href": "C_Programmieren_2/11_Uebung_8.html#übung-8.3",
    "title": "Übung 8",
    "section": "Übung 8.3",
    "text": "Übung 8.3\nGeneriere nun eine Zufallszahl, die aus einer Normalverteilung stammt und die in etwa zwischen -100 und +100 liegt. Weise diese Zahl der Variabel x_offset zu. Generiere danach eine zweite Zufallszahl (auf die gleiche Art) und weise diese y_offset zu.\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nÜberlege dir, welcher Mittelwert Sinn macht um Werte zwischen -100 und +100 zu bekommen. Welche Zahl liegt zwischen -100 und +100?\nÜberlege dir als nächstes, welche Standartabweichung sinnvoll wäre. Zur Erinnerung: Etwa 68% der Werte liegen inerhalb von +/- 1 Standartabweichung (SD), 95% innerhalb von +/- 2 SD, 99% innerhalb von 3 SD (siehe unten):\n\n\n\n\n\n\nAbbildung 38.2: Normalverteilung und die Anteile innerhalb von 1 Standartabweichung (Mittelwert \\(\\mu\\) minus Standartabweichung \\(\\sigma\\)), 2 Standartabweichungen (\\(\\mu - 2\\times\\sigma)\\) und 2 Standartabweichungen (\\(\\mu - 3\\times\\sigma)\\). Quelle: cobocards\n\n\n\n\n\n\n\n\nMusterlösung\n# Normalverteilte Werte mit Mittelwert 0 und Standartabweichung 100  \n# Achtung: bei dieser Standartabweichung sind ca 30% der Werte &gt; 100!\nx_offset = random.normalvariate(0, 100)\ny_offset = random.normalvariate(0, 100)\n\nx_offset\ny_offset",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_8.html#übung-8.4",
    "href": "C_Programmieren_2/11_Uebung_8.html#übung-8.4",
    "title": "Übung 8",
    "section": "Übung 8.4",
    "text": "Übung 8.4\nAddiere nun die Zufallszahlen x_offset und y_offset jeweils zu den Dummykoordinaten x_start und y_start und weise diese neuen Koordinaten x_neu und y_neu zu. Die neuen Werte stellen die leicht verschobenen Ursprungskoordinaten dar. In meinem Fall sind diese um 10.2 Meter nach Osten (positiver Wert) bzw. 4.4 Meter nach Süden (negativer Wert) verschoben worden.\n\n\nMusterlösung\nx_offset = 10.246170309600945\ny_offset = -4.443904000288846\n\nx_neu = x_start + x_offset\ny_neu = y_start + y_offset\n\n\n\nx_neu\n\n10.246170309600945\n\n\n\ny_neu\n\n-4.443904000288846\n\n\n\n\nCode für die Visualisierung (nur FYI)\nimport pandas as pd\n\nmypoints = pd.DataFrame({\n    \"x\": [x_start, x_neu],\n    \"y\": [y_start, y_neu],\n    \"typ\": [\"start\", \"neu\"]\n    }\n)\n\nfrom matplotlib import pyplot as plt\n\nmypoints.plot(\"x\", \"y\", kind = \"scatter\", xlim = [-100, 100], ylim = [-100, 100], c = [\"red\", \"blue\"], title = \"Ursprung (rot) und Simulation (blau)\")",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_8.html#sec-ex-offset-function",
    "href": "C_Programmieren_2/11_Uebung_8.html#sec-ex-offset-function",
    "title": "Übung 8",
    "section": "Übung 8.5",
    "text": "Übung 8.5\nNun haben wir das zufällige Verschieben eines Einzelpunktes am Beispiel einer Dummykoordinaten (0/0) durchgespielt. In der nächsten Aufgabe (Funktionen in DataFrames) werden wir alle unsere Zeckenstichkoordinaten auf diese Weise zufällig verschieben um einen simulierten Zeckenstichdatensatz ähnlich wie Abbildung 38.1 zu erhalten.\nDafür brauchen wir die eben erarbeiteten Einzelschritte als Funktion, um diese auf alle Zeckenstiche anwenden zu können.\nErstelle jetzt eine Funktion namens offset_coordinate welche als Input eine x oder y-Achsenwert annimmt und eine leicht verschobene Wert zurückgibt.** Integriere die Standartabweichung der Verteilung als optionalen Parameter mit dem Namen distance und einem Defaultwert von 100.\n\n\nMusterlösung\ndef offset_coordinate(old, distance = 100):\n    new = old + random.normalvariate(0, distance)\n    return new\n\n\n\n# die Funktion sollte so funktionieren:\noffset_coordinate(x_start)\n\n-101.51340458181195",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/11_Uebung_8.html#sec-offset-vis",
    "href": "C_Programmieren_2/11_Uebung_8.html#sec-offset-vis",
    "title": "Übung 8",
    "section": "Übung 8.6",
    "text": "Übung 8.6\nNun ist es wichtig, dass wir unser Resultat visuell überprüfen. Im Beispiel unten wende ich die in der letzten Übung erstellte Funktion offset_coordinate() 1’000 mal auf die Dummykoordinate an. Nutze deine Funktion offset_coordinate um eine Visualisierung gemäss untenstehendem beispiel zu machen.\n\nx_neu_list = [offset_coordinate(x_start) for i in range(1, 1000)]\ny_neu_list = [offset_coordinate(y_start) for i in range(1, 1000)]\n\n# Liste in eine Pandas DataFrame überführen\nmysim = pd.DataFrame({\"x\" : x_neu_list, \"y\" : y_neu_list})\n\nmysim.plot(\"x\", \"y\", kind = \"scatter\")\n\nfrom matplotlib import pyplot as plt\nplt.axis(\"equal\")\n\n(np.float64(-348.6544067221421),\n np.float64(379.7643578278204),\n np.float64(-329.8906267126254),\n np.float64(343.67346774161706))",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Übung 8</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/12_Funktionen_in_DataFrames.html",
    "href": "C_Programmieren_2/12_Funktionen_in_DataFrames.html",
    "title": "Funktionen in DataFrames",
    "section": "",
    "text": "In dieser Aufgabe haben wir das Ziel, die in der letzten Aufgabe (Zufallszahlen generieren) erstellte Funktion offset_coordinate() auf alle Zeckenstich-Koordinaten anwenden. Bildlich gesprochen: Wir nehmen unsere Zeckenstichdatensatz und schütteln ihn einmal durch. So erhalten wir einen Datensatz ähnlich wie in Abbildung 38.1 mit dem Unterschied, dass jede Zeckenstichmeldung nicht eine Wolke von simulierten Punkten enthält, sondern nur einen einzelnen Punkt.\nNutze hier die Datei zeckenstiche.csv von letzter Woche (siehe Tabelle 1). Erstelle ein neues Notebook und nutze nachstehenden Code um die nötigen Module und Functions zu haben:\n\nimport pandas as pd\n\ndef offset_coordinate(old, distance = 100):\n    import random\n    new = old + random.normalvariate(0,distance)\n\n    return new\n\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n#           ______________________↗____________________\n#         &lt; verwendet hier euren eigenen relativen pfad &gt;\n#           -------------------------------------------\n     \n\nzeckenstiche\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[1], line 9\n      5     new = old + random.normalvariate(0,distance)\n      7     return new\n----&gt; 9 zeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n     10 #           ______________________↗____________________\n     11 #         &lt; verwendet hier euren eigenen relativen pfad &gt;\n     12 #           -------------------------------------------\n     15 zeckenstiche\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)\n   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)\n    617 _validate_names(kwds.get(\"names\", None))\n    619 # Create the parser.\n--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)\n    622 if chunksize or iterator:\n    623     return parser\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)\n   1617     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n   1619 self.handles: IOHandles | None = None\n-&gt; 1620 self._engine = self._make_engine(f, self.engine)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880, in TextFileReader._make_engine(self, f, engine)\n   1878     if \"b\" not in mode:\n   1879         mode += \"b\"\n-&gt; 1880 self.handles = get_handle(\n   1881     f,\n   1882     mode,\n   1883     encoding=self.options.get(\"encoding\", None),\n   1884     compression=self.options.get(\"compression\", None),\n   1885     memory_map=self.options.get(\"memory_map\", False),\n   1886     is_text=is_text,\n   1887     errors=self.options.get(\"encoding_errors\", \"strict\"),\n   1888     storage_options=self.options.get(\"storage_options\", None),\n   1889 )\n   1890 assert self.handles is not None\n   1891 f = self.handles.handle\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'data/zeckenstiche.csv'",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Funktionen in *DataFrames*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_9.html",
    "href": "C_Programmieren_2/13_Uebung_9.html",
    "title": "Übung 9",
    "section": "",
    "text": "Übung 9.1\nMache dich nochmals damit vertraut, einzelne Spalten zu selektieren. Schau dir DataFrames nochmals an wenn du nicht mehr weisst wie das geht.\nMusterlösung\nzeckenstiche[\"x\"]\nzeckenstiche[\"y\"]",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_9.html#übung-9.2",
    "href": "C_Programmieren_2/13_Uebung_9.html#übung-9.2",
    "title": "Übung 9",
    "section": "Übung 9.2",
    "text": "Übung 9.2\nMache dich nochmals damit vertraut, wie man neue Spalten erstellt. Schau dir DataFrames nochmals an wenn du nicht mehr weisst wie das geht. Erstelle ein paar neue Spalten nach dem Beispiel unten um die Hangriffe zu üben. Lösche die Spalten im Anschluss wieder mit del zeckenstiche['test1'] etc.\n\n\nMusterlösung\nzeckenstiche[\"test1\"] = \"test1\"\n\nzeckenstiche[\"test2\"] = 10\n\nzeckenstiche[\"test3\"] = range(10)\n\n\n\n# zeckenstiche könnte danach folgendermassen aussehen:\nzeckenstiche\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 2\n      1 # zeckenstiche könnte danach folgendermassen aussehen:\n----&gt; 2 zeckenstiche\n\nNameError: name 'zeckenstiche' is not defined\n\n\n\n\n# unnötigen Spalten wieder entfernen:\ndel zeckenstiche['test1']\ndel zeckenstiche['test2']\ndel zeckenstiche['test3']\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 # unnötigen Spalten wieder entfernen:\n----&gt; 2 del zeckenstiche['test1']\n      3 del zeckenstiche['test2']\n      4 del zeckenstiche['test3']\n\nNameError: name 'zeckenstiche' is not defined",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_9.html#sec-ex-apply",
    "href": "C_Programmieren_2/13_Uebung_9.html#sec-ex-apply",
    "title": "Übung 9",
    "section": "Übung 9.3",
    "text": "Übung 9.3\npandas kennt eine ganze Familie von Methoden, um Spalten zu Manipulieren und Daten zu Aggregieren (apply, map, mapapply, assign). Es würde den Rahmen dieses Kurses sprengen, die alle im Detail durchzugehen, es lohnt sich aber sehr sich mit diesen auseinanderzusetzen wenn man sich näher mit Python befassen möchte.\nIm unserem Fall brauchen wir lediglich die Methode apply um die Funktion offset_coordinate() auf die Zeckenstichkoordinaten anzuwenden. Dabei gehen wir wie folgt for:\n\nzeckenstiche[\"x\"].apply(offset_coordinate)\n#\\______1_______/ \\_2_/\\_______3_________/\n\n# 1. Spalte selektieren ([\"x\"])\n# 2. Methode \"apply\" aufrufen\n# 3. Function übergeben\n\nVerwende dieses Schema um auch offset_coordinate auf die y Spalte anzuwenden und speichere den Output dieser beiden Operationen als neue Spalten x_sim sowie y_sim. Die DataFrame zeckenstiche sollte danach wie folgt aussehen:\n\n\nMusterlösung\nzeckenstiche[\"x_sim\"] = zeckenstiche[\"x\"].apply(offset_coordinate)\nzeckenstiche[\"y_sim\"] = zeckenstiche[\"y\"].apply(offset_coordinate)\n\n\n\nzeckenstiche\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 zeckenstiche\n\nNameError: name 'zeckenstiche' is not defined",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_9.html#sec-ex-param",
    "href": "C_Programmieren_2/13_Uebung_9.html#sec-ex-param",
    "title": "Übung 9",
    "section": "Übung 9.4",
    "text": "Übung 9.4\nIn Übung 9.3 haben wir unsere Funktion offset_coordinate aufgerufen, ohne den Parameter distance zu spezifizieren. Dies war möglich, weil wir für distance einen Defaultwert festgelegt hatten (100 Meter). Wir können aber auch zusätzliche Parameter kommagetrennt nach der Funktion angeben. Dies sieht folgendermassen aus:\n\nzeckenstiche[\"x\"].apply(offset_coordinate, distance = 200)\n\nNutze diese Möglichkeit, um den Offset (distance) auf maximal 10 Meter zu reduzieren.\n\n\nMusterlösung\nzeckenstiche[\"x_sim\"] = zeckenstiche[\"x\"].apply(offset_coordinate, distance = 10)\nzeckenstiche[\"y_sim\"] = zeckenstiche[\"y\"].apply(offset_coordinate, distance = 10)",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/13_Uebung_9.html#übung-9.5",
    "href": "C_Programmieren_2/13_Uebung_9.html#übung-9.5",
    "title": "Übung 9",
    "section": "Übung 9.5",
    "text": "Übung 9.5\nUm die Original x/y-Werte sowie die simulierten Daten im gleichen Plot darzustellen, wird folgendermassen vorgegangen: Der erste Datensatz wird mit .plot() visualisiert, wobei der Output einer Variabel (z.B. basemap) zugewiesen wird. Danach wird der zweite Datensatz ebenfalls mit .plot() visualisiert, wobei auf den ersten Plot via dem Argument ax verwiesen wird.\nBei den roten Punkten handelt es sich um die Original-Zeckenstichen, bei den blauen um die simulierten (leicht verschoben) Zeckenstiche. Visualisiere deine eigenen Zeckenstiche auf diese Weise.\n\nfrom matplotlib import pyplot as plt\n\nbasemap = zeckenstiche.plot(\"x\", \"y\", kind = \"scatter\", color = \"red\")\nzeckenstiche.plot(\"x_sim\", \"y_sim\", kind = \"scatter\", ax = basemap, color = \"blue\")\n\nplt.axis(\"equal\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 3\n      1 from matplotlib import pyplot as plt\n----&gt; 3 basemap = zeckenstiche.plot(\"x\", \"y\", kind = \"scatter\", color = \"red\")\n      4 zeckenstiche.plot(\"x_sim\", \"y_sim\", kind = \"scatter\", ax = basemap, color = \"blue\")\n      6 plt.axis(\"equal\")\n\nNameError: name 'zeckenstiche' is not defined",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Übung 9</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html",
    "href": "C_Programmieren_2/20_Anhang.html",
    "title": "Anhang",
    "section": "",
    "text": "Anhang 1: Probleme mit Conda: Umlaute im Bentzernamen\nAlle conda environments werden an einem zentralen Ort gespeichert. Typischerweise im folgenden Verzeichnis: C:\\Users\\DEIN-WINDOWS-BENUTZERNAME\\AppData\\Local\\ESRI\\conda\\envs\\. Wenn ihr Umlaute in eurem Windows Benutzernamen habt, findet conda eure environment möglicherweise nicht. Eine Möglichkeit, dieses Problem zu beheben, ist einen alternativen Speicherort für eure conda environments zu definieren. Dazu geht ihr wie folgt vor1:",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#anhang-1-probleme-mit-conda-umlaute-im-bentzernamen",
    "href": "C_Programmieren_2/20_Anhang.html#anhang-1-probleme-mit-conda-umlaute-im-bentzernamen",
    "title": "Anhang",
    "section": "",
    "text": "Überlege dir eine Location, wo du deine conda nvironments abspeichern möchtest (z.B. C:\\conda-envs). Erstelle diesen Ordnerpfad und prüfe ob du dort Schreibrechte hast indem du in diesem Orner C:\\conda-envs eine Dateie erstellst. Wenn das klappt, hast du Schreibrechte.\nFüge diesen Pfad deiner conda configuration hinzu:\nconda config --append envs_dirs C:\\conda-envs\nPrüfe ob der letzte Schritt funktioniert hat indem du folgendem Befehl laufen lässt und prüfst, ob C:\\conda-envs vorkommt:\nconda config --show envs_dirs\nErstelle eine neue conda environment in dieser neu erstellten directory:\nconda create --prefix=C:\\conda-envs\\geopython\nPrüfe, ob das geklappt hat, indem du die verfügbaren environments auflistest.\nconda info --envs\nWenn das geklappt hat, kannst du nun deine environment aktivieren\nconda activate geopython",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#anhang-2-conda-und-arcpy",
    "href": "C_Programmieren_2/20_Anhang.html#anhang-2-conda-und-arcpy",
    "title": "Anhang",
    "section": "Anhang 2: Conda und arcpy",
    "text": "Anhang 2: Conda und arcpy\nUm die ganzen Befehle von ArcGIS direkt in Python ansteuern zu können, muss das package arcpy installiert werden. Bisher haben wir alle unsere Packages mit conda installiert, z.B:\nconda install -c conda-forge geopandas\nMit arcpy geht dies leider nicht, weil arcpy ein kostenpflichtiges Modul ist welches eine ArcGIS Lizenz benötigt. Glücklicherweise nutzt ArcGIS aber auch Conda Environments. Wir müssen also nur bewerkstelligen, das Juypter Lab die gleiche Conda environment verwendet wie ArcGIS. Dazu gehen wir wie folgt vor:\n\nSchritt 1: ArcGIS Python Umgebung Klonen\nSchritt 2: Die neue Environment aktivieren\nSchritt 3: weitere Module installieren\n\n\nSchritt 1: ArcGIS Python Umgebung Klonen\nZuerst prüfen wir die Python Umgebung in ArcGIS. Diese findet man in ArcGIS unter Project &gt; Python\n\nHier ist einerseits die Project Environement ersichtlich (1), andererseits steht aber auch, dass diese Environment “read only” ist (2). Das bedeutet, dass wir keine neuen module installieren können, wenn wir diese Environment benutzen. Wir folgen deshalb den Vorschlag “Clone and activate a new environment”. Dazu klicken wir auf “Manage Environment” (3). Übrigens: Das ArcGIS Conda benutzt sehen wir an (4).\nKlicke hier auf “Clone Default” um die Umgebung zu kopieren. Das dauert eine Weile, danach kann man die neue Environment auswählen (Klick auf den Button “Active”). Notiert dir den Namen der neuen Environment, speichere das ArcGIS Projekt ab und starte das ArcGIS neu\n\n\nSchritt 2: Die neue Environment aktivieren\nNun haben wir uns eine wunderschöne Python Umgebung parat gemacht und können diese jetzt in CMD aktivieren. Starte dazu Command Prompt / CMD und schaue dir die verfügbaren environments an:\nconda env list\nBei mir sieht der output folgendermassen aus:\n# conda environments:\n#\narcgisonline             C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgisonline\narcgisonline2            C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgisonline2\narcgispro-py3-clone      C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\narcgispro-py3-clone1     C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone1\ncameratraps-detector     C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\cameratraps-detector\ngeopython                C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\geopython\ntest                     C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\test\narcgispro-py3         *  C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\nroot                     C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\nAktiviere nun die eben erstelle environment mit folgendem code (ersetzte name-der-environment mit dem tatsächlichen Namen deiner neuen environment aus dem letzten Schritt.\nactivate name-der-environment\n\n\nSchritt 3: weitere Module installieren\nGlücklicherweise ist jupyterlab bereits in der arcgis environment installiert, dies können wir mit folgendem code überprüfen:\nconda list\n# packages in environment at C:\\Users\\rata\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone1:\n#\naffine                    2.3.0                      py_0    anaconda\narcgis                    1.8.2                 py36_1275    esri\narcgispro                 2.6                           0    esri\n.\n.\n.\njupyterlab                2.2.9                      py_0    conda-forge\njupyterlab_pygments       0.1.2              pyh9f0ad1d_0    conda-forge\njupyterlab_server         1.2.0                      py_0    conda-forge\n.\n.\n.\nWenn jetzt aber noch module fehlen (wie z.B. geopandas), dann können wir diese wie gewohnt installieren.\n\n\nSchritt 4: arcpy verwenden\nWenn alles gewünschten Module installiert sind können wir nun JupyterLab starten.\nSobald JupyterLab gestartet ist, können wir innerhalb einer cell das Modul arcpy mit import arcpy importieren und nun auch verwenden. Zum Beispiel folgendermassen:\nimport arcpy\nfrom arcpy import env\n\n# Set environment settings\nenv.workspace = \"C:/data/Habitat_Analysis.gdb\"\n\n# Select suitable vegetation patches from all vegetation\nveg = \"vegtype\"\nsuitableVeg = \"C:/output/Output.gdb/suitable_vegetation\"\nwhereClause = \"HABITAT = 1\" \narcpy.Select_analysis(veg, suitableVeg, whereClause)\nDer Syntax ist auf jeder jeweiligen Tool Beschreibung gut dokumentiert (Abschnitt “Code Sample”, z.B. hier)",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#anhang-3-jupyterlab-mit-r",
    "href": "C_Programmieren_2/20_Anhang.html#anhang-3-jupyterlab-mit-r",
    "title": "Anhang",
    "section": "Anhang 3: JupyterLab mit R",
    "text": "Anhang 3: JupyterLab mit R\nEinige von euch kennen JupyterLab bereits aus dem Statistik Unterricht. Dort habt ihr JupyterLab mit R benutzt, dabei habt ihr aber nicht auf eurem lokalen PC, sondern auf einer gehosteten Version von JupyterLab gearbeitet, also auf einem Server. Dieser Server kann jeder Zeit wieder Offline geschaltet werden oder ihr könnt euren Zugriff darauf verlieren. Wenn ihr JupyterLab mit R lokal nutzen wollt, geht ihr wie folgt vor (Anleitung in Anlehnung an diesen Blogpost):\n\nIn eurem Python Command Prompt erstellt ihr eine neue conda environment, aktiviert diese und installiert juypterlab sowie r-ikernel (letzteres aus dem channel r, nicht wie gewohnt conda-forge).\nconda create --name r-env\nconda activate r-env\nconda install -c conda-forge jupyterlab\nconda install -c r r-irkernel\nNun ist R in eurer conda environment aktiviert. Nun könnt ihr mit folgenden Befehlen das Package IRkernel installieren sowie den Kernel für JuypterLab verfügbar machen.\nRscript -e \"install.packages('IRkernel', repos = 'https://cloud.r-project.org')\"\nRscript -e \"IRkernel::installspec(user = FALSE)\"\nOptional: Wenn ihr ein paar nützliche shortcuts für R haben wollt, könnt ihr die extension techrah/text-shortcuts mit folgender Zeile installieren.\njupyter labextension install @techrah/text-shortcuts\nNun könnt ihr JupyterLab starten und sollet nun einen R-Kernel zur Verfügung haben:\njupyter lab\n\n\n\n\n\n\n\nAbbildung 41.1: Nach den oben beschriebnen Schritten sollte nun ein R Kernel zur Verfügung stehen",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_2/20_Anhang.html#footnotes",
    "href": "C_Programmieren_2/20_Anhang.html#footnotes",
    "title": "Anhang",
    "section": "",
    "text": "Aus: https://stackoverflow.com/a/67376348/4139249↩︎",
    "crumbs": [
      "Programmieren II",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html",
    "title": "Einführung in for loop",
    "section": "",
    "text": "Die Grundform\nNirgends ist der Aspekt der Automatisierung so sichtbar wie in for loops. Loops sind “Schleifen” wo eine Aufgabe beliebig lange wiederholt wird. Auch for loops sind im Grunde genommen simple. Auf den ersten Blick sieht eine for loop aus wie eine Function definition (siehe Function Basics und Function Advanced). Im folgenden Beispiel seht ihr ein minimales Beispiel einer for loop.\nfor platzhalter in [0,1,2]:\n    print(\"Iteration\",platzhalter)\n\nIteration 0\nIteration 1\nIteration 2",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#die-grundform",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#die-grundform",
    "title": "Einführung in for loop",
    "section": "",
    "text": "for legt fest, dass eine For-Loop beginnt\nNach for kommt eine Platzhalter-Variabel, die ihr beliebig benennen könnt. Im obigen Beispiel lautet diese platzhalter\nNach dem Platzhalter kommt der Begriff in. Dieser Begriff kommt zwingend nach dem Platzhalter.\nNach in wird der “Iterator” festgelegt, also worüber der For-Loop iterieren soll (hier: über eine List mit den Werten [0,1,2]).\nDanach kommt ein Doppelpunkt : der zeigt: “Nun legen wir gleich fest was im For-Loop passieren soll” (ähnlich wie in einer Function)\nAuf einer neuen Zeile wird eingerückt festgelegt, was in der For-Loop passieren soll. Dieser Teil kann beliebig lange sein, ein for loop ist dann fertig, wenn man nicht mehr eingerückt wird. In unserem Fall wird mit print1 etwas in die Konsole ausgegeben.\nAchtung: return() gibt’s in For-Loops nicht!",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#der-iterator",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#der-iterator",
    "title": "Einführung in for loop",
    "section": "Der Iterator",
    "text": "Der Iterator\nIm obigen Beispiel haben wir über eine List iteriert, wir haben also eine Liste als Iterator verwendet. Es gibt aber noch andere “Dinge”, über die wir iterieren können. Angenommen wir wollen den gleichen for loop mit den Zahlen von 0 bis 100 oder 100 bis 1’000 durchführen. Es wäre ganz schön mühsam, alle Zahlen von 0 bis 100 manuell in einer Liste zu erfassen. Zu diesem Zweck können wir die Funktion range verwenden. Mit range(3) erstellen wir einen Iterator mit den Werten 0, 1 und 2. Mit range(100,1001) erhalten wir die Werte von 100 bis 1’000.\nDer gleiche loop wie oben lautet mit range folgendermassen:\n\nfor platzhalter in range(3):\n    print(\"Iteration\",platzhalter)\n\nIteration 0\nIteration 1\nIteration 2",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#der-platzhalter",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#der-platzhalter",
    "title": "Einführung in for loop",
    "section": "Der Platzhalter",
    "text": "Der Platzhalter\nDie Platzhaltervariabel liegt immer zwischen for und in, den Namen dieser Variabel könnt ihr frei wählen. Ich habe sie im obigen Beispiel platzhalter genannt. Speziell an dieser Variabel ist, dass sie während der Dauer des Loops ihren Wert verändert. Mehr dazu in Basic for loop.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_For_Loops_Intro.html#footnotes",
    "href": "C_Programmieren_3/2_For_Loops_Intro.html#footnotes",
    "title": "Einführung in for loop",
    "section": "",
    "text": "Mit print können wir Variabeln in die Konsole “ausdrucken” lassen. Innerhalb von print können dazu verschiedene Variablen kommagetrennt aufgeführt werden, ohne sie mit + verbinden zu müssen wie damals in Function Basics.↩︎",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Einführung in *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_10.html",
    "href": "C_Programmieren_3/2_Uebung_10.html",
    "title": "Übung 10",
    "section": "",
    "text": "Übung 10.1\nKopiere den folgenden for Loop und lasse ihn bei dir laufen. Spiele mit den Werten rum, um ein Gefühl für For Loops zu bekommen: Ergänze die Liste mit weiteren Zahlen, verändere den Namen der Platzhaltervariabel und verändere den Text, der in print ausgegeben wird.\nMusterlösung\nfor platzhalter in [0,1,2,5,10]:\n    print(\"Iteration\",platzhalter)\n\n\nIteration 0\nIteration 1\nIteration 2\nIteration 5\nIteration 10",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_10.html#sec-for-gruss",
    "href": "C_Programmieren_3/2_Uebung_10.html#sec-for-gruss",
    "title": "Übung 10",
    "section": "Übung 10.2",
    "text": "Übung 10.2\nKonstruiere eine Liste bestehend aus 3 Namen und nenne diese Liste namen. Erstelle danach einen for loop, mit welcher jede Person in der Liste gegrüsst wird. Nutze dafür print.\n\n\nMusterlösung\nnamen = [\"Il Buono\", \"Il Brutto\", \"Il Cattivo\"]\n\nfor name in namen:\n    print(\"Ciao \",name)\n\n\nDer Output könnte etwa so aussehen:\n\n\nMusterlösung\nfor name in namen:\n    print(\"Ciao \",name)\n\n\nCiao  Il Buono\nCiao  Il Brutto\nCiao  Il Cattivo",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_10.html#übung-10.3",
    "href": "C_Programmieren_3/2_Uebung_10.html#übung-10.3",
    "title": "Übung 10",
    "section": "Übung 10.3",
    "text": "Übung 10.3\nKopiere den folgenden For Loop und spiele hier mit den Werten herum. Verändere den For Loop so, dass er über die Werte von -5 bis +5 iteriert.\n\n\nMusterlösung\nfor nonsense in range(3, 5):\n    print(\"Iteration\",nonsense)\n\n\nIteration 3\nIteration 4\n\n\n\n\nMusterlösung\n# Iteriert von -5 bis +5\nfor platzhalter in range(-5,6):\n    print(\"Iteration\",platzhalter)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_10.html#übung-10.4",
    "href": "C_Programmieren_3/2_Uebung_10.html#übung-10.4",
    "title": "Übung 10",
    "section": "Übung 10.4",
    "text": "Übung 10.4\nBis jetzt haben unsere Loops nicht viel Arbeiten müssen. Erstelle nun einen For Loop, welcher für die Werte -5 bis +5 folgendes ausgibt:\nDas Quadrat von -5 ist 25\nDas Quadrat von -4 ist 16\n...\n\n\nMusterlösung\nfor platzhalter in range(-5,6):\n    print(\"Das Quadrat von\",platzhalter, \"ist\",platzhalter*platzhalter)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/2_Uebung_10.html#sec-forloops-ex-party",
    "href": "C_Programmieren_3/2_Uebung_10.html#sec-forloops-ex-party",
    "title": "Übung 10",
    "section": "Übung 10.5",
    "text": "Übung 10.5\nBisher haben wir die Platzhaltervariabel immer in unserem Loop wiederverwendet. Das müssen wir aber gar nicht, wir können den for loop einfach nutzen um etwas x mal zu wiederholen. Erstellen einen for loop der folgende beiden Sätze 5x wiederholt:\nWho likes to party?\nWe like to party!\nWho likes to party?\n....\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nNutze dafür zwei verschiedene print Befehle auf zwei Zeilen.\n\n\n\n\n\nMusterlösung\nfor i in range(5):\n    print(\"Who likes to party?\")\n    print(\"We like to party!\")",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Übung 10</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/3_For_Loops_Basics.html",
    "href": "C_Programmieren_3/3_For_Loops_Basics.html",
    "title": "Basic for loop",
    "section": "",
    "text": "Bis jetzt haben wir lediglich Sachen in die Konsole herausgeben lassen, doch wie schon bei Functions ist der Zweck einer for loop meist, dass nach Durchführung etwas davon zurückbleibt. Aber return() gibt es wie bereits erwähnt bei for loops nicht. Nehmen wir folgendes Beispiel:\n\nfor rolle in [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]:\n    liedzeile = \"I'm a \"+ rolle \n    print(liedzeile)\n\nI'm a bitch\nI'm a lover\nI'm a child\nI'm a mother\nI'm a sinner\nI'm a saint\n\n\nDer Output von dieser For-Loop sind zwar sechs Liederzeilen, wenn wir die Variabel liedzeile aber jetzt anschauen ist dort nur das Resultat aus der letzten Durchführung gespeichert. Das gleiche gilt auch für die Variabel rolle.\n\nliedzeile\n\n\"I'm a saint\"\n\n\n\nrolle\n\n'saint'\n\n\nDas verrät uns etwas über die Funktionsweise des for loops: Bei jedem Durchgang werden die Variablen immer wieder überschrieben. Wenn wir also den Output des ganzen For-Loops abspeichern wollen, müssen wir dies etwas vorbereiten.\nDafür erstellen wir unmittelbar for dem for loops einen leeren Behälter, zum Beispiel eine leere Liste:\n\nrefrain = []\n\nNun können wir innerhalb des Loops append() nutzen, um den Output von einem Durchgang dieser Liste hinzuzufügen.\n\nfor rolle in [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]:\n    liedzeile = \"I'm a \"+ rolle \n    refrain.append(liedzeile)\n\nIn unserer Liste refrain ist nun der Wert jeder Iteration gespeichert.\n\nrefrain\n\n[\"I'm a bitch\",\n \"I'm a lover\",\n \"I'm a child\",\n \"I'm a mother\",\n \"I'm a sinner\",\n \"I'm a saint\"]",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Basic *for loop*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/3_Uebung_11.html",
    "href": "C_Programmieren_3/3_Uebung_11.html",
    "title": "Übung 11",
    "section": "",
    "text": "Übung 11.1\nNehmen wir nochmals das Beispiel aus Übung 10.2. Erstelle nochmal ein Loop, wo drei Personen aus einer Liste gegrüsst werden. Diesmal sollen aber die drei Grüsse in einer Liste (z.B. mylist) gespeichert werden.\nMusterlösung\nmylist = []\n\nfor name in [\"Il Buono\", \"Il Brutto\", \"Il Cattivo\"]:\n    mylist.append(\"Ciao \"+name)\nMusterlösung\n# Das Resultat sieht dann so aus:\nmylist\n\n\n['Ciao Il Buono', 'Ciao Il Brutto', 'Ciao Il Cattivo']",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/3_Uebung_11.html#sec-ex-loopoutput",
    "href": "C_Programmieren_3/3_Uebung_11.html#sec-ex-loopoutput",
    "title": "Übung 11",
    "section": "Übung 11.2",
    "text": "Übung 11.2\nDer im Beispiel verwendete Refrain aus dem Lied “Bitch” von Meredith Brooks besteht bis auf zwei Zeilen aus Wiederholungen. Versuche mit zwei verschiedenen, aneinander gereihten for loops den ganzen Refrain in einer Liste zu speichern. Die beiden Teile die vom Muster Abweichen (“I do not feel ashamed” und “You know you wouldn’t want it any other way”) kannst du auch ausserhalb der Loops in die Listen einfügen (append).\n\n\nMusterlösung\nrefrain = []\n\nfor rolle in [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]:\n    liedzeile = \"I'm a \"+ rolle \n    refrain.append(liedzeile)\nrefrain.append(\"I do not feel ashamed\")\nfor rolle in [\"your hell\",\"your dream\",\"nothing in between\"]:\n    liedzeile = \"I'm \"+ rolle \n    refrain.append(liedzeile)\nrefrain.append(\"You know you wouldn't want it any other way\") \n\n\n\n\nMusterlösung\n# Das Resultat sieht dann so aus:\nrefrain\n\n\n[\"I'm a bitch\",\n \"I'm a lover\",\n \"I'm a child\",\n \"I'm a mother\",\n \"I'm a sinner\",\n \"I'm a saint\",\n 'I do not feel ashamed',\n \"I'm your hell\",\n \"I'm your dream\",\n \"I'm nothing in between\",\n \"You know you wouldn't want it any other way\"]",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Übung 11</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_For_Loops_Advanced.html",
    "href": "C_Programmieren_3/4_For_Loops_Advanced.html",
    "title": "Advanced for loops",
    "section": "",
    "text": "Verschachtelte for loops\nWir können verschiedene for loops auch ineinander verschachteln (englisch: nested loops). Das ist vor allem dann nützlich, wenn alle Kombinationen aus zwei Datensätzen miteinander verrechnet werden müssen. Angenommen du willst die drei Mitglieder deiner Band (bestehend aus Il Buono, Il Brutto, Il Cattivo) deinen Eltern vorstellen und auch umgekehrt deine Eltern deiner Band vorstellen. Für so was eignen sich zwei verschachtelte for Loops hervorragend:\neltern = [\"Papa\", \"Mama\"]\nband = [\"Il Buono\", \"Il Brutto\", \"Il Cattivo\"]\n\nfor bandmitglied in band:\n    for elternteil in eltern:\n        print(elternteil, \"das ist\",bandmitglied)\n        print(bandmitglied, \"das ist\",elternteil)\n        print(\"---\")\n\nPapa das ist Il Buono\nIl Buono das ist Papa\n---\nMama das ist Il Buono\nIl Buono das ist Mama\n---\nPapa das ist Il Brutto\nIl Brutto das ist Papa\n---\nMama das ist Il Brutto\nIl Brutto das ist Mama\n---\nPapa das ist Il Cattivo\nIl Cattivo das ist Papa\n---\nMama das ist Il Cattivo\nIl Cattivo das ist Mama\n---",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Advanced *for loops*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_For_Loops_Advanced.html#verschachtelte-for-loops",
    "href": "C_Programmieren_3/4_For_Loops_Advanced.html#verschachtelte-for-loops",
    "title": "Advanced for loops",
    "section": "",
    "text": "Hinweis\n\n\n\n\n\nAls Platzhaltervariabel nutze ich wenn immer möglich das Singulär und für den Iterator das Plural von dem Objekt, über das ich iteriere. for bandmitglied in band, for vogel in voegel usw, dies hilft mir den Überblick im loop zu bewahren.\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nEin anderes Beispiel: In Übung 10.5 haben wir die beiden Zeilen \"Who likes to party?\", “We like to party?” 5x wiederholt. Dabei werden die Wörter `to party für jede Wiederholung zwei mal wiederholt:\nWho likes to party?\nWe like to party!\nWho likes to party?\nWe like to party!\n...\n\nDies kann man in zwei verschachtelte For Loops umschreiben:\nfor i in range(5):\n    inner = [\"Who likes\", \"We like\"]\n    for j in inner:\n        print(j+\" to party\")\n\nWho likes to party\nWe like to party\nWho likes to party\nWe like to party",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Advanced *for loops*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_For_Loops_Advanced.html#verkürzte-schreibweise",
    "href": "C_Programmieren_3/4_For_Loops_Advanced.html#verkürzte-schreibweise",
    "title": "Advanced for loops",
    "section": "Verkürzte Schreibweise",
    "text": "Verkürzte Schreibweise\nEs ist äusserst häufig der Fall, dass wir den Output aus einem Loop in einer Liste abspeichern wollen. Wie das geht haben wir ja bereits in Basic for loop gelernt:\n\nrollen = [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]\n\nrefrain = []\nfor rolle in rollen:\n    liedzeile = \"I'm a \"+ rolle \n    refrain.append(liedzeile)\n\nNur ist das ein bisschen umständlich, weil wir dafür viele Zeilen Code brauchen, um etwas eigentlich ganz simples zu bewerkstelligen. Es gibt deshalb dafür auch eine verkürzte Schreibweise, welche ich in der letzten Woche bereits einmal verwendet habe (siehe Übung 8.6). Der obige Loop hat in der verkürzten Schreibweise die folgende Form:\n\nrefrain = [\"I'm a \"+ rolle for rolle in rollen]\n\nDiese verkürzte Schreibweise heisst in Python list comprehension und sie ist äusserst praktisch, wenn man sie beherrscht. Das Beherrschen ist aber nicht zentral, es reicht schon wenn ihr eine solche Schreibweise wieder erkennt und richtig interpretieren könnt (im Sinne von “Aha, hier wird also in einem Loop eine Liste erstellt”). In der folgenden Darstellung seht ihr farblich, welche Elemente sich in der verkürzten Schreibweise wo wiederfinden und welche Elemente gar nicht wiederverwendet werden.\n\nrollen = [\"bitch\",\"lover\",\"child\",\"mother\",\"sinner\",\"saint\"]\n\n\n\nHerkömmlicher For-Loop:\n\n  ref = []\n  for r in rollen:\n      liedzeile = \"I'm a \"+ r\n      refrain.append(liedzeile)\n  \n\n\n\n\nVerkürzte Schreibweise:\n\nref = [\"I'm a \"+ r for r in rollen]",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Advanced *for loops*</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_12.html",
    "href": "C_Programmieren_3/4_Uebung_12.html",
    "title": "Übung 12",
    "section": "",
    "text": "Übung 12.1\nErstelle zwei Listen bestehend aus 3 Hundenamen (hunde) und 3 Katzennamen (katzen). Erstelle einen verschachtelten For Loop, wo jeder Hund jede Katze beisst und jede Katze jeden Hund kratzt.\nMusterlösung\nhunde = [\"Bruno\", \"Berta\",\"Helmi\"]\nkatzen = [\"Greta\", \"Xavier\", \"Zachy\"]\n\nfor katze in katzen:\n    for hund in hunde:\n        print(hund, \"beisst\", katze+\" und \"+katze, \"kratzt \", hund)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_12.html#übung-12.1",
    "href": "C_Programmieren_3/4_Uebung_12.html#übung-12.1",
    "title": "Übung 12",
    "section": "",
    "text": "Bruno beisst Greta und Greta kratzt  Bruno\nBerta beisst Greta und Greta kratzt  Berta\nHelmi beisst Greta und Greta kratzt  Helmi\n....",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_12.html#übung-12.2",
    "href": "C_Programmieren_3/4_Uebung_12.html#übung-12.2",
    "title": "Übung 12",
    "section": "Übung 12.2",
    "text": "Übung 12.2\nErstelle einen verschachtelten Loop, wo alle Kombinationen von 0 bis 9 miteinander addiert werden.\n\n\nMusterlösung\naddition = []\n\nwerte = range(10)\n\nfor i in werte:\n    for j in werte:\n        resultat = i+j\n        addition.append(resultat)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_12.html#übung-12.3",
    "href": "C_Programmieren_3/4_Uebung_12.html#übung-12.3",
    "title": "Übung 12",
    "section": "Übung 12.3",
    "text": "Übung 12.3\nNutze die Funktion offset_coordinate (Lösung aus Übung 8.5) um einen Punkt in einem Koordinatensystem zu verschieben. Diesmal soll der Punkt aber nicht nur 1x, sondern 100x verschoben werden (100 Simulationen).\n\n\nMusterlösung\nimport random\n\ndef offset_coordinate(old, distance = 100):\n    new = old + random.normalvariate(0, distance)\n    return new\n\nx_start = 0\ny_start = 0\n\nx_random = []\ny_random = []\nfor i in range(100):\n    x_new = offset_coordinate(x_start)\n    y_new = offset_coordinate(y_start)\n\n    x_random.append(x_new)\n    y_random.append(y_new)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/4_Uebung_12.html#übung-12.4-fakultativ",
    "href": "C_Programmieren_3/4_Uebung_12.html#übung-12.4-fakultativ",
    "title": "Übung 12",
    "section": "Übung 12.4 (fakultativ)",
    "text": "Übung 12.4 (fakultativ)\nVersuche die Monte Carlo Simulation für die Annäherung an Pi (aus der ersten Übung “Datenqualität und Unsicherheit) mit einer Funktion und einem For Loop zu lösen.\nZur Erinnerung, die Vorgehensweise für die Annäherung an Pi geht folgendermassen:\n\nZufallskoordinaten (x, y) zwischen 0 und 1 erstellen\nDistanz zum Ursprung (0) mit der Formel \\(\\sqrt(x^2+y^2)\\) berechnen\nBestimmen ob sich der Punkt innerhalb des Kreisviertels befindet (\\(d &lt; 1\\))\nSchritte 1 & 2 mehrfach wiederholen\nAnteil der Punkte innerhalb des Kreisviertels mit 4 Multiplizieren\n\nTipps:\n\nFür die Erstellung der Zufallspunkte brauchst du die Funktion random() aus dem modul random\nSchritte 1 - 3 werden am sinnvollsten ein eine Funktion verpakt, welche keine Argumente benötigt\nSchritt 4 löst du am besten mit einer For loop mit range(100) (für 100 Wiederholungen)\n\n\n\nMusterlösung\nimport random\n\n# erstelle eine Funktion, die zwei Zufallszahlen zwischen 0 und 1 generiert,\n# die Distanz zum Ursprung (0,0) berechnet und True retourniert, wenn der Wert ausserhalb des Kreisviertels liegt\ndef get_pi(): \n    x = random.random()\n    y = random.random()\n    pythagoras = (x**2+y**2)**0.5\n    ausserhalb = pythagoras &gt; 1\n    return ausserhalb\n\nget_pi()\n\n# die Funktion 100x wiederholen und die Anzahl Werte &gt; 1 zählen\nres = [get_pi() for x in range(100)]\n\n# Anteil der Werte &gt; 1 berechnen und mit 4 multiplizieren\n(100-sum(res))/100*4",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Übung 12</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html",
    "href": "C_Programmieren_3/5_GIS_in_Python.html",
    "title": "Input: GIS in Python",
    "section": "",
    "text": "DataFrames &gt; GeoDataFrames\nGlücklicherweise können wir unsere Zeckenstich-Dataframe mit nur einem Zusatzmodul und wenigen Zeilen code in eine räumliche DataFrame konvertieren. Mit dem Modul geopandas erstellen wir aus unserer pandas DataFrame eine geopandas GeoDataFrame. Mit dieser Erweiterung erhält die DataFrame:\nBeide Bestandteile müssen wir bei der Erstellung der GeoDataFrame festlegen. Nachstehend seht ihr, wie ihr dies bei den Zeckenstichen machen könnt, was diese Bestandteile genau bedeuten seht ihr in Aufbau von GeoDataFrames (geometry) und Koordinatenbezugssystem (crs).\nimport geopandas as gpd\n\ngeom = gpd.points_from_xy(\n  zeckenstiche['x'],    # ↘\n  zeckenstiche['y']     # → die Geometrie Spalte\n  )   \n\nzeckenstiche_gpd = gpd.GeoDataFrame(\n    zeckenstiche,    # die DataFrame (\"Attributtabelle\")\n    geometry = geom, #\n    crs = 2056       # das Koordinatenbezugssystem (EPSG Code)\n    )\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 4\n      1 import geopandas as gpd\n      3 geom = gpd.points_from_xy(\n----&gt; 4   zeckenstiche['x'],    # ↘\n      5   zeckenstiche['y']     # → die Geometrie Spalte\n      6   )   \n      8 zeckenstiche_gpd = gpd.GeoDataFrame(\n      9     zeckenstiche,    # die DataFrame (\"Attributtabelle\")\n     10     geometry = geom, #\n     11     crs = 2056       # das Koordinatenbezugssystem (EPSG Code)\n     12     )\n\nNameError: name 'zeckenstiche' is not defined\nNun sehen wir, dass die neue geometry Spalte die Punkt-Geometrie enthält.\nzeckenstiche_gpd\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 zeckenstiche_gpd\n\nNameError: name 'zeckenstiche_gpd' is not defined\nZudem hat die GeoDataFrame nun ein Attribut crs, wo das Koordinatenbezugssystem gespeichert ist.\nzeckenstiche_gpd.crs.name\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 zeckenstiche_gpd.crs.name\n\nNameError: name 'zeckenstiche_gpd' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-geodataframe",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-geodataframe",
    "title": "Input: GIS in Python",
    "section": "",
    "text": "geometry: eine Zusatzspalte geometry mit der Geometrie als räumliches Objekt und\ncrs: ein Attribut crs welches das Koordinatenbezugssystem der Geometriespalte enthält.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-datenstruktur",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-datenstruktur",
    "title": "Input: GIS in Python",
    "section": "Aufbau von GeoDataFrames",
    "text": "Aufbau von GeoDataFrames\nMit geometry = haben wir die Geometriespalte der GeoDataFrame festgelegt. Bei unseren Zeckenstichdaten ist die Geometrie sehr simpel: Sie besteht aus Punkt-Objekte die sich wiederum aus den x- und y-Koordinaten zusammensetzen. Um x/y-Koordinaten in Punktgeometrien zu konvertieren gibt es in Geopandas die Funktion points_from_xy. Diese verwende ich im obigen Code um die Punkt-Objekte zu erstellen.\nAn dieser Stelle ist es wichtig, die drei Hierarchiestufen von GeoDataFrames zu kären. Von “unten” nach “oben” erläutert gibt es folgende Stufen:\n\nGeometry: Einzelne Objekte 1 der folgenden Typen\n\nPoints / Multipoint 2\nLinestring / Multilinestring 3\nPolygon / Multipolygon 4\n\nGeoSeries: Eine vielzahl an Geometries, typischerweise eine Spalte einer GeoDataFrame namens (geometry)\nGeoDataFrame: Eine Tabelle, welche über eine Geometrie-Spalte (GeoSeries) verfügt\n\n\nDie drei Hierarchien in Geopandas: Eine GeoDataFrame verfügt immer über eine Geometrie-Spalte, welche sich eine GeoSeries nennt. Diese wiederum besteht aus Einzelgeometrien, sogenannten Geometries.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-crs",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-crs",
    "title": "Input: GIS in Python",
    "section": "Koordinatenbezugssystem",
    "text": "Koordinatenbezugssystem\nMit crs = wird das Koordinatenbezugssystem (engl. Coordinate Reference System) unseres Datensatzes festgelegt. Das Koordinatenbezugssystem gibt unseren x/y-Zahlenwerten einen konkreten Raumbezug auf dem Planeten und macht aus ihnen Koordiaten in der Schweiz. Wie lautet aber das “Koordinatenbezugssystem” unserer Daten?\nIm Prinzip weiss diese Information nur derjenige, der die Daten erstellt hat. Man man das Koordinatensytem aber auch anhand der Koordinaten erahnen: Es handelt sich in unserem Fall um Werte im Bereich von 2’600’000 auf der einen und 1’200’000 auf der anderen Achse. Da wir wissen das die Daten aus der Schweiz stammen kann man mit etwas Erfahrung sagen, dass es sich um Daten im neuen Schweizer Koordinatenbezugssystem CH1903+ / LV95 handeln muss. Der EPSG Code dieses Koordinatenbezugssystems lautet 2056 und diesen Code können wir in der Funktion gpd.GeoDataFrame nutzuen, um das Korrekte Koordinatenbezugssystem zu zuweisen.\n\n# Das Attribut `crs` wurde aufgrund vom EPSG Code richtig erkannt:\nzeckenstiche_gpd.crs.name\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 # Das Attribut `crs` wurde aufgrund vom EPSG Code richtig erkannt:\n----&gt; 2 zeckenstiche_gpd.crs.name\n\nNameError: name 'zeckenstiche_gpd' is not defined\n\n\n\nDiese CRS Information erlaubt uns auch, mit einer Zeile Code eine Webmap unserer Zeckenstiche zu machen. Versucht es aus!\n\nzeckenstiche_gpd.explore()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 zeckenstiche_gpd.explore()\n\nNameError: name 'zeckenstiche_gpd' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-formate",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#sec-pythongis-formate",
    "title": "Input: GIS in Python",
    "section": "Geodatenformate",
    "text": "Geodatenformate\nDas Einlesen von CSV und die Konvertierung von DataFrame zu GeoDataFrame hat bei den Zeckenstichen zwar gut funktioniert, es ist aber auch etwas umständlich jedes Mal die geometry Spalte und das crs zu setzen. CSVs eignen sich nicht besonders gut für das speichern von Geodaten, insbesonders wenn die Daten komplexer sind (Linien, Polygone..)). Deshalb gibt es auch spezifische Datenformate, in den Geodaten gespeichert werden können. Bei diesen Datenformaten werden geometry und crs automatisch abgespeichert.\nIhr seid im Studium mit solchen Datenformate bereits in Kontakt gekommen, sicher kennt ihr ESRI’s File Geodatabases/Feature Classes sowie Shapefiles. Dies sind häufig genutzte Formate, aber leider nicht offen, und gerade Shapefiles haben viele Tücken (siehe switchfromshapefile.org). Es gibt dafür ganz tolle Alternativen, beispielsweise Geopackages (nicht zu verwechseln mit ArcGIS Pro Packages!). Mit nachstehendem Befehl können wir zeckenstiche_gpd als Geopackage abspeichern.\n\nzeckenstiche_gpd.to_file(\"data/zeckenstiche.gpkg\", driver = \"GPKG\")   \n# Wer UNBEDINGT ein shapefile abspeichern will, \n# kann \".gpkg\" mit \".shp\" ersetzen\n# (-_-)\n\nDas File “zeckenstiche.gpkg” befindet sich nun in meiner Working Directory und ich kann sie mit gpd.read_file(\"data/zeckenstiche.gpkg\") wieder einlesen. Im Unterschied zu vorher musst ich nun geometry und crs nicht mehr zuweisen, diese sind beim Schreiben des Geopackage abgespeichert worden. Das Geopackage kann ich nun auch mit ArcGIS / QGIS öffnen, wenn ich die Punkte interaktiv explorieren möchte.\nIm Block “Datenqualität und Unsicherheit” habt ihr mit dem Wald Datensatz gearbeitet. Ich habe diesen als Geopackage exportiert (siehe Tabelle 1) und kann ihn wie im nachstehend Codeblock ersichtlich einlesen und visualisieren.\n\nwald = gpd.read_file(\"data/wald.gpkg\") # &lt;- importiert das File \"wald.gpkg\"\n\nwald\n\n\n---------------------------------------------------------------------------\nDataSourceError                           Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 wald = gpd.read_file(\"data/wald.gpkg\") # &lt;- importiert das File \"wald.gpkg\"\n      3 wald\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:294, in _read_file(filename, bbox, mask, columns, rows, engine, **kwargs)\n    291             from_bytes = True\n    293 if engine == \"pyogrio\":\n--&gt; 294     return _read_file_pyogrio(\n    295         filename, bbox=bbox, mask=mask, columns=columns, rows=rows, **kwargs\n    296     )\n    298 elif engine == \"fiona\":\n    299     if pd.api.types.is_file_like(filename):\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:547, in _read_file_pyogrio(path_or_bytes, bbox, mask, rows, **kwargs)\n    538     warnings.warn(\n    539         \"The 'include_fields' and 'ignore_fields' keywords are deprecated, and \"\n    540         \"will be removed in a future release. You can use the 'columns' keyword \"\n   (...)\n    543         stacklevel=3,\n    544     )\n    545     kwargs[\"columns\"] = kwargs.pop(\"include_fields\")\n--&gt; 547 return pyogrio.read_dataframe(path_or_bytes, bbox=bbox, **kwargs)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/geopandas.py:261, in read_dataframe(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, fid_as_index, use_arrow, on_invalid, arrow_to_pandas_kwargs, **kwargs)\n    256 if not use_arrow:\n    257     # For arrow, datetimes are read as is.\n    258     # For numpy IO, datetimes are read as string values to preserve timezone info\n    259     # as numpy does not directly support timezones.\n    260     kwargs[\"datetime_as_string\"] = True\n--&gt; 261 result = read_func(\n    262     path_or_buffer,\n    263     layer=layer,\n    264     encoding=encoding,\n    265     columns=columns,\n    266     read_geometry=read_geometry,\n    267     force_2d=gdal_force_2d,\n    268     skip_features=skip_features,\n    269     max_features=max_features,\n    270     where=where,\n    271     bbox=bbox,\n    272     mask=mask,\n    273     fids=fids,\n    274     sql=sql,\n    275     sql_dialect=sql_dialect,\n    276     return_fids=fid_as_index,\n    277     **kwargs,\n    278 )\n    280 if use_arrow:\n    281     meta, table = result\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/raw.py:196, in read(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, return_fids, datetime_as_string, **kwargs)\n     56 \"\"\"Read OGR data source into numpy arrays.\n     57 \n     58 IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted\n   (...)\n    191 \n    192 \"\"\"\n    194 dataset_kwargs = _preprocess_options_key_value(kwargs) if kwargs else {}\n--&gt; 196 return ogr_read(\n    197     get_vsi_path_or_buffer(path_or_buffer),\n    198     layer=layer,\n    199     encoding=encoding,\n    200     columns=columns,\n    201     read_geometry=read_geometry,\n    202     force_2d=force_2d,\n    203     skip_features=skip_features,\n    204     max_features=max_features or 0,\n    205     where=where,\n    206     bbox=bbox,\n    207     mask=_mask_to_wkb(mask),\n    208     fids=fids,\n    209     sql=sql,\n    210     sql_dialect=sql_dialect,\n    211     return_fids=return_fids,\n    212     dataset_kwargs=dataset_kwargs,\n    213     datetime_as_string=datetime_as_string,\n    214 )\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:1239, in pyogrio._io.ogr_read()\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:219, in pyogrio._io.ogr_open()\n\nDataSourceError: data/wald.gpkg: No such file or directory\n\n\n\nEs handelt sich also um einen Datensatz mit nur zwei Zeilen, aber mehreren Polygonen pro Zeile (das macht es zu einem Multipolygon5). Mit plot können wir diesen Datensatz einfach visualisieren und mit den Zeckenstichdaten überlagern.\n\nbase = wald.plot(color = [\"Lightgrey\",\"Green\"])\nzeckenstiche_gpd.plot(ax = base, color = \"red\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 base = wald.plot(color = [\"Lightgrey\",\"Green\"])\n      2 zeckenstiche_gpd.plot(ax = base, color = \"red\")\n\nNameError: name 'wald' is not defined\n\n\n\nNoch einfacher und sogar mit einer Basemap und Zoom möglichkeit, geht es mit der explore() Methode. Nun wird übrigens auch klar, dass es sich bei unseren 10 Zeckenstichen um sehr dicht beieinanderliegenden Punkte handelt.\n\nbase = wald.explore()\nzeckenstiche_gpd.explore(m = base, color = \"red\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 base = wald.explore()\n      2 zeckenstiche_gpd.explore(m = base, color = \"red\")\n\nNameError: name 'wald' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/5_GIS_in_Python.html#footnotes",
    "href": "C_Programmieren_3/5_GIS_in_Python.html#footnotes",
    "title": "Input: GIS in Python",
    "section": "",
    "text": "Die Geometrien in Geopandas sind eigentlich Objekte vom Modul Shapely. Shapely wiederum ist ein Python Modul, welches mit Geopandas mit-installiert und mit-importiert wird.↩︎\nDer Unterschied zwischen Point und Multipoint, Linesstring und Multilinestring und Polygon Multipolyon ist folgendermassen: Typischerweise hat jedes Attribut eine Geometrie. Zum Beispiel hat jede Zeckenstichmeldung eine ID, eine Ungenauigkeitsangabe und eben eine Punkgeometrie. Somit handelt es sich bei diesem Datensatz um einen einfach Point Datensatz. Wenn pro Attribut mehrere Geometrien zugewiesen sind handelt es sich um ein Multipoint Objekt.↩︎\nDer Unterschied zwischen Point und Multipoint, Linesstring und Multilinestring und Polygon Multipolyon ist folgendermassen: Typischerweise hat jedes Attribut eine Geometrie. Zum Beispiel hat jede Zeckenstichmeldung eine ID, eine Ungenauigkeitsangabe und eben eine Punkgeometrie. Somit handelt es sich bei diesem Datensatz um einen einfach Point Datensatz. Wenn pro Attribut mehrere Geometrien zugewiesen sind handelt es sich um ein Multipoint Objekt.↩︎\nDer Unterschied zwischen Point und Multipoint, Linesstring und Multilinestring und Polygon Multipolyon ist folgendermassen: Typischerweise hat jedes Attribut eine Geometrie. Zum Beispiel hat jede Zeckenstichmeldung eine ID, eine Ungenauigkeitsangabe und eben eine Punkgeometrie. Somit handelt es sich bei diesem Datensatz um einen einfach Point Datensatz. Wenn pro Attribut mehrere Geometrien zugewiesen sind handelt es sich um ein Multipoint Objekt.↩︎\nDer Unterschied zwischen Point und Multipoint, Linesstring und Multilinestring und Polygon Multipolyon ist folgendermassen: Typischerweise hat jedes Attribut eine Geometrie. Zum Beispiel hat jede Zeckenstichmeldung eine ID, eine Ungenauigkeitsangabe und eben eine Punkgeometrie. Somit handelt es sich bei diesem Datensatz um einen einfach Point Datensatz. Wenn pro Attribut mehrere Geometrien zugewiesen sind handelt es sich um ein Multipoint Objekt.↩︎",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Input: GIS in Python</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html",
    "title": "Räumliche Operationen",
    "section": "",
    "text": "Buffer\nEine typische GIS Operation ist das “Buffern” von Objekten. Der ArcGIS Befehl “Buffer” erreichen wir in Geopandas mit .buffer(). Folgender Code macht einen Buffer mit einer Distanz von 10m.\nbuffered = zeckenstiche.buffer(10) \n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 buffered = zeckenstiche.buffer(10) \n\nNameError: name 'zeckenstiche' is not defined\nUm Geopandas-Objekte zu plotten kann man einfach .plot() verwenden. Zudem kann man mit boundary die Umrisse eines Polygons extrahieren:\nbase = buffered.boundary.plot() # plottet die boundries    \n\nzeckenstiche.plot(ax = base, color = \"black\") # plottet die Punkte\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 base = buffered.boundary.plot() # plottet die boundries    \n      3 zeckenstiche.plot(ax = base, color = \"black\") # plottet die Punkte\n\nNameError: name 'buffered' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#union",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#union",
    "title": "Räumliche Operationen",
    "section": "Union",
    "text": "Union\nMit unary_union können wir aus unserer Point-Geometrie ein MultiPoint erstellen (siehe Aufbau von GeoDataFrames). Dieser Befehl lautet in ArcGIS Union.\n\nzeckenstiche_union = zeckenstiche[\"geometry\"].unary_union\n\ntype(zeckenstiche_union) # Es handelt sich nun um den Typ \"MultiPoint\"\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 zeckenstiche_union = zeckenstiche[\"geometry\"].unary_union\n      3 type(zeckenstiche_union) # Es handelt sich nun um den Typ \"MultiPoint\"\n\nNameError: name 'zeckenstiche' is not defined\n\n\n\nWenn wir uns zeckenstiche_union nun mit print anschauen sehen wir, dass sämtliche Koordinaten in einem Objekt zusammengepackt sind:\n\nprint(zeckenstiche_union)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 print(zeckenstiche_union)\n\nNameError: name 'zeckenstiche_union' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#sec-raeumliche-operationen-mbg",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#sec-raeumliche-operationen-mbg",
    "title": "Räumliche Operationen",
    "section": "Minimum Bounding Geometry",
    "text": "Minimum Bounding Geometry\nÜber ein MultiPoint lassen sich jetzt wunderbar sogenannte (in ESRI Terminologie) Minimum Bounding Geometries rechnen. Mit den gleichnamigen Funktionen können wir nun eine convex_hull 1 sowie eine envelope 2 über alle Punkte rechnen.\n\nmy_convex_hull = zeckenstiche_union.convex_hull\nmy_envelope = zeckenstiche_union.envelope\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 my_convex_hull = zeckenstiche_union.convex_hull\n      2 my_envelope = zeckenstiche_union.envelope\n\nNameError: name 'zeckenstiche_union' is not defined\n\n\n\nNun konvertiere ich beide Polygon-Geometrien in GeoSeries, damit sie einfacher zu visualisieren sind:\n\nmy_convex_hull = gpd.GeoSeries(my_convex_hull)\nmy_envelope = gpd.GeoSeries(my_envelope)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 my_convex_hull = gpd.GeoSeries(my_convex_hull)\n      2 my_envelope = gpd.GeoSeries(my_envelope)\n\nNameError: name 'my_convex_hull' is not defined\n\n\n\nUm die beiden Objekte nebeneinander zu visualisieren importiere ich zuerst pyplot aus matplotlib (mit dem alias plt) und erstelle subplots\n\nfrom matplotlib import pyplot as plt\nfig, (ax1, ax2) = plt.subplots(1, 2,sharex=True, sharey = True,figsize = (9, 9))\n\n# Erstellt den linken Plot\nmy_convex_hull.plot(ax = ax1)\nax1.set_title(\"Convex Hull\")\nzeckenstiche.plot(ax = ax1, color = \"black\")\n\n# Erstellt den rechten Plot\nmy_envelope.plot(ax = ax2)\nax2.set_title(\"Envelope\")\nzeckenstiche.plot(ax = ax2, color = \"black\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 5\n      2 fig, (ax1, ax2) = plt.subplots(1, 2,sharex=True, sharey = True,figsize = (9, 9))\n      4 # Erstellt den linken Plot\n----&gt; 5 my_convex_hull.plot(ax = ax1)\n      6 ax1.set_title(\"Convex Hull\")\n      7 zeckenstiche.plot(ax = ax1, color = \"black\")\n\nNameError: name 'my_convex_hull' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#overlay",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#overlay",
    "title": "Räumliche Operationen",
    "section": "Overlay",
    "text": "Overlay\nViele der Funktionen aus dem ESRI Toolset “Overlay” sind in der Geopandas Funktion overlay verpackt. Um sie zu demonstrieren nutze ich die Geometrien, die wir in weiter oben erstellt haben (buffered und my_convex_hull). Zuerst muss ich sie aber noch von GeoSeries in GeoDataFrames konverieren.\n\nbuffered_gdf = gpd.GeoDataFrame(geometry = buffered, crs = 2056)               \nmy_convex_hull_gdf = gpd.GeoDataFrame(geometry = my_convex_hull, crs = 2056) \n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 buffered_gdf = gpd.GeoDataFrame(geometry = buffered, crs = 2056)               \n      2 my_convex_hull_gdf = gpd.GeoDataFrame(geometry = my_convex_hull, crs = 2056) \n\nNameError: name 'buffered' is not defined\n\n\n\nNun kann ich zum beispielsweise die Overlay-Funktion difference ausführen:\n\nmy_difference = gpd.overlay(my_convex_hull_gdf,buffered_gdf, how='difference')\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 my_difference = gpd.overlay(my_convex_hull_gdf,buffered_gdf, how='difference')\n\nNameError: name 'my_convex_hull_gdf' is not defined\n\n\n\n\n# Bereitet die drei Subplots vor ################\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, sharex=True, sharey = True, figsize = (9,9))\n#################################################\n\n# Plot links ####################################\nmy_convex_hull_gdf.plot(ax = ax1)               #\nax1.set_title(\"1. Das Minimum Convex Polygon\")  # \nax1.set_axis_off()                              #\n# Plot mitte ####################################\nbuffered_gdf.plot(ax = ax2)                     #\nax2.set_title(\"2. Die gebufferten Punkte\")      # \nax2.set_axis_off()                              #\n# Plot rechts ###################################\nmy_difference.plot(ax = ax3)                    #\nax3.set_title(\"Differenz aus 1. & 2.\")          # \nax3.set_axis_off()                              #\n#################################################\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[12], line 6\n      2 fig, (ax1, ax2, ax3) = plt.subplots(1, 3, sharex=True, sharey = True, figsize = (9,9))\n      3 #################################################\n      4 \n      5 # Plot links ####################################\n----&gt; 6 my_convex_hull_gdf.plot(ax = ax1)               #\n      7 ax1.set_title(\"1. Das Minimum Convex Polygon\")  # \n      8 ax1.set_axis_off()                              #\n\nNameError: name 'my_convex_hull_gdf' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Raeumliche_Operationen.html#footnotes",
    "href": "C_Programmieren_3/6_Raeumliche_Operationen.html#footnotes",
    "title": "Räumliche Operationen",
    "section": "",
    "text": "Convex Hull stellt ein “Rahmen” um alle Punkte dar, wo alle Innenwinkel kleiner sind als 180° (konvex)↩︎\nEnvelope stellt ebenfalls ein “Rahmen um alle Punkte dar, die aber quadratisch geformt und am Koordiatensystem ausgerichtet ist.↩︎",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Räumliche Operationen</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html",
    "href": "C_Programmieren_3/6_Uebung_14.html",
    "title": "Übung 14",
    "section": "",
    "text": "Übung 14.1\nImportiere Geopandas und wandle zeckenstiche in eine GeoDataFrame um (zeckenstiche). Vergiss nicht, das Koordinatenbezugssystem festzulegen!\nMusterlösung\nimport pandas as pd\nimport geopandas as gpd\n\n# Übung 14.1\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n\ngeom = gpd.points_from_xy(\n  zeckenstiche['x'],    # ↘\n  zeckenstiche['y']     # → die Geometrie Spalte\n  )   \n\nzeckenstiche_gpd = gpd.GeoDataFrame(\n    zeckenstiche,    # die DataFrame (\"Attributtabelle\")\n    geometry = geom, #\n    crs = 2056       # das Koordinatenbezugssystem (EPSG Code)\n)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.2",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.2",
    "title": "Übung 14",
    "section": "Übung 14.2",
    "text": "Übung 14.2\nBuffere die Zeckenstiche um eine Distanz von 12 Meter und speichere den Output in der Variabel zeckenstiche_buffer. Visualisiere die gebufferten Punkte mit .explore().\n\n\nMusterlösung\nzeckenstiche_buffer = zeckenstiche_gpd.buffer(12)\nzeckenstiche_buffer.explore()\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 zeckenstiche_buffer = zeckenstiche_gpd.buffer(12)\n      2 zeckenstiche_buffer.explore()\n\nNameError: name 'zeckenstiche_gpd' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.3",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.3",
    "title": "Übung 14",
    "section": "Übung 14.3",
    "text": "Übung 14.3\nExtrahiere die Umrisse von zeckenstiche_buffer und speichere diese in zeckenstiche_buffer_outline. Visualisiere anschliessend diese Umrisse.\n\n\nMusterlösung\nzeckenstiche_buffer_outline = zeckenstiche_buffer.boundary\n\nzeckenstiche_buffer_outline.explore()\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 zeckenstiche_buffer_outline = zeckenstiche_buffer.boundary\n      3 zeckenstiche_buffer_outline.explore()\n\nNameError: name 'zeckenstiche_buffer' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.4",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.4",
    "title": "Übung 14",
    "section": "Übung 14.4",
    "text": "Übung 14.4\nNutze nachstehenden Code um zwei Datensätze im gleichen Plot darzustellen.\n\n\nMusterlösung\n# Nicht interaktiv:\nfrom matplotlib import pyplot as plt\nfig, ax = plt.subplots()\n\nzeckenstiche_buffer_outline.plot(ax = ax, color = \"green\")\nzeckenstiche_gpd.plot(ax = ax, color = \"pink\")\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 5\n      2 from matplotlib import pyplot as plt\n      3 fig, ax = plt.subplots()\n----&gt; 5 zeckenstiche_buffer_outline.plot(ax = ax, color = \"green\")\n      6 zeckenstiche_gpd.plot(ax = ax, color = \"pink\")\n\nNameError: name 'zeckenstiche_buffer_outline' is not defined\n\n\n\n\n\n\n\n\n\n\n\n\nMusterlösung\n# Interaktiv:\nbase = zeckenstiche_buffer_outline.explore(color = \"green\")\nzeckenstiche_gpd.explore(m = base, color = \"pink\")\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 # Interaktiv:\n----&gt; 2 base = zeckenstiche_buffer_outline.explore(color = \"green\")\n      3 zeckenstiche_gpd.explore(m = base, color = \"pink\")\n\nNameError: name 'zeckenstiche_buffer_outline' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.5",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.5",
    "title": "Übung 14",
    "section": "Übung 14.5",
    "text": "Übung 14.5\nBerechne das “Envelope” von zeckenstiche_gpd anhand der Beispiele in Räumliche Operationen. Speichere den Output als zeckenstiche_envelope.\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nDenk daran, dass du zuerst noch einen Union machen musst (siehe Räumliche Operationen)\n\n\n\n\n\nMusterlösung\nzeckenstiche_envelope = zeckenstiche_gpd.unary_union.envelope\n\nzeckenstiche_envelope",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/6_Uebung_14.html#übung-14.6",
    "href": "C_Programmieren_3/6_Uebung_14.html#übung-14.6",
    "title": "Übung 14",
    "section": "Übung 14.6",
    "text": "Übung 14.6\nExportiere zeckenstiche_gpd als “Geopackage” mit dem Namen “zeckenstiche.gpkg”. Lese nochmal Geodatenformate wenn du nicht mehr weisst, wie das geht. Versuche anschliessend, “zeckenstiche.gpkg” wieder einzulesen.\n\n\nMusterlösung\nzeckenstiche.to_file(\"data/zeckenstiche.gpkg\")",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Übung 14</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Spatial_Joins.html",
    "href": "C_Programmieren_3/7_Spatial_Joins.html",
    "title": "Spatial Joins",
    "section": "",
    "text": "Wie funktioniert ein Spatial Join?\nIn Input: GIS in Python habt ihr euch mit den GIS-Funktionalitäten von geopandas vertraut gemacht. Eine ganz zentrale Funktion in GIS sind die sogenannten “Spatial Joins”. Dabei werden Attribute von einem Geodatensatz auf einen anderen Geodatensatz aufgrund einer räumlichen Beziehung der beiden Datensätze übertragen. Konkret auf unsere Zeckenstiche bedeutet dies: Jedem Zeckenstich sollte die Eigenschaft “Wald: ja” / “Wald: nein” aus `wald zugewiesen werden. Am einfachsten lässt sich dies in einer Darstellung erklären:\nIn Python wird ein Spatial Join zwischen zeckenstiche und wald wie folgt durchgeführt (wichtig ist dabei auch die Reihenfolge der Argumente: left_df bestimmt den Geometrietyp des Outputs):\ngpd.sjoin(left_df = zeckenstiche_gpd, right_df = wald)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 gpd.sjoin(left_df = zeckenstiche_gpd, right_df = wald)\n\nNameError: name 'zeckenstiche_gpd' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Spatial Joins</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Spatial_Joins.html#wie-funktioniert-ein-spatial-join",
    "href": "C_Programmieren_3/7_Spatial_Joins.html#wie-funktioniert-ein-spatial-join",
    "title": "Spatial Joins",
    "section": "",
    "text": "Abbildung 51.1: “Spatial Join” zwischen zeckenstiche und wald. In diesem Spatial Join wurde die Geometrie von zeckenstiche übernommen, das heisst das Resultat des Joins ist ein Punkt-Layer.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Spatial Joins</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html",
    "href": "C_Programmieren_3/7_Uebung_15.html",
    "title": "Übung 15",
    "section": "",
    "text": "Übung 15.1\nLade das File “wald.gpkg” (siehe Tabelle 1) herunter und speichere es in deiner Workings Directory. Importiere den Datensatz und speichere ihn in der Variable wald.\nSchau dir wald an (mit type, .plot() etc.)\nMusterlösung\nimport geopandas as gpd \n\nwald = gpd.read_file(\"data/wald.gpkg\")\n\nwald\ntype(wald)\nwald.plot()",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html#sec-ex-spatialjoin",
    "href": "C_Programmieren_3/7_Uebung_15.html#sec-ex-spatialjoin",
    "title": "Übung 15",
    "section": "Übung 15.2",
    "text": "Übung 15.2\nFühre einen SpatialJoin zwischen wald und zeckenstiche durch. Vertausche die Reihenfolge (left_df, right_df) und schaue dir den Output an. Wodurch unterscheiden sich die beiden outputs? Was sagt dir das über die Funktionsweise von sjoin?\n\n\n\n\n\n\nWichtig!\n\n\n\nMelde dich bei den Betreuern wenn der SpatialJoin bei dir nicht funktioniert und du eine Fehlermeldung bekommst.\n\n\n\n\nMusterlösung\nzeckenstiche_gpd = gpd.read_file(\"data/zeckenstiche.gpkg\")\n\ngpd.sjoin(left_df = zeckenstiche_gpd, right_df = wald)\ngpd.sjoin(left_df = wald, right_df = zeckenstiche_gpd) \n\n# in beiden Fällen hat der Output geich viele Zeilen. \n# In der ersten Variante ist die Geometrie\n# des Outputs \"Point\", im zweiten Fall \"Multipolygon\"",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html#sec-ex-count",
    "href": "C_Programmieren_3/7_Uebung_15.html#sec-ex-count",
    "title": "Übung 15",
    "section": "Übung 15.3",
    "text": "Übung 15.3\nFühre nun den SpatialJoin aus Übung 15.2 in der Reihenfolge aus, der dir am sinnvollsten erscheint. Weise den Output dieser Operation der Variabel zeckenstiche_join zu.\nNutze nun die dazugewonnene Spalte Wald_text um die Anzahl Zeckenstich-Meldungen im Wald zu zählen. Dazu musst du wie folgt vorgehen:\n\nEntsprechende Spalte selektieren (siehe Übung 4.5)\nWerte in der Spalte mit “ja” vergleichen\nAnzahl True mit sum() zählen (True entspricht immer 1, False entspricht immer 0)\n\n\n\nMusterlösung\n# die folgende Variante (mit dem Output \"point\") ist sinnvoller, da auch\n# wir uns primär für die Punkte (Zeckenstiche) interessieren.\nzeckenstiche_join = gpd.sjoin(left_df = zeckenstiche_gpd, right_df = wald)\n\nsum(zeckenstiche_join[\"Wald_text\"] == \"ja\")",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/7_Uebung_15.html#übung-15.4",
    "href": "C_Programmieren_3/7_Uebung_15.html#übung-15.4",
    "title": "Übung 15",
    "section": "Übung 15.4",
    "text": "Übung 15.4\nBerechne nun Anteil der Zeckenstiche im Wald (gemessen an der Anzahl Zeckenstich-Meldungen total). Weise den Output der Variabel anteil_wald zu.\n\n\nMusterlösung\nanteil_wald = sum(zeckenstiche_join[\"Wald_text\"] == \"ja\")/len(zeckenstiche_join[\"Wald_text\"])",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>Übung 15</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Ziel und Vorgehen\nFür den Leistungsnachweis von Programmieren sollt ihr den Anteil der Zeckenstiche im Wald unter der Berücksichtigung der Unsicherheit mit einer Monte Carlo Simulation ermitteln.\nGehe dazu wie folgt vor: Erstelle einen for loop (siehe Basic for loop), welcher pro Iteration folgende Schritte ausführt:",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#ziel-und-vorgehen",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#ziel-und-vorgehen",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Schritt: Zeckenstiche importieren\nSchritt: Zeckenstiche auf der Basis von gemeldeten Stiche simulieren (siehe Funktionen in DataFrames)\nSchritt: Simulierte Zeckenstiche von pandas DataFrame in geopandas GeoDataFrame umwandeln (siehe DataFrames &gt; GeoDataFrames)\nSchritt: Spatial Join mit wald.gpkg (siehe Übung 15.2)\nSchritt: Der Anteil der Zeckenstiche im Wald Berechnen (siehe Übung 15.3)\nSchritt: Schritte 2 - 5 mindestens 50x Wiederholen (for loop)\nSchritt: Die verschiedenen Waldanteile visualiseren (z.B. in einem Boxplot, siehe Anhang 1: Daten visualisieren)\nSchritt: Schritte 6 und 7 für drei verschiedene Radien wiederholen\nSchritt (Optional): Eine Karte mit den simulierten Zeckenstichen erstellen (siehe Anhang 2: Geodaten visualisieren)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#anforderungen",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#anforderungen",
    "title": "Leistungsnachweis",
    "section": "Anforderungen",
    "text": "Anforderungen\nFühre die Analyse folgendermassen durch:\n\nmit dem ganzen Datensatz zeckenstiche_full.csv (1’076 Meldungen, siehe Tabelle 1)\nmit mindestens 50 Iterationen\nmit drei verschiedenen Distanz-Werten (distance = in Übung 8.5).\n\nVisualisiere für jeden Distanzwert die Verteilung der Anteile (z.B: mittels einem Boxplot)",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#struktur",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#struktur",
    "title": "Leistungsnachweis",
    "section": "Struktur",
    "text": "Struktur\nFühre die Datenanalyse durch, indem du Python Code mit Markdown Text ergänzt.\nStrukturiere den Bericht mithilfe von Markdown in folgende Unterkapitel\n\nEinleitung\nMaterial & Methoden\nResultate\nDiskussion\n\nSorge dafür, dass der Bericht sauber und ordentlich daher kommt (vermeide zum Beispiel lange Python Messages im Bericht, entferne unnötigen Code). Führt die Datenanalyse durch, indem ihr den Python Code mit Markdown Text unterstützt. Beschreibt und begründet eure Analyseschritte und wie die Resultate zu interpretieren sind. Der Fokus soll auf der technischen Umsetzung liegen, nicht auf der Interpretation der Resultate.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/9_Leistungsnachweis.html#abgabeformat",
    "href": "C_Programmieren_3/9_Leistungsnachweis.html#abgabeformat",
    "title": "Leistungsnachweis",
    "section": "Abgabeformat",
    "text": "Abgabeformat\nDas Jupyter-Notebook File via Moodle. Wichtig: Zuerst alle Zellen ausführen (Run &gt; Restart Kernel and Run all cells…). Notebooks, bei denen dieser Schritt nicht ausgeführt wurden, werden nicht akzeptiert!",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/10_Anhang.html",
    "href": "C_Programmieren_3/10_Anhang.html",
    "title": "Anhang",
    "section": "",
    "text": "Anhang 1: Daten visualisieren\nEs ist äusserst Zentral, Daten regelmässig und oft zu visualisieren. Die de facto standart Library hierfür in Python ist matplotlib. Diese Library kann man direkt ansteuern wie in diesem Tutorial beschrieben wird. Wir verwenden die library jedoch etwas anders: Dabei nutzen wir die Tatsache aus, dass sowohl pandas wie auch geopandas eingebaute Methoden (methods) haben um deren Inhalte zu visualisieren. Die Methode heisst in beiden Fällen .plot(), wie wir weiter unten noch sehen werden.",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/10_Anhang.html#sec-viz",
    "href": "C_Programmieren_3/10_Anhang.html#sec-viz",
    "title": "Anhang",
    "section": "",
    "text": "Histogramm aus List\npandas vereinfacht das Visualisieren von Daten sogar soweit, dass es sich jewils lohnt seine Listen, Dictionaries usw. zuerst in eine Series oder DataFrame zu überführen um sie zu visualisieren (wie ich zum Beispiel in Zufallszahlen generieren jeweils gemacht habe).\n\nimport random\nimport pandas as pd\n\nrandom_gamma = [random.gammavariate(1, 1) for x in range(1000)]\n\nrandom_gamma = pd.Series(random_gamma)\n\nrandom_gamma.plot(kind = \"hist\", bins = 50)\n\n\n\n\n\n\n\n\nWeitere Beispiele zu Histogrammen aus Listen findet ihr im Kapitel Zufallszahlen generieren .\n\n\nBoxplot aus List\nDas Visualisieren als Boxplot ist sehr ähnlich, man ersetzt \"hist\" lediglich durch \"box. Eine komplette liste der möglichen Argumente für findet ihr hier: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.plot.html\n\nrandom_gamma.plot(kind = \"box\")\n\n\n\n\n\n\n\n\n\n\nScatterplot aus DataFrame\nUm einen Scatterplot zu erstellen, braucht es eine DataFrame (eine Series reicht hierfür nicht aus).\n\nzeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 zeckenstiche = pd.read_csv(\"data/zeckenstiche.csv\")\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)\n   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)\n    617 _validate_names(kwds.get(\"names\", None))\n    619 # Create the parser.\n--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)\n    622 if chunksize or iterator:\n    623     return parser\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)\n   1617     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n   1619 self.handles: IOHandles | None = None\n-&gt; 1620 self._engine = self._make_engine(f, self.engine)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880, in TextFileReader._make_engine(self, f, engine)\n   1878     if \"b\" not in mode:\n   1879         mode += \"b\"\n-&gt; 1880 self.handles = get_handle(\n   1881     f,\n   1882     mode,\n   1883     encoding=self.options.get(\"encoding\", None),\n   1884     compression=self.options.get(\"compression\", None),\n   1885     memory_map=self.options.get(\"memory_map\", False),\n   1886     is_text=is_text,\n   1887     errors=self.options.get(\"encoding_errors\", \"strict\"),\n   1888     storage_options=self.options.get(\"storage_options\", None),\n   1889 )\n   1890 assert self.handles is not None\n   1891 f = self.handles.handle\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'data/zeckenstiche.csv'\n\n\n\n\nzeckenstiche.plot(\"x\", \"y\", kind = \"scatter\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 zeckenstiche.plot(\"x\", \"y\", kind = \"scatter\")\n\nNameError: name 'zeckenstiche' is not defined\n\n\n\n\n\nStatische Karte aus GeoDataFrame\nUm aus GeoDataFrames Karten zu machen verwendet man ebenfalls die .plot() Methode. Um wirklich schöne Karten mit Python herzustellen braucht man viel Übung. Für eine schnelle Visualisierung reicht aber die .plot() Methode.\n\nimport geopandas as gpd\n\nzeckenstiche = gpd.read_file(\"data/zeckenstiche.gpkg\")\nwald = gpd.read_file(\"data/wald.gpkg\")\n\n\n---------------------------------------------------------------------------\nDataSourceError                           Traceback (most recent call last)\nCell In[5], line 3\n      1 import geopandas as gpd\n----&gt; 3 zeckenstiche = gpd.read_file(\"data/zeckenstiche.gpkg\")\n      4 wald = gpd.read_file(\"data/wald.gpkg\")\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:294, in _read_file(filename, bbox, mask, columns, rows, engine, **kwargs)\n    291             from_bytes = True\n    293 if engine == \"pyogrio\":\n--&gt; 294     return _read_file_pyogrio(\n    295         filename, bbox=bbox, mask=mask, columns=columns, rows=rows, **kwargs\n    296     )\n    298 elif engine == \"fiona\":\n    299     if pd.api.types.is_file_like(filename):\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:547, in _read_file_pyogrio(path_or_bytes, bbox, mask, rows, **kwargs)\n    538     warnings.warn(\n    539         \"The 'include_fields' and 'ignore_fields' keywords are deprecated, and \"\n    540         \"will be removed in a future release. You can use the 'columns' keyword \"\n   (...)\n    543         stacklevel=3,\n    544     )\n    545     kwargs[\"columns\"] = kwargs.pop(\"include_fields\")\n--&gt; 547 return pyogrio.read_dataframe(path_or_bytes, bbox=bbox, **kwargs)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/geopandas.py:261, in read_dataframe(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, fid_as_index, use_arrow, on_invalid, arrow_to_pandas_kwargs, **kwargs)\n    256 if not use_arrow:\n    257     # For arrow, datetimes are read as is.\n    258     # For numpy IO, datetimes are read as string values to preserve timezone info\n    259     # as numpy does not directly support timezones.\n    260     kwargs[\"datetime_as_string\"] = True\n--&gt; 261 result = read_func(\n    262     path_or_buffer,\n    263     layer=layer,\n    264     encoding=encoding,\n    265     columns=columns,\n    266     read_geometry=read_geometry,\n    267     force_2d=gdal_force_2d,\n    268     skip_features=skip_features,\n    269     max_features=max_features,\n    270     where=where,\n    271     bbox=bbox,\n    272     mask=mask,\n    273     fids=fids,\n    274     sql=sql,\n    275     sql_dialect=sql_dialect,\n    276     return_fids=fid_as_index,\n    277     **kwargs,\n    278 )\n    280 if use_arrow:\n    281     meta, table = result\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/raw.py:196, in read(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, return_fids, datetime_as_string, **kwargs)\n     56 \"\"\"Read OGR data source into numpy arrays.\n     57 \n     58 IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted\n   (...)\n    191 \n    192 \"\"\"\n    194 dataset_kwargs = _preprocess_options_key_value(kwargs) if kwargs else {}\n--&gt; 196 return ogr_read(\n    197     get_vsi_path_or_buffer(path_or_buffer),\n    198     layer=layer,\n    199     encoding=encoding,\n    200     columns=columns,\n    201     read_geometry=read_geometry,\n    202     force_2d=force_2d,\n    203     skip_features=skip_features,\n    204     max_features=max_features or 0,\n    205     where=where,\n    206     bbox=bbox,\n    207     mask=_mask_to_wkb(mask),\n    208     fids=fids,\n    209     sql=sql,\n    210     sql_dialect=sql_dialect,\n    211     return_fids=return_fids,\n    212     dataset_kwargs=dataset_kwargs,\n    213     datetime_as_string=datetime_as_string,\n    214 )\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:1239, in pyogrio._io.ogr_read()\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:219, in pyogrio._io.ogr_open()\n\nDataSourceError: data/zeckenstiche.gpkg: No such file or directory\n\n\n\nEinfache Plots ohne anpassung:\n\nwald.plot()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 wald.plot()\n\nNameError: name 'wald' is not defined\n\n\n\nAnpassung der Plot Grösse:\n\nwald.plot(figsize = (5,5))\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 wald.plot(figsize = (5,5))\n\nNameError: name 'wald' is not defined\n\n\n\nChoroplethenkarte Karte\n\nfrom matplotlib.colors import ListedColormap\n\nmy_cmap = ListedColormap([\"green\",\"lightgrey\"])\nwald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 4\n      1 from matplotlib.colors import ListedColormap\n      3 my_cmap = ListedColormap([\"green\",\"lightgrey\"])\n----&gt; 4 wald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\n\nNameError: name 'wald' is not defined\n\n\n\nMehrere Layers:\n\nbase = wald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\nzeckenstiche.plot(color = \"Red\", ax = base)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 base = wald.plot(column = \"Wald_text\", legend = True, cmap = my_cmap)\n      2 zeckenstiche.plot(color = \"Red\", ax = base)\n\nNameError: name 'wald' is not defined\n\n\n\n\n\nInteraktive Karten aus GeoDataFrame\nWeitere Informationen dazu findet ihr hier: https://geopandas.org/docs/user_guide/interactive_mapping.html\nVollautomatisch, ohne Anpassungen:\n\nzeckenstiche.explore()\n\nZeckenstiche Rot eingefärbt:\n\nzeckenstiche.explore(color = \"red\")\n\nZeckenstiche nach \"accuracy\" eingefärbt:\n\nzeckenstiche.explore(column = \"accuracy\")\n\nWald nach \"Wald_text\" eingefärbt (beachte, dass ich my_cmap weiter oben erstellt habe!):\n\nwald.explore(column = \"Wald_text\", cmap = my_cmap)\n\nZwei übereinander gelagerte Layers:\n\nbase = wald.explore(column = \"Wald_text\", cmap = my_cmap)\nzeckenstiche.explore(m = base, color = \"red\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 base = wald.explore(column = \"Wald_text\", cmap = my_cmap)\n      2 zeckenstiche.explore(m = base, color = \"red\")\n\nNameError: name 'wald' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "C_Programmieren_3/10_Anhang.html#sec-geoviz",
    "href": "C_Programmieren_3/10_Anhang.html#sec-geoviz",
    "title": "Anhang",
    "section": "Anhang 2: Geodaten visualisieren",
    "text": "Anhang 2: Geodaten visualisieren\nIn folgenden Beispielen zeigen wir noch ein paar einfache Wege, wie ihr die Zeckenstichdaten visualisieren könnt.\n\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport descartes\n\nwald = gpd.read_file(\"data/wald.gpkg\")\nzeckenstiche_full = pd.read_csv(\"data/zeckenstiche_full.csv\")\n\ngeom = gpd.points_from_xy(zeckenstiche_full['x'], zeckenstiche_full['y'])\n\nzeckenstiche_gpd = gpd.GeoDataFrame(\n    zeckenstiche_full,\n    geometry=geom,\n    crs = 2056)\n\n\n---------------------------------------------------------------------------\nDataSourceError                           Traceback (most recent call last)\nCell In[11], line 6\n      3 import matplotlib.pyplot as plt\n      4 import descartes\n----&gt; 6 wald = gpd.read_file(\"data/wald.gpkg\")\n      7 zeckenstiche_full = pd.read_csv(\"data/zeckenstiche_full.csv\")\n      9 geom = gpd.points_from_xy(zeckenstiche_full['x'], zeckenstiche_full['y'])\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:294, in _read_file(filename, bbox, mask, columns, rows, engine, **kwargs)\n    291             from_bytes = True\n    293 if engine == \"pyogrio\":\n--&gt; 294     return _read_file_pyogrio(\n    295         filename, bbox=bbox, mask=mask, columns=columns, rows=rows, **kwargs\n    296     )\n    298 elif engine == \"fiona\":\n    299     if pd.api.types.is_file_like(filename):\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/geopandas/io/file.py:547, in _read_file_pyogrio(path_or_bytes, bbox, mask, rows, **kwargs)\n    538     warnings.warn(\n    539         \"The 'include_fields' and 'ignore_fields' keywords are deprecated, and \"\n    540         \"will be removed in a future release. You can use the 'columns' keyword \"\n   (...)\n    543         stacklevel=3,\n    544     )\n    545     kwargs[\"columns\"] = kwargs.pop(\"include_fields\")\n--&gt; 547 return pyogrio.read_dataframe(path_or_bytes, bbox=bbox, **kwargs)\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/geopandas.py:261, in read_dataframe(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, fid_as_index, use_arrow, on_invalid, arrow_to_pandas_kwargs, **kwargs)\n    256 if not use_arrow:\n    257     # For arrow, datetimes are read as is.\n    258     # For numpy IO, datetimes are read as string values to preserve timezone info\n    259     # as numpy does not directly support timezones.\n    260     kwargs[\"datetime_as_string\"] = True\n--&gt; 261 result = read_func(\n    262     path_or_buffer,\n    263     layer=layer,\n    264     encoding=encoding,\n    265     columns=columns,\n    266     read_geometry=read_geometry,\n    267     force_2d=gdal_force_2d,\n    268     skip_features=skip_features,\n    269     max_features=max_features,\n    270     where=where,\n    271     bbox=bbox,\n    272     mask=mask,\n    273     fids=fids,\n    274     sql=sql,\n    275     sql_dialect=sql_dialect,\n    276     return_fids=fid_as_index,\n    277     **kwargs,\n    278 )\n    280 if use_arrow:\n    281     meta, table = result\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/raw.py:196, in read(path_or_buffer, layer, encoding, columns, read_geometry, force_2d, skip_features, max_features, where, bbox, mask, fids, sql, sql_dialect, return_fids, datetime_as_string, **kwargs)\n     56 \"\"\"Read OGR data source into numpy arrays.\n     57 \n     58 IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted\n   (...)\n    191 \n    192 \"\"\"\n    194 dataset_kwargs = _preprocess_options_key_value(kwargs) if kwargs else {}\n--&gt; 196 return ogr_read(\n    197     get_vsi_path_or_buffer(path_or_buffer),\n    198     layer=layer,\n    199     encoding=encoding,\n    200     columns=columns,\n    201     read_geometry=read_geometry,\n    202     force_2d=force_2d,\n    203     skip_features=skip_features,\n    204     max_features=max_features or 0,\n    205     where=where,\n    206     bbox=bbox,\n    207     mask=_mask_to_wkb(mask),\n    208     fids=fids,\n    209     sql=sql,\n    210     sql_dialect=sql_dialect,\n    211     return_fids=return_fids,\n    212     dataset_kwargs=dataset_kwargs,\n    213     datetime_as_string=datetime_as_string,\n    214 )\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:1239, in pyogrio._io.ogr_read()\n\nFile ~/miniconda3/envs/modul-agi/lib/python3.12/site-packages/pyogrio/_io.pyx:219, in pyogrio._io.ogr_open()\n\nDataSourceError: data/wald.gpkg: No such file or directory\n\n\n\n\nKernel Density Plot\nMit der Erweiterung seaborn lassen sich mit wenigen Zeilen Code eine Kernel Density rechnen und visualisieren. Siehe nachstehenden Code:\n\nimport seaborn as sns\n\nf, ax = plt.subplots(1, figsize=(6, 6))\nwald.boundary.plot(linewidth=0.1, ax=ax)\nzeckenstiche_gpd.plot(color='red', linewidth=0.1, ax=ax)\n\nsns.kdeplot(x = zeckenstiche_full.x, y= zeckenstiche_full.y,shade = False,n_levels = 10, cmap = \"viridis\", ax = ax)\n\nax.set_axis_off()\nplt.show()\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 import seaborn as sns\n      3 f, ax = plt.subplots(1, figsize=(6, 6))\n      4 wald.boundary.plot(linewidth=0.1, ax=ax)\n\nModuleNotFoundError: No module named 'seaborn'\n\n\n\n\n\nHintergrundkarte\nMit der Erweiterung contextily kann man sehr schnell und einfach Hintergrundkarten in den Plot einbinden. Dafür muss das GeoDataFrame vorher aber in WGS84 Koordinaten (EPSG 3857) konvertiert werden (mit to_crs, s.u.).\n\nimport contextily as ctx\n\nf, ax = plt.subplots(1, figsize=(6, 6))\nzeckenstiche_gpd.to_crs(epsg = 3857).plot(ax = ax)\nctx.add_basemap(ax)\n\nax.set_axis_off()\nplt.show()\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 import contextily as ctx\n      3 f, ax = plt.subplots(1, figsize=(6, 6))\n      4 zeckenstiche_gpd.to_crs(epsg = 3857).plot(ax = ax)\n\nModuleNotFoundError: No module named 'contextily'\n\n\n\n\n\nKDE mit Hintergrundkarte\nKernel Denisty und Hintergrundkarte können auch kombiniert werden:\n\nlat = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.x\nlng = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.y\n\nf, ax = plt.subplots(1, figsize=(6, 6))\n\nsns.kdeplot(x = lat,y = lng,shade = False,n_levels = 25, cmap = \"viridis\", ax = ax)\nctx.add_basemap(ax)\n\nax.set_axis_off()\nplt.show()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 lat = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.x\n      2 lng = zeckenstiche_gpd.to_crs(epsg = 3857).geometry.y\n      4 f, ax = plt.subplots(1, figsize=(6, 6))\n\nNameError: name 'zeckenstiche_gpd' is not defined",
    "crumbs": [
      "Programmieren III",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>Anhang</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html",
    "title": "Vorbereitung",
    "section": "",
    "text": "Datensätze\nLaden Sie das File netzwerkanalyse.gpkg von Moodle herunter. Hier befinden sich alle Datensätze, die im Laufe des Blocks “Netzwerkanalyse” benötigt werden:",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#datensätze",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#datensätze",
    "title": "Vorbereitung",
    "section": "",
    "text": "Tabelle 55.1: Datensätze im File netzwerkanalyse.gpkg für den Block “Netzwerkanalyse”\n\n\n\n\n\n\n\n\n\n\nLayer\nKoord. System\nBeschreibung\n\n\n\n\nGemeinde_Waedenswil\nEPSG 2056\nDie Gemeindegrenze von Wädenswil. Dieser Datensatz basiert auf swissBOUNDARIES3D von Swisstopo.\n\n\nosm_highway\nEPSG 4326\nAlle “Highway” Linien aus dem OpenStreetmaps (Stand nach* Übung 5: OpenStreetMap Vektordaten herunterladen)\n\n\nosm_highway_prepared\nEPSG 2056\nAlle “Highway” Linien transformiert und neu projiziert (Output aus Übung 1.2: Daten Clippen)\n\n\nshops_waedenswil\nEPSG 2056\nAlle Läden in Wädenswil, für Übung 4.2: Traveling Salesperson für mehr Standorte\n\n\nbuildings_waedenswil_polygons\nEPSG 2056\nAlle Gebäudestandorte (Polygon Daten) in Wädenswil, für Übung 4.3 (fakultativ, Guezli-Challenge): Traveling Salesperson für noch mehr Standorte\n\n\nabfallentsorgung_waedenswil\nEPSG 2056\nEntsorgungsstellen Wädenswil\n\n\nwaedenswil_centrality\nEPSG 2056\nZentralitätsmasse für Wädenswil (aus Übung 2.3: Zentralitätsmasse berechnen)\n\n\nHaltestellen_waedenswil\nEPSG 2056\nHaltestellen in Wädenswil",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-1-qgis-installieren",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-1-qgis-installieren",
    "title": "Vorbereitung",
    "section": "Übung 1: QGIS installieren",
    "text": "Übung 1: QGIS installieren\nAuf der QGIS Homepage qgis.org finden Sie die aktuellen QGIS Versionen für Windows, Linux, Mac und weitere Betriebssysteme in 32 und 64 bit. Laden Sie den passenden Standalone Installer des “Longterm release (most stable)” herunter (aktuell 3.28). Installieren Sie QGIS nach dem Download.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-2-tutorials-anschauen",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-2-tutorials-anschauen",
    "title": "Vorbereitung",
    "section": "Übung 2: Tutorials anschauen",
    "text": "Übung 2: Tutorials anschauen\nSchauen Sie sich danach zum Einstieg einzelne Videos vom Youtube Nutzer Marshal Mappers an. Schauen Sie die Videos bis Sie die grundlegendsten Arbeitsschritte von QGIS (Daten importieren, Werkzeuge finden, Karte zu pdf exportieren) verstanden haben. Erstellen Sie dann ein neues Projekt (Projekt→New) und speichern Sie dieses direkt ab (Projekt→Save As..).",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-3-daten-importieren",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-3-daten-importieren",
    "title": "Vorbereitung",
    "section": "Übung 3: Daten importieren",
    "text": "Übung 3: Daten importieren\nWährend Shapefiles im GIS-Unterricht bisher oft zur Speicherung von Vectordaten verwendet wurden, werden in QGIS vor allem Geopackage Dateien verwendet (.gpkg). QGIS kann Shapefiles durchaus lesen und schreiben, wir werden in den Übungen aber vor allem mit Geopackage Daten arbeiten. Geopackages sind eine alternative Methode, Vektordaten abzuspeichern. Sie beheben einige Defizite, die Shapefiles mit sich bringen. Siehe dazu auch die Website “Shapefiles must die”.\n\nNeues QGIS Projekt starten und Projektdatei speichern (Beachten Sie dazu die Empfehlungen am Anfang)\nCRS auf EPSG 2056 setzen\nAus dem File netzwerkanalyse.gpgk den Layer Gemeinde_Waedenswil (siehe Tabelle 55.1) in QGIS Importieren\nSymbologie folgendermassen ändern: Fläche transparent, Stadtgrenze schwarz",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-plugins",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-plugins",
    "title": "Vorbereitung",
    "section": "Übung 4: Plugin installieren",
    "text": "Übung 4: Plugin installieren\nQGIS wird von zahlreichen Einzelpersonen und Gruppen entwickelt. Aus diesem Grund ist die Software modular aufgebaut, und nur ein Teil wird mit der Standard-Installation mitgeliefert. Für einige Funktionen müssen zusätzliche Erweiterungen (sogenannte “Plugins”) installiert werden. Installieren Sie das Plugin “QuickOSM” um OpenStreetMap (OSM) Vektordaten rasch und einfach lokal abspeichern zu können.\n\nReiter Plugins→Manage and Install Plugins\nIm Suchfenster “QuickOSM” suchen\nPlugin anwählen und auf “install” klicken\n\nDie wichtigsten Metadaten zu allen Plugins werden auf plugins.qgis.org festgehalten. Dort findet man auch Links zur Projektseite, weiteren Dokumentation und ggf. Tutorials: Zu QuickOSM sind die Metadaten hier abrufbar: https://plugins.qgis.org/plugins/QuickOSM/",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-osmdownload",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#sec-ex-network-osmdownload",
    "title": "Vorbereitung",
    "section": "Übung 5: OpenStreetMap Vektordaten herunterladen",
    "text": "Übung 5: OpenStreetMap Vektordaten herunterladen\nMit dem neuen Plugin “QuickOSM” laden Sie nun den Strassendatensatz der Gemeinde Wädenswil herunter. Dies geschieht folgendermassen:\n\nRechtsklick auf den Layer Gemeinde_Waedenswil → Zoom to layer\nReiter Vektor → Quick OSM → Quick OSM\nWählen Sie bei der Option key “highway” und lassen value leer\nWählen Sie Option “Canvas Extent”\nKlicken Sie anschliessend auf “Run query”\n\nDas Query lädt nebst den Liniendaten auch noch Punkt- und Polygon-Daten herunter. Diese interessieren uns nicht und können entfernt werden (Rechtsklick→remove).",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-6-temporäre-datei-abspeichern",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#übung-6-temporäre-datei-abspeichern",
    "title": "Vorbereitung",
    "section": "Übung 6: Temporäre Datei abspeichern",
    "text": "Übung 6: Temporäre Datei abspeichern\nOutputs werden in QGIS standardmässig in einem Temp-Folder abgelegt. Diese Dateien werden nach Beendigung von QGIS gelöscht. Um die Daten auch zu einem späteren Zeitpunkt verwenden zu können, müssen sie an einem geeigneten Ort abgespeichert werden. Führen Sie diesen Schritt mit den eben beschafften OSM Strassendaten (nur Linien) aus. Im gleichen Schritt können Sie alle unnötigen Spalten aus der grossen Attributtabelle löschen.\n\nRechtsklick auf den temporären Linien-Layer → Export → Save Features As…\nUnter “Select fields to export and their export options” nur Spalte highway auswählen\nFormat: Geopackage\nFilename: Geeigneter Speicherort1 aufsuchen und Datei abspeichern als “osm_highway.gpkg” (Erweiterung muss nochmals angegeben werden)\n\n\n\n\n\n\n\nMerken Sie sich:\n\n\n\n\nEs lohnt sich, vor jedem Projekt eine sinnvolle Ordnerstruktur aufzubauen\nNeben Shapefiles gibt es weitere (bessere?) Wege, wie Vektordaten abgespeichert werden können. Eine gute Variante ist Geopackage.\nQGIS ist mittlerweile ein mächtiges Werkzeug, welches für die Bearbeitung vieler klassischer GIS Fragestellungen geeignet ist.\nQGIS ist modular aufgebaut, wichtige Funktionen sind über Plugins verfügbar. Dadurch kommt QGIS nicht aus “einem Guss” daher.\nOutputs werden in temporären Dateien abgespeichert, die bei der Schliessung von QGIS gelöscht werden. Sollen Geodaten permanent verfügbar sein, müssen sie entsprechend explizit abgespeichert werden.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/2_Vorbereitung.html#footnotes",
    "href": "D_Netzwerkanalyse_1/2_Vorbereitung.html#footnotes",
    "title": "Vorbereitung",
    "section": "",
    "text": "Merken Sie sich den Speicherort, Sie werden das File in der kommenden Übung brauchen.↩︎",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>Vorbereitung</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/3_QGIS.html",
    "href": "D_Netzwerkanalyse_1/3_QGIS.html",
    "title": "Aufgabe 1: Operationen mit QGIS",
    "section": "",
    "text": "Übung 1.1: Daten Transformieren\nDie OSM Daten sind aktuell noch im Koordinatensystem WGS84 (EPSG 4326). Die Gemeindegrenze hingegen ist mit den neuen Schweizer Landeskoordinaten CH1903+ LV95 (EPSG 2056) abgespeichert. Wir wollen in unserer Analyse mit CH1903+ LV95 (EPSG 2056) arbeiten. Transformieren Sie dazu den Strassendatensatz in das Koordinatensystem CH1903+ LV95 (EPSG 2056). Nutzen Sie dazu das Tool Reproject Layer. Wichtig: Speichern Sie den Transformierten Strassendatensatz in einer neuen Datei (siehe Abbildung 56.2)\nViele wichtige Tools lassen sich über die Menü Bar aufrufen (v.a. “Vector” und “Raster”). Die Tools lassen sich auch relativ rasch mit der Suchfunktion in “Processing Toolbox” finden.\nSpeichern Sie den neuen Strassendatensatz in einer neuen Datei, nicht als temporärer Layer. Normalerweise spielt dies keine Rolle, doch im Falle von “reproject” entsteht beim Speichern als temporärer Layer ein Fehler.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 1: Operationen mit QGIS</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-network-transfrom",
    "href": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-network-transfrom",
    "title": "Aufgabe 1: Operationen mit QGIS",
    "section": "",
    "text": "Abbildung 56.2: Tool Reproject Layer",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 1: Operationen mit QGIS</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-clip",
    "href": "D_Netzwerkanalyse_1/3_QGIS.html#sec-ex-clip",
    "title": "Aufgabe 1: Operationen mit QGIS",
    "section": "Übung 1.2: Daten Clippen",
    "text": "Übung 1.2: Daten Clippen\nZoomen sie auf die Gemeindegrenze (Layers Panel→Rechtsklick auf Datensatz → Zoom to layer). Sie stellen fest, dass die Strassendaten über die Gemeindegrenze hinaus verlaufen. Wir möchten für die kommenden Übungen nur die Strassen, die innerhalb der Gemeinde Wädenswil liegen. Dazu müssen wir das Strassennetz mit der Gemeindegrenze verschneiden (“clip”). Führen Sie das gleichnamige Werkzeug mit dem Input Layer “OSM_highway” und dem Clip Layer Gemeinde_Waedenswil aus. Speichern Sie die Ausgabe in einer neuen Datei.\nEs gibt eine ganze Reihe Werkzeuge zum Begriff “clip”. Entscheiden Sie selbst, welches für diese Fragestellung geeignet ist.\n\n\n\n\n\n\nHinweis\n\n\n\n\nAchten Sie darauf, das dem neuen (“clipped”) Datensatz das richtige Koordinatensystem zugewiesen wurde. Wenn nicht, gehe zu: Properties &gt; Source &gt; Assigned Coordinate Reference System (CRS), wähle the EPSG:2056 - CH1903+ / LV95 und klicke auf Apply",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>Aufgabe 1: Operationen mit QGIS</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "",
    "text": "Übung 2.1: Topologie bereinigen\nDas OSM Strassennetz “osm_highway” ist topologisch nicht perfekt für unsere Zwecke vorbereitet. An Kreuzungen fehlen teilweise Knoten, welche ein “Abbiegen” auf der Kreuzung ermöglichen. Um diesen Umstand zu beheben, nutzen wir das Tool v.clean und führen damit die Operation “break” durch. Dadurch werden Linien an Kreuzungen unterbrochen. Diese Operation löst einige topologische Fehler, führt z.B. bei Brücken und Tunnels aber zu neuen Unstimmigkeiten, die Sie an dieser Stelle aber getrost ignorieren können.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.1-topologie-bereinigen",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.1-topologie-bereinigen",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "",
    "text": "Werkzeug v.clean auswählen\nParameter:\n\nLayer to clean : Transformierter und geclippter OSM Strassendatensatz\nCleaning tool : break\nv.out.ogr output type: auto\ncleaned (output): Save to File…\n\nMit “Run” ausführen",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.2-losgelöste-getrennte-elemente-entfernen",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.2-losgelöste-getrennte-elemente-entfernen",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.2: Losgelöste (getrennte) Elemente entfernen",
    "text": "Übung 2.2: Losgelöste (getrennte) Elemente entfernen\nAufmerksamen Anwendern könnte nun auffallen, dass gewisse Bestandteile des Netzwerks nicht mit dem Hauptnetz verbunden sind. Diese getrennten Elemente können mit dem Werkzeug v.net.components identifiziert werden. Das Werkzeug prüft, welche Bestandteile des Netzwerkes miteinander verbunden sind und gruppiert diese mit Nummern. Diese Nummern werden in der Spalte “comp” abgespeichert.\nIm Idealfall sollte unser Netzwerk aus einer Gruppe bestehen; so wäre jeder Knotenpunkt mit jedem andern Knotenpunkt verbunden: Bei uns ist dies jedoch nicht der Fall. Damit wir in den nachstehenden Übungen mit einem sauberen Datensatz arbeiten können, bereinigen wir dieses Problem an dieser Stelle:\n\nFühren Sie das Werkzeug v.net.components aus\n\nType of components : “strong”\nV.out.ogr output type: auto\nNetwork_Components_Line: Save to File…\nNetwork_Components_Point: Save to File…\n\nDer neue Linien Datensatz verfügt (wie oben beschrieben) über eine Spalte “comp”. Überprüfen Sie dies indem Sie die Attributtabelle anschauen.\nFärben Sie die Linien nach der Spalte (“comp”) ein. So, dass jede Gruppe eine Farbe erhält.\nErmitteln Sie die Nummer der Hauptkategorie (z.B. mit dem Werkzeug “Identify Features”)\nÖffnen Sie die Attributtabelle und machen sie eine “Selektion anhand einer Abfrage” (“Select Features using an expression” [1])\nSelektieren Sie die Hauptkategorie mittels einer korrekten Abfrage (z.B. comp = 99). QGIS bietet ihnen hierfür leider wenig Hilfestellung (im Gegensatz zum Query Builder von ArcGIS)\nUm die anderen Kategorien zu entfernen, haben Sie nun zwei Möglichkeiten:\n\nEine Editiersession starten [2], die Selektion invertieren [3] und die selektierten Daten löschen [4]. ODER\nSelektierte Daten (ohne Invertierung) in ein neues File exportieren mittels Rechtsklick auf den Layer→“Save as”→Häkchen bei “Save only selected features”\n\nSpeichern Sie den Layer anschliessend mit folgendem Namen ab: “osm_highway_prepared.gpkg”",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#sec-ex-centrality-calculate",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#sec-ex-centrality-calculate",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.3: Zentralitätsmasse berechnen",
    "text": "Übung 2.3: Zentralitätsmasse berechnen\nNun kann mit der eigentlichen Netzwerkanalyse begonnen werden. Wir rechnen für unser bereinigtes Strassennetz verschiedene Zentralitätsmasse.\n\nv.net.centrality starten\nParameter\n\nInput vector line layer : Bereinigter Output aus letzter Übung\nv.out.ogr output type : auto\nNetwork Centrality: Save to File…\n\nMit “run” ausführen\nSpeichern Sie die resultierende Datei in ihrem Ordner ab (“waedenswil_centrality.gpkg”)",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.4-zentralitätsmasse-visualisieren",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.4-zentralitätsmasse-visualisieren",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.4: Zentralitätsmasse Visualisieren",
    "text": "Übung 2.4: Zentralitätsmasse Visualisieren\nVisualisieren Sie die Ausprägung “Closeness” der berechneten Zentralitätswerte über die Symbologie (Layer Properties→Style→Graduated). Wählen Sie eine geeignete Methode und passen Sie den Stil an, bis er Ihnen gefällt. Spielen Sie dabei mit der Klassifikationsmethode (Mode: Equal interval, Quantile, Natural Breaks..) sowie der Color ramp rum. Achten Sie darauf, dass Sie immer auf “Classify” klicken müssen, um Änderungen anzuwenden.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.5-zentralitätsmasse-vergleichen",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#übung-2.5-zentralitätsmasse-vergleichen",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "Übung 2.5: Zentralitätsmasse vergleichen",
    "text": "Übung 2.5: Zentralitätsmasse vergleichen\nInstallieren Sie das Plugin “QuickMapServices” um eine OSM Hintergrundkarte einzubinden (e.g. Web → QuickMapServices → OSM → OSM Standard). Um direkt in QGIS die Zentralitätsmasse zu vergleichen, duplizieren sie den entsprechenden Layer noch zweimal (rechtsklick &gt; Duplicate) – so können Sie jede der Zentralitäten separat symbolisieren und vergleichen. Sie können auch für jedes der Zentralitätsmasse eine Karte exportieren via Project &gt; Import / Export Export Map to Image.\nVergleichen Sie die drei Zentralitätsmasse und setzen Sie sie in den Kontext der Theorie.",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#footnotes",
    "href": "D_Netzwerkanalyse_1/4_GRASS_GIS.html#footnotes",
    "title": "Aufgabe 2: Zentralitätsmasse berechnen",
    "section": "",
    "text": "Da QGIS wie bereits erwähnt von verschiedenen Personen und Gruppen entwickelt wird, gibt es auch Doppelspurigkeiten, die man so in einer kommerziellen Software wie ArcGIS weniger vorfindet. In dieser Hinsicht ist QGIS sehr ähnlich wie die Programmiersprachen R und Python.↩︎",
    "crumbs": [
      "Netzwerkanalyse I",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>Aufgabe 2: Zentralitätsmasse berechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Shortest_Path.html",
    "href": "D_Netzwerkanalyse_2/1_Shortest_Path.html",
    "title": "Aufgabe 3: Kürzeste Pfade (shortest path)",
    "section": "",
    "text": "Übung 3.1: Projekt vorbereiten\nStarten Sie QGIS und beginnen Sie ein neues Projekt mit dem CRS CH1903+ LV95 (EPSG 2056). Lesen Sie den Datensatz “osm_highway_prepared.gpkg” von letzter Woche ein. Wer den Datensatz von letzter Woche nicht auffinden kann, findet die Datei in Tabelle 55.1. Prüfen Sie, ob das CRS richtig erkannt wurde (Rechtsklick → Properties → Reiter Source → Set source coordinate reference system → Hier sollte EPSG 2056 stehen).\nWir brauchen zudem eine Hintergrundkarte zur Orientierung. Blenden Sie mit dem Plugin “QuickMapServices” die Openstreetmap Hintergrundkarte ein (Web → QuickMapServices → OSM → OSM Standard) ein. Falls Sie diese Option nicht finden, müssen Sie das enstprechede Plugin “QuickMapServices” installieren (siehe dazu Übung 4: Plugin installieren).\nDie Hintergrundkarte dient lediglich zur Orientierung, die Farben lenken uns jedoch vom Netzwerk ab. Wechseln Sie deshalb den Darstellungsmodus auf Graustufen mittels Rechtklick auf den Layer “OSM Standard” → Properties → Symbology → Grayscale Auswahl: “By lightness”.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>Aufgabe 3: Kürzeste Pfade (shortest path)</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Shortest_Path.html#sec-ex-shortestpath",
    "href": "D_Netzwerkanalyse_2/1_Shortest_Path.html#sec-ex-shortestpath",
    "title": "Aufgabe 3: Kürzeste Pfade (shortest path)",
    "section": "Übung 3.2: Kürzester Pfad berechnen",
    "text": "Übung 3.2: Kürzester Pfad berechnen\nNun können wir mittels “Shortest path (point to point)” (aus dem Toolset “Network analyses” den kürzesten Pfad zwischen zwei Knotenpunkten auf dem Netzwerk berechnen. Starten sie das Tool und wählen sie als Input Datensatz (“Vector Layer representing network”) osm_highway_prepared aus.\nDie Start- und Endpunkte können Sie interaktiv in der Karte setzen. Klicken Sie dazu auf das Symbol neben den entsprechenden Feldern (“Start point” bzw. “End point”) und klicken Sie in der Karte an die gewünschten Stellen. Führen Sie das Tool mit “Run” aus.\nVisualisieren Sie nun den neuen Layer “Shortest Path” so, dass er gut ersichtlich ist.\nHinweis: Auch GRASS GIS bietet einen Shortest Path Algorithmus an (v.net.path). Dieser ist darauf ausgelegt, viele kürzeste Pfade für viele Punkte zu berechnen, und nimmt als Input deshalb ein Textfile.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>Aufgabe 3: Kürzeste Pfade (shortest path)</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Shortest_Path.html#übung-3.3-mit-ors-routing-vergleichen",
    "href": "D_Netzwerkanalyse_2/1_Shortest_Path.html#übung-3.3-mit-ors-routing-vergleichen",
    "title": "Aufgabe 3: Kürzeste Pfade (shortest path)",
    "section": "Übung 3.3: Mit ORS Routing vergleichen",
    "text": "Übung 3.3: Mit ORS Routing vergleichen\nNun wollen wir diese Route mit derjenigen eines professionellen Routing Services vergleichen. https://maps.openrouteservice.org/ bietet ihre Dienste bis zu einem bestimmten Kontingent kostenlos an. Installieren Sie das Plug-In “ORS Tools” um diesen Service zu nutzen.\nFühren Sie das Tool nach der Installation via Web → ORS Tools → ORS Tools aus. Fügen Sie bei Settings ( ) → “API Key” den Schlüssel ein. Den Schlüssel findet ihr auf Moodle.\nÜber diesen Schlüssel wird sichergestellt, dass die Anzahl Abfragen pro Minute und Tag ein gewisses Maximum nicht überschreiten.\nGeben Sie Start und Endpunkt mit der Maus ein (klick auf das +) und orientieren sich dabei an dem Layer “Shortest_Path” (aus der vorherigen Übung). Allenfalls verschwindet das “ORS Tools” Fenster, sie können es aber über die Toolbar (siehe Abbildung 58.2) wieder aufrufen.\n\n\n\n\n\n\nAbbildung 58.2: ORS Routing\n\n\n\nMit einem Klick auf dieses Symbol erscheint das ORS Routing wieder.\nFühren Sie die Berechnung mit “Apply” aus und vergleichen Sie den resultierenden Pfad mit dem “Shortest Path” aus Übung 3.2: Kürzester Pfad berechnen. Führen Sie die gleiche Berechnung mit verschiedenen Einstellungen durch (kürzeste Route, schnellste Route, Fahrrad, zu Fuss). Vergleichen Sie die unterschiedlichen Routen mit unserer eigenen Berechnung und visualisieren Sie diese in einer Karte.\nBerechnen Sie nun mit OSM Routing den kürzesten Pfad zwischen dem Campus Grüental und dem Campus Reidbach, auch wieder je einmal mit der Verkehrsmodalität Auto, Fahrrad und Fussweg. Vergleichen Sie die drei Resultate.\n\n\n\n\n\n\nHinweis\n\n\n\nDas ORS Tools Plugin bietet keine Möglichkeit, die blauen Linien zu entfernen, die die ausgewählten Punkte auf der Karte verbinden (https://github.com/GIScience/orstools-qgis-plugin/issues/120). Diese Linien sind temporär, d.h. sie werden beim nächsten Öffnen des QGIS-Projekts wieder verschwinden.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>Aufgabe 3: Kürzeste Pfade (shortest path)</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "",
    "text": "Übung 4.1: Traveling Salesperson für Campus Standorte\nAngenommen Sie sind ein Kurrierdienst und müssen ausgehend von der Halbinsel Au aus alle Campus Standorte der ZHAW Wädenswil besuchen. Sie wollen die Route so optimieren, dass Sie die kürzeste Route Sie das gleichnamige Tool (v.net.salesmen) um genau dieses Problem zu lösen.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#übung-4.1-traveling-salesperson-für-campus-standorte",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#übung-4.1-traveling-salesperson-für-campus-standorte",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "",
    "text": "Erstellen Sie dazu als erstes eine neue Geopackage Datei (Layer→Create Layer→New Geopackage Layer) um die Campus Standorte zu erfassen.\n\nMit dem Feld “Database” ist der Pfad inkl. Dateiname der zu erstellenden Datei gemeint. Wählen Sie hier an einem geeigneten Speicherort den Dateiname “campus_waedenswil.gpkg”\n“Table name” ist der Name des Layers innerhalb der Geopackage Datei (im Gegensatz zu einem Shapefile können innerhalb eines Geopackage mehrere Layers von unterschiedlichen Datentypen koexistieren)\n\nWählen Sie bei “Geometry Type” “Point” aus und bei CRS EPSG 2056\nFügen Sie eine Spalte in der Attributtabelle hinzu indem Sie unter “New field”→“Name” den Wert “Standort_name” eingeben (Hier wollen wir “Grüental”, “Reidbach”.. erfassen) Wählen Sie einen geeigneten Datentyp sowie eine geeignete Maximallänge\nBestätigen Sie mittels “Add field to list”\nErstellen Sie das Geopackage mit “OK”\n\n\nStarten Sie mit einem Klick auf den Stift die Editiersession und fügen Sie mit dem “Add Feature” Werkzeug Features hinzu. Digitalisieren Sie so die Campus Standorte (Grüental, Reidbach, Seifenstreuli, Schloss) sowie den Ausgangspunkt (Halbinsel Au). Wählen Sie pro Standort einen für Sie geeigneten Punkt, möglichst auf dem OSM Strassennetz.\nSpeichern Sie die erfassten Punkte mit einem Klick auf “Save Edits”.\nStarten Sie nun das Tool v.net.salesman (über die Processing Toolbox) und wählen Sie als Input Layer den OSM Strassendatensatz und als “Center Point Layer” die eben digitalisierten Standorte.\nv.out.ogr output type: auto.\nBetrachten Sie die Outputdaten.",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-shops",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-shops",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "Übung 4.2: Traveling Salesperson für mehr Standorte",
    "text": "Übung 4.2: Traveling Salesperson für mehr Standorte\nDer Traveling-Salesperson-Pfad für fünf Punkte zu berechnen ist relativ trivial und könnte “von Hand” gerechnet werden. Anspruchsvoller wird es jedoch, wenn sich die Anzahl der Standorte erhöht. Nehmen wir an, Sie wollen eine Einkaufstour durch alle Läden in Wädenswil machen: Nutzen Sie die OSM Daten und v.net.salesman um eine sinnvolle Route zu berechnen.\n\nOSM Daten der Läden laden: Vector→QuickOSM→QuickOSM\nkey “shop”→Run query sowie Gebiet wählen (siehe dazu Übung 5: OpenStreetMap Vektordaten herunterladen)\nPunkt-Daten der Shops in CRS 2056 konvertieren (reproject, siehe Übung 1.1: Daten Transformieren). Clippen ist fakultativ (nicht erreichbare Knotenpunkte werden schlicht ignoriert)\nv.net.salesman mit diesen Standorten durchführen",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-buildings",
    "href": "D_Netzwerkanalyse_2/2_Travelling_Salesman.html#sec-ex-network-traveling-buildings",
    "title": "Aufgabe 4: Traveling Salesperson",
    "section": "Übung 4.3 (fakultativ, Guezli-Challenge): Traveling Salesperson für noch mehr Standorte",
    "text": "Übung 4.3 (fakultativ, Guezli-Challenge): Traveling Salesperson für noch mehr Standorte\nUm unsere Rechenmaschine richtig herauszufordern, können wir den Traveling Salesperson Pfad für alle Gebäudestandorte in Wädenswil berechnen. Nutzen Sie hierzu QuickOSM um “building” herunterzuladen. Reprojizieren Sie die Polygon-Daten in CRS 2056 und konvertieren Sie diese in Punkte, indem Sie das Centroid pro Polygon berechnen (Tool “Polygon Centroids”). Berechnen Sie anschliessend den Traveling Salesperson. Ermitteln Sie die Gesamtdistanz dieses Pfades, indem Sie mit dem Field Calculator die Länge pro Segment rechnen (length) und anschliessend die Summe aller Längen ermitteln (View→Statistical Summary). Wer zuerst die korrekte Distanz in den Chat schreibt, wird mit Ruhm und Ehre belohnt und zur/zum “AGI Studentin/Student des Tages” erkürt!\n\nFür viele klassische Fragestellungen (z.B. shortest path, traveling salesmen) bietet QGIS / GRASS einen passenden Algorithmus\nDie Tools werden teilweise sehr unterschiedlich angesprochen (shortest path braucht Textfiles, Traveling salesmen braucht Punkt-Features) und liefern unterschiedliche Outputs",
    "crumbs": [
      "Netzwerkanalyse II",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>Aufgabe 4: Traveling Salesperson</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "",
    "text": "Übung 5.1: Linien in Segmente unterteilen\nDa sie gerne hopfenhaltige Getränke in Dosen und Glasflaschen konsumieren, ist Ihnen bei der Standortwahl die Distanz zur nächsten Entsorgungsstelle sehr wichtig. Je näher die Wohnung an einer solchen Entsorgungsstelle wäre, desto weniger weit müssten Sie das Recycling Material mit Ihrem Wägelchen durch die Gegend fahren. Wir berechnen deshalb die Isochronen Linien zu den Entsorgungsstellen auf dem Strassennetz.\nVisualisieren Sie das Resultat in dem Sie die Symbolisierung des neu entstanden Linienlayers entsprechend anpassen (Spalte “cat” einfärben). Sind das nun bereits Isolinien?",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.1-linien-in-segmente-unterteilen",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.1-linien-in-segmente-unterteilen",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "",
    "text": "Starten Sie das Tool v.net.iso um die Isochronen-Linien auf dem Strassennetz zu berechnen.\nWählen Sie als Input Vector Line das Strassennetz\nAls “Center Points layer” wählen Sie die Entsorgungsstellen\nIm Feld “Cost for Isolines” können Sie die Schwellenwerte festlegen, bei denen die Isochronenlinien gezogen werden sollen. Die Einheit entspricht den “Map units” (Meter) und werden kommagetrennt eingegeben. Um den vollen Effekt des Tools auszukosten verwenden wir eine grosse Anzahl von Schwellenwerten (z.B. alle 200m von 0 bis 3 km):\n200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000\nWählen Sie wie immer den v.out.ogr output type: “auto”\nFühren Sie das Werkzeug anschliessend mit “Run” aus.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.2-linien-in-punkte-umwandeln",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.2-linien-in-punkte-umwandeln",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "Übung 5.2: Linien in Punkte Umwandeln",
    "text": "Übung 5.2: Linien in Punkte Umwandeln\nUm aus den Linien eine Oberfläche zu erhalten müssen wir die Kategorien aus dem Output von v.net.iso interpolieren. Dies funktioniert besser mit Punkten als Linien. In einem ersten Schritt müssen wir also den Output aus v.net.iso in Punkte umwandeln. Verwenden Sie hierfür das Werkzeug “Convert Lines to Points” (SAGA). Belassen sie das Häkchen bei “Insert additional Points” und setzten Sie die Distanz (“Insertion Distance”) auf 100 Meter. Führen Sie das Werkzeug mit “run” aus.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#sec-ex-interpolate-points",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#sec-ex-interpolate-points",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "Übung 5.3: Punkte interpolieren",
    "text": "Übung 5.3: Punkte interpolieren\nNun haben wir Punkte, die mit einer Interpolation in eine Oberfläche überführt werden können. Verwenden Sie dazu das Tool “Inverse distance weighted” (SAGA). Überlegen sie, was Sie interpolieren möchten und legen sie das entsprechende Feld in der Option “Attribute” fest. Zusätzlich können Sie folgende Parameter wählen:\n\nCellsize: 25\nSearch Range: [0] local\nMaximum Search Distance: 500\nWeighting Function: [1] Inverse Distance to a power\n\nClippen sie den Output anschliessen auf die Gemeindegrenze mit dem Werkzeug “Clip Raster by mask layer”. Speichern Sie den geclippten Layer mit dem Namen abfall_raster.tif in ihrem Projektordner.\nUm den Datensatz zu visualisieren können sie im Reiter “Symbology” der Layereigenschaften den Rendertype “Singleband Pseudocolor” auswählen. Wählen Sie einen geeigneten Farbverlauf und klicken sie auf “classify” und anschliessend auf “ok”.\n\n\n\n\n\n\nHinweis\n\n\n\nGruppieren Sie alle Layers im Zusammenhang mit den Entsorungsstellen mittels Selektion &gt; Rechtsklick &gt; Group selected um den Überblick zu behalten.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.4-isolinien-berechnen",
    "href": "D_Netzwerkanalyse_3/2_Entsorgungsstelle.html#übung-5.4-isolinien-berechnen",
    "title": "Aufgabe 5: Entsorgungsstelle",
    "section": "Übung 5.4: Isolinien berechnen",
    "text": "Übung 5.4: Isolinien berechnen\nDieser nächste Schritt dient nur zu Illustrationszwecken: Wir möchten aus der generierten Oberfläche Isolinien berechnen. Nutzen sie hierfür das Tool Raster→Extraktion→Contour…. Spielen sie mit verschiedenen Intervallen (Interval between..) rum bis Ihnen eine Darstellung gefällt. Überlagern Sie den interpolierten Raster, die Isolinien sowie die Entsorgungsstellen und freuen sie sich ab diesem Ergebnis!\n\n\n\n\n\n\nAbbildung 60.1: Isolinien berechnen",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>Aufgabe 5: Entsorgungsstelle</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "",
    "text": "Übung 6.1: Datensatz Clippen und betrachten\nAls weiteres Kriterium wollen Sie eine gute Erschliessung mit dem öffentlichen Verkehr. Dabei geht um den ÖV-Anschluss unter Berücksichtigung des elektronischen Fahrplans. Dafür hat das ARE einen Datensatz herausgeben, den Sie hier auffinden können: https://s.geo.admin.ch/7e80a8bd28\nLaden Sie den Datensatz “ÖV-Güteklassen ARE” herunter und importieren Sie ihn in Ihr Projekt.\nClippen Sie den Datensatz mit der Gemeindegrenze von Wädenswil. Symbolisieren Sie den Datensatz anhand des Feldes “KLASSE” und betrachten Sie anschliessend die Attributtabelle.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.1-datensatz-clippen-und-betrachten",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.1-datensatz-clippen-und-betrachten",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "",
    "text": "Tipp zum Herunterladen!\n\n\n\n\n\n\nÖV-Güteklassen",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.2-buchstaben-in-nummerische-kategorien-überführen",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#übung-6.2-buchstaben-in-nummerische-kategorien-überführen",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "Übung 6.2: Buchstaben in nummerische Kategorien überführen",
    "text": "Übung 6.2: Buchstaben in nummerische Kategorien überführen\nDa es sich bei den Klassen um Buchstaben handelt, können wir sie für unsere Analyse in dieser Form nicht verwenden. Wir müssen die Buchstaben noch in Zahlen konvertieren (A zu 1, B zu 2 usw.). Verwenden Sie hierfür den Field Calculator der Attributtabelle. Versuchen Sie die Konversion Buchstaben in Zahlen mit einer if() Funktion um zu setzen. Falls sie nicht weiter kommen finden Sie weiter unten einen Lösungsvorschlag.\n\n\n\n\n\n\nHinweise\n\n\n\n\nBevor Sie die Funktion anwenden können müssen Sie noch den “Output field name” definieren.\nSobald sie den Field Calculator ausführen wechselt QGIS in den Editiermodus. Änderungen werden nur gespeichert, wenn die Editiersession beendet wird.\nWenn sie im mittleren Bereich auf unter “Fields and Values” auf ein Feld klicken haben sie rechts die Möglichkeit, die Werte dieser Felder zu betrachten und ebenfalls mit Doppelklick in ihre Formel zu übernehmen.\n\n\n\n\n\n\n\nAbbildung 61.1: Field Calculator\n\n\n\nZur Erinnerung: Der Field Calculator besteht aus drei Bereichen: Im mittleren Bereich können Sie Funktionen sowie Felder der Attributtabelle suchen und mittels einfachem anklicken Hilfestellung erhalten (rechts). Mittels Doppelklick wird die Funktion oder die Feldbezeichnung in den “Function Editor” (links) übertragen. Hier wird die eigentliche Funktion zusammengebaut die ausgeführt werden soll.\n\n\n\n\n\n\n\n\nHinweis\n\n\n\n\n\nif(\"KLASSE\" = 'A' ,1,\n  if(\"KLASSE\" = 'B' ,2,\n    if(\"KLASSE\" = 'C' ,3,\n      if(\"KLASSE\" = 'D' ,4,0)\n    )\n  )\n)",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#sec-ex-polygon-to-raster",
    "href": "D_Netzwerkanalyse_3/3_OEV-Gueteklassen.html#sec-ex-polygon-to-raster",
    "title": "Aufgabe 6: ÖV-Güteklassen",
    "section": "Übung 6.3: Polygon in Raster konvertieren",
    "text": "Übung 6.3: Polygon in Raster konvertieren\nKonvertieren Sie das Polygon nun in ein Raster mit Werkzeug “Rasterize (Vector To Raster)”. Führen Sie das Tool mit den folgenden Einstellungen aus:\n\nField to use for a burn-in value: KLASSE (numerisch)\nOutput raster size units: Georeferenced Units\nWidth/Horizontal resolution: 25\nHeight/Vertical resolution: 25\n\n\nBeachten Sie, dass nun alle Bereiche in Wädenswil, die keiner Kategorie zugewiesen waren nun keinen Wert erhalten haben. Für unsere Abstufung bräuchten wir hier aber den Wert “5” (1 – 4 haben wir bereits zugewiesen). Benutzen Sie das Tool “r.null” um alle Null Werte in 5 zu konvertieren (“the value to replace the null value by”).\n\nSpeichern Sie den Output mit dem Namen oev_raster.tif in ihrem Projektordner und gruppieren Sie alle Layers im Zusammenhang mit den ÖV-Güteklassen.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>Aufgabe 6: ÖV-Güteklassen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html",
    "href": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html",
    "title": "Aufgabe 7: Zentralitätsmasse",
    "section": "",
    "text": "Übung 7.1: Zentralitätsmasse betrachten und auswählen\nDa Sie aber auf keinen Fall an einer Durchfahrtsstrasse wohnen möchten, müssen Sie dies in der Wohnungssuche ebenfalls berücksichtigen. Laden Sie deshalb den Datensatz “waedenswil_centrality.gpkg” aus Übung 2.3: Zentralitätsmasse berechnen. Falls Sie diesen nicht mehr haben, können Sie die Zentralitätsmasse neu berechnen (v.net sowie v.net.centrality) oder Sie verwenden den Datensatz “waedenswil_centrality.gpkg” in Tabelle 55.1. Prüfen Sie anhand der Symbolisierung, welches Mass “Durchfahrtsstrassen” am besten abbildet.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>Aufgabe 7: Zentralitätsmasse</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html#übung-7.2-zentralitätsmasse-in-fläche-überführen",
    "href": "D_Netzwerkanalyse_3/4_Zentralitaetsmasse.html#übung-7.2-zentralitätsmasse-in-fläche-überführen",
    "title": "Aufgabe 7: Zentralitätsmasse",
    "section": "Übung 7.2: Zentralitätsmasse in Fläche überführen",
    "text": "Übung 7.2: Zentralitätsmasse in Fläche überführen\nDas gewählte Zentralitätsmass können wir nun ebenfalls mit dem Tool “Inverse distance weighted” (SAGA) in eine Oberfläche überführen. Führen sie das Tool analog Übung 5.3: Punkte interpolieren, mit dem gewählten Zenralitätsmass aus. Sie können die Parameter des Tools nach eigenem Gutdünken auch anpassen (wir empfehlen auf jedenfall die gleiche Output Cellsize von 25m zu verwenden um im Anschluss die Flächen miteinander verrechnen zu können).\nClippen sie anschliessend den Output mit dem Werkezeug “Clip raster by Mask Layer” (GDAL). Speichern Sie den Output unter centrality_raster.tif in ihrem Projektordner und gruppieren Sie alle Layers im Zusammenhang mit den Zentralitätsmassen.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>Aufgabe 7: Zentralitätsmasse</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html",
    "href": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html",
    "title": "Aufgabe 8: Flächen verrechnen",
    "section": "",
    "text": "Übung 8.1: Rasterdatensätze skalieren\nÖffnen Sie anschliessend das Tool Rescale Raster und skalieren Sie jeden der drei Rasterdatensätze jeweils so, dass Sie Werte von 0 bis 100 erhalten. Geben Sie dabei bei “New minimum value” 0 und bei “New maximum value” 100 ein.\nSpeichern Sie die Ergebnisse unter folgenden Namen ab: oev_scaled.tif, abfall_scaled.tif, centrality_scaled.tif.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>Aufgabe 8: Flächen verrechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html#übung-8.2-zusammenführen-mit-raster-calculator",
    "href": "D_Netzwerkanalyse_3/5_Flaechen_verrechnen.html#übung-8.2-zusammenführen-mit-raster-calculator",
    "title": "Aufgabe 8: Flächen verrechnen",
    "section": "Übung 8.2: Zusammenführen mit Raster Calculator",
    "text": "Übung 8.2: Zusammenführen mit Raster Calculator\nNutzen Sie nun den Raster Calculator (Raster→Raster Calculator) um die drei Rasterdatensätze miteinander zu verrechnen.\n\nDie einfachste Variante ist die Berechnung des Mittelwertes der drei Rasterdatensätze. Dafür muss man alle drei summieren und durch drei dividieren:\n\\(raster_{neu}\\) = \\(\\frac{oev_{scaled}+abfall_{scaled}+centrality_{scaled}}{3}\\)\nOptional kann man auch die drei Rasterdatensätze unterschiedlich gewichten, wie beispielweise nachstehende Berechnung zeigt. Beachten Sie, dass in diesem Fall nicht mehr durch 3, sondern durch die Summe der Gewichte dividiert wird. Visualisieren und interpretieren Sie anschliessend das Resultat.\n\\(raster_{neu}\\) = \\(\\frac{oev_{scaled}\\times1+abfall_{scaled}\\times10+centrality_{scaled}\\times5}{16}\\)\nZum Abschluss clippen Sie den Output mit dem Werkezeug Clip raster by Mask Layer (GDAL) auf die Gemeindegrenze von Wädenswil. Speichern Sie den Output unter final_result.tif in ihrem Projektordner ab. Passen Sie die Symbolisierung entsprechend an.",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>Aufgabe 8: Flächen verrechnen</span>"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/6_Leistungsnachweis.html",
    "href": "D_Netzwerkanalyse_3/6_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Um den Leistungsnachweis für Netzwerkanalyse zu erbringen, müsst ihr die Übungen aus Aufgabe 5: Entsorgungsstelle, Aufgabe 6: ÖV-Güteklassen, Aufgabe 7: Zentralitätsmasse und Aufgabe 8: Flächen verrechnen, ausführen und dokumentieren (maximal zwei A4-Seiten).\n\nAbgeben müsst Ihr ein PDF Dokument mit Eurem Lösungsansatz der Multikriterien-Analyse (Aufgabe 8: Flächen verrechnen) inkl. einer kurzen Beschreibung (ca. 400 - 600 Wörter), wie Ihr hier vorgegangen seid.\nBeschreibt vor allem auch, was für ein Zentralitätsmass Ihr für die Teilfrage “Durchfahrtsstrasse” gewählt habt. Begründet Eure Wahl durch einen konzeptionellen Vergleich mit den beiden anderen Zentralitätsmassen.\nFür den Leistungsnachweis erwarten wir, dass Ihr die Kriterien (ÖV, Abfall, Durchfahrtsstrasse) unterschiedlich gewichtet und die Wahl der Gewichte erklärt.\nAchtet darauf, dass Eure Karte die nötigen Elemente enthält (Datenherkunft, Datum, Legende usw.).\nAbgabe erfolgt via Moodle",
    "crumbs": [
      "Netzwerkanalyse III",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html",
    "title": "Übung Web Map",
    "section": "",
    "text": "Übung 1: Erste Schritte mit ArcGIS Online (Online Tutorial)\nFühre das Online Tutorial «Erste Schritte mit ArcGIS Online» durch. Damit erlernst Du die grundlegenden Funktionalitäten der Kartenerstellung in ArcGIS Online.\nLink zum Tutorial",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-2-arcgis-online-inhaltsseite-organisieren",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-2-arcgis-online-inhaltsseite-organisieren",
    "title": "Übung Web Map",
    "section": "Übung 2: ArcGIS Online: Inhaltsseite organisieren",
    "text": "Übung 2: ArcGIS Online: Inhaltsseite organisieren\nIn ArcGIS Online kann die eigene Inhaltsseite personalisiert werden. Es können Ordner erstellt werden in denen Inhalte verwaltet und organisiert werden können.\n\nMelde Dich mit Deinen persönlichen Nutzerdaten auf dem ArcGIS Online Organisationskonto der ZHAW an: ZHAW ArcGIS Maps\nWechsle von der Startseite in das Register Inhalt. Im Ordner «Alle eigenen Inhalte» sollten die beiden Inhalte «At-Risk Population in Houston» (Instant App) und «Houston Evacuation Map» (Web Map) welche Du im Rahmen der ersten Übung (Online Tutorial) erstellt hast, aufgeführt sein.\n\n\n\n\n\nErstelle einen neuen Ordner mit dem Namen «Modul AGI» in dem Du alle Inhalte ablegen kannst, welche Du im Rahmen dieses Moduls auf ArcGIS Online hochlädst. Klicke hierfür auf «Neu», und gib den Namen für den neu zu erstellenden Ordner ein.\n\n\n\n\n\nVerschiebe nun die beiden Inhalte «At-Risk Population in Houston» (Web Mapping Application) und «Houston Evacuation Map» (Web Map) in den soeben neu erstellten Ordner. Gehe hierfür zurück auf den Ordner «Alle meine Inhalte». Selektiere die beiden Inhalte und klicke auf die Option «Verschieben».\n\nWähle im sich öffnenden Fenster «Element verschieben» den Ordner «Modul AGI» und verschiebe diese Inhalte in den neuen Ordner\n\n\n\n\n\nLege alle Deine Inhalte, welche Du im Rahmen dieses Moduls auf ArcGIS Online hochlädst im Ordner «Modul AGI» ab.\nDu kannst jederzeit neue Ordner erstellen und so Deine Inhalte auf ArcGIS Online organisieren.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-3-arcgis-online-freigabeeigenschaften-bei-bestehenden-inhalten-ändern",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-3-arcgis-online-freigabeeigenschaften-bei-bestehenden-inhalten-ändern",
    "title": "Übung Web Map",
    "section": "Übung 3: ArcGIS Online: Freigabeeigenschaften bei bestehenden Inhalten ändern",
    "text": "Übung 3: ArcGIS Online: Freigabeeigenschaften bei bestehenden Inhalten ändern\nBei der Durchführung des Esri Online Tutorials «Erste Schritte mit ArcGIS Online» hast Du sowohl die Web Map als auch die Web Mapping Application für «Alle (öffentlich)» freigegeben. Ändere nun die Freigabe dieser beiden Inhalte, damit diese nur noch von Dir aufgerufen werden können.\n\nZeige die Inhalte im Ordner «Modul AGI».\nKlicke bei der Web Mapping Application «At-Risk Population in Houston» auf das Globus-Symbol.\n\nÄndere im Freigabefenster nun die Freigabeeigenschaften für diesen Inhalt. Diese Anwendung soll nun nicht mehr für die Öffentlichkeit freigegeben sein, sondern nur noch für Dich (Du kannst die Anwendung öffnen, andere haben jedoch keinen Zugriff mehr darauf). Wähle hierfür die Option «Eigentümer».\n\n\n\n\n\nFühre dasselbe für die Web Map «Houston Evacuation Map» durch.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-4-arcgis-pro-karte-einrichten",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-4-arcgis-pro-karte-einrichten",
    "title": "Übung Web Map",
    "section": "Übung 4: ArcGIS Pro: Karte einrichten",
    "text": "Übung 4: ArcGIS Pro: Karte einrichten\nLade die Daten von Moodle herunter (ZIP-File: Daten Einführungsübung ArcGIS Online), extrahiere die Daten unter einem sinnvollen Ordnerpfad und erstelle ein neues ArcGIS Pro Projekt mit dem Namen E_ArcGIS_Online im Ordner, in dem Du die Übungsdaten extrahiert hast.\n\n\n\n\n\n\nTipp\n\n\n\nÜbrigens: Du kannst alle Deine Karten (Maps) welche Du im Laufe dieses Unterrichtsblocks erstellst in diesem Projekt speichern\n\n\n\nStarte ArcGIS Pro und erstelle ein neues ArcGIS Pro Projekt mit dem Namen «E_ArcGIS_Online».\nMelde Dich mit Deinen persönlichen Benutzerdaten (kürzel_student / PW) in ArcGIS Pro beim ArcGIS Online Portal der ZHAW an (sofern Du noch nicht angemeldet bist).\nBenenne die neue Map als «Einführung» (Contents Pane &gt; Kontextmenü Map &gt; Properties &gt; Map Properties &gt; General Tab &gt; bei Name Eingabe vornehmen &gt; mit OK bestätigen).\n\nGehe in das Catalog Window und überprüfe die Inhalte im Projektordner. Zusätzlich zur Projekt-GDB sollte die Geodatenbank «uebung_online_publikation.gdb» aufgeführt sein. Falls nicht, erstelle im Catalog Pane eine Verbindung zum Ordner her, in dem Du die heutigen Übungsdaten entpackt hast (Catalog Pane &gt; Project &gt; Folders &gt; Kontextmenü Add Folder Connection).\n\n\n\n\n\nDie Geodatenbank «uebung_online_publikation.gdb» enthält folgende Feature Classes:",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-5-arcgis-pro-koordinatensystem-anpassen",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-5-arcgis-pro-koordinatensystem-anpassen",
    "title": "Übung Web Map",
    "section": "Übung 5: ArcGIS Pro: Koordinatensystem anpassen",
    "text": "Übung 5: ArcGIS Pro: Koordinatensystem anpassen\nDamit die Daten später auf ArcGIS Online veröffentlicht werden können, muss den Daten das Koordinatensystem «WGS 1984 Web Mercator Auxiliary Sphere» zugewiesen werden. Momentan ist den fünf Layern noch das Schweizerische Koordinatensystem zugewiesen. Führe für jeden einzelnen Layer eine Koordinatentransformation durch.\n\n\n\n\n\n\nTipp\n\n\n\nUm Probleme bei der Veröffentlichung auf ArcGIS Online zu vermeiden empfiehlt es sich, immer mit dem Koordinatensystem «WGS 1984 Web Mercator Auxiliary Sphere» zu arbeiten.\n\n\n\nÖffne das Geoprocessing Window (Menü Analysis &gt; Tools)\n\nSuche nach «Project» und öffne das Tool «Project (Data Management Tools). Transformiere die fünf Layers vom Schweizerischen Koordinatensystem in das projizierte weltweite Koordinatensystem. Definiere hierfür die nötigen Werkzeug-Parameter. Speichere die Output Layers in der gleichen Geodatenbank (uebung_online_publikation.gdb), jeweils ohne «_lv95» (bsp. picknickplatz). Das Koordinatensystem WGS 1984 Web Mercator Auxiliary Sphere findest Du unter folgendem Pfad: Projected coordinate system &gt; World &gt; WGS 1984 Web Mercator (auxiliary sphere). Füge es doch zu Deinen Favoriten hinzu.\n\n\n\n\n\nNach Ausführung des Werkzeugs «Project» werden die Layers automatisch der Karte «Einfuehrung» hinzugefügt.\n\nWichtig: Entfernen Sie den Layer «veloweg» aus Ihrer Karte.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-6-arcgis-pro-vorbereitung-der-karte",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-6-arcgis-pro-vorbereitung-der-karte",
    "title": "Übung Web Map",
    "section": "Übung 6: ArcGIS Pro: Vorbereitung der Karte",
    "text": "Übung 6: ArcGIS Pro: Vorbereitung der Karte\nSymbolisiere die vier Layer in einer Art und Weise, dass sie gut voneinander unterschieden werden können. Weise dem Layer «stadtkreis» eine Einzelwert-Legende basierend auf dem Feld «kname» zu und versehe diesen Layer mit einer Transparenz. Ändere zudem die Basemap auf «Light Gray Canvas».\n\nAktiviere nun für den Layer «zeckenstiche» die Zeiteigenschaften:\n\nContents Window &gt; Kontextmenü Layer «zeckenstiche» &gt; Properties.\nWähle unter Time folgende Einstellungen und bestätige sie mit OK:\n\nLayer Time: Each feature has a single time field\nTime Field: date\n\n\n\nFür den Layer «zeckenstiche» hast Du die Zeiteigenschaften aktiviert und Du kannst nun im Menüband «Time» die Eigenschaften der Zeitanimation definieren und anpassen.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-7-arcgis-pro-veröffentlichen-publishing-einer-karte",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-7-arcgis-pro-veröffentlichen-publishing-einer-karte",
    "title": "Übung Web Map",
    "section": "Übung 7: ArcGIS Pro: Veröffentlichen (Publishing) einer Karte",
    "text": "Übung 7: ArcGIS Pro: Veröffentlichen (Publishing) einer Karte\nIm Folgenden wird diese Karte mitsamt all ihren Inhalten, Symbolisierung und Funktionalitäten als Web Map auf ArcGIS Online veröffentlicht (direkt via ArcGIS Pro). Vergewissere Dich, dass Du mit dem ZHAW ArcGIS Online Organisationskonto verbunden bist (Portal Connection) und speichere das ArcGIS Pro Projekt.\n\nWechsle in das Menüband «Share»\nWähle anschliessend «Web Map»\n\nGebe der Karte einen Namen (Zecken Stadt Zürich Vorname Name), schreibe eine kurze Zusammen-fassung und definiere Tags. Wähle folgende Einstellungen:\n\nSelect a Configuration: Copy all data Exploratory\nLocation Folder: Modul AGI (Die Inhalte werden in ArcGIS Online in diesem Ordner abgelegt)\nShare With: Groups (wähle «Modul Angewandte Geoinformatik HS 2021»; die Karte und die Feature Layers werden nur für diese Gruppe freigegeben).\n\n\n\n\n\n\nKlicke auf «Analyze» und löse bei Bedarf die angezeigten Probleme. Nutze zur Lösung der etwaigen Probleme die ArcGIS Webhelp. Sofern die Warnung «Layer does not have a feature template set» erscheint, kann diese vernachlässigt werden.\nDie Meldung «00374 Unique numeric IDs are not assigned» kann über das Kontextmenü gelöst werden. (Kontextmenü -&gt; «Auto-Assign IDs Sequentially»)\nVeröffentliche anschliessend die Web Map mit «Share». Dieser Vorgang kann einige Zeit in Anspruch nehmen.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-8-arcgis-pro-veröffentlichen-publishing-eines-layers",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-8-arcgis-pro-veröffentlichen-publishing-eines-layers",
    "title": "Übung Web Map",
    "section": "Übung 8: ArcGIS Pro: Veröffentlichen (Publishing) eines Layers",
    "text": "Übung 8: ArcGIS Pro: Veröffentlichen (Publishing) eines Layers\nIn der vorangehenden Übung 7 hast Du eine gesamte Karte als Web Map veröffentlicht. Manchmal müssen oder sollen jedoch nur einzelne (oder mehrere) Layers als Web Layers veröffentlicht werden ohne gleichzeitige Erstellung einer Web Map. Erstelle nun in Deinem ArcGIS Pro Projekt eine neue Karte und lade den Layer «veloweg» hinzu. Anschliessend kann dieser Layer als einzelner Feature Layer auf ArcGIS Online veröffentlicht werden.\n\nGehe wiederum ins Menü «Share» und wähle «Web Layer &gt; Publish Web Layer».\n\nGebe dem Layer den Namen «Velowege Vorname Name», schreibe eine kurze Zusammenfassung und definiere Tags. Wähle folgende Einstellungen:\n\nLayer Type: Feature\nLocation Folder: Modul AGI (Der Layer wird in ArcGIS Online in diesem Ordner abgelegt)\nShare With: Groups (wähle «Modul Angewandte Geoinformatik HS 2022»; der Feature Layer wird nur für diese Gruppe freigegeben).\n\n\n\n\n\n\nKlicke auf «Analyze» und löse angezeigte Probleme.\nDie Meldung «00374 Unique numeric IDs are not assigned» kann über das Kontextmenü gelöst werden. (Kontextmenü -&gt; «Auto-Assign IDs Sequentially»)\nVeröffentliche anschliessend den Web Layer «Velowege Vorname Name» mit «Share». Dieser Vorgang kann einige Zeit in Anspruch nehmen.\nSpeichere das ArcGIS Pro Projekt.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-9-arcgis-online-web-map-anpassen",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-9-arcgis-online-web-map-anpassen",
    "title": "Übung Web Map",
    "section": "Übung 9: ArcGIS Online: Web Map anpassen",
    "text": "Übung 9: ArcGIS Online: Web Map anpassen\nWechsle in einen Internet Browser und melde Dich beim ZHAW ArcGIS Online Organisationskonto an. Wechsle anschliessend in das Menü «Inhalt» und betrachte die Inhalte im Ordner «Modul AGI». Momentan sollten zwei Feature Layer inkl. Service Definition, zwei Web Maps und eine Web Mapping Application (Instant App) als Inhalte sichtbar sein.\n\nInhalte können auch gelöscht werden, beispielsweise benötigst Du die Web Mapping Application «At-Risk Population in Houston» und die Web Map «Houston Evacuation Map» nicht mehr. Selektiere die beiden Inhalte und durch Klicken auf «Löschen» kannst Du diese Inhalte unwiderruflich löschen. Merke Dir: Sofern Du nur die Web Map löschst, funktioniert die Web Mapping Application nicht mehr. Jede Web Mapping Application basiert immer auf einer Web Map!\n\nÖffne nun die Web Map «Zecken Stadt Zürich Vorname Name». Klicke auf «…» und wähle «In Map Viewer öffnen» (evtl. in neuem Browser-Fenster öffnen).\n\nDie Web Map enthält die vier Feature Layer «zeckenstiche», «picknickplatz», «vitaparcours» und «stadtkreis». Ändere nun die Namen der Layer (bsp. Zeckenstiche Zeit-animiert statt zeckenstiche):\n\nGehe auf «Inhalt».\nÖffne bei Layer «zeckenstiche» das Kontextmenü durch Klicken auf «…»\nWähle «Umbenennen» und ändere den Layernamen auf «Zeckenstiche Zeit-animiert»\n\n\n\n\n\nPasse die Namen der anderen Layers an (bsp. Grossschreibung)\n\nFüge nun das Veloweg-Netz der Stadt Zürich als zusätzlichen Feature Layer zur Karte.\n\nWähle «Hinzufügen» und dann «Durchsuchen von Layern» (beende bei Bedarf die Zeitanimation).\n\n\n\n\n\nSuche unter «Eigene Inhalte». Gib im Suchfeld «Veloweg» ein. Der Layer sollte dann angezeigt werden. Füge den Layer durch Klicken auf «+» der Karte hinzu. Der Layer wird der Karte hinzugefügt.\n\n\n\n\n\n\nVerändere die Layer-Reihenfolge. Verschiebe den Layer «Velowege» unterhalb von «Vita Parcours».\n\nGehe in den Reiter «Layer».\nVerschiebe mittels drag and drop den Layer «Velowege» an die gewünschte Position und ändere den Namen des Layers.\nAlternative: Klicke unter Inhalt beim Layer «Velowege» auf die drei vertikalen Punkte und verschiebe den Layer an den gewünschten Ort.\n\n\n\n\n\n\nÄndere das Symbol für den Layer «Velowege» (bsp. ein dezentes dunkelgrau).\n\nSelektiere den Layer «Velowege» in der Layer-Ansicht.\nÖffne das Menü «Styles» (vertikales Menü rechts).\n\n\n\n\n\nGehe auf «Style-Optionen»\nKlicke auf das Stift-Symbol und ändere die Linienfarbe und -breite.\n\n\n\n\n\nBestätige die Eingaben mit “Fertig” &gt; “Fertig”\n\nLade nun den Layer «Zeckenstiche Zeit-animiert» ein zweites Mal zur Webmap. Hierfür musst Du die Web-Feature-Layers «Zecken Stadt Zürich Vorname Name» nochmals zur Karte hinzufügen und anschliessend die Layers, welche nicht doppelt vorhanden sein sollen wieder entfernen. Ändere anschliessend den Style und deaktiviere die Zeitanimation.\n\nWähle «Hinzufügen». Füge den Web-Layer mit dem Namen «Zecken Stadt Zürich Vorname Name_WFL1» mittels «+» Button zur Karte hinzu.\n\nHebe zuerst mittels «Gruppierung aufheben) die Gruppierung auf (dieser Feature Layer enthält vier verschiedene Layers). Entferne anschliessend die Layers «Picknickplatz», «Vitaparcours» und «Stadtkreis» aus der Webmap, denn diese Layers sollen nicht doppelt in der Webmap enthalten sein. Führe dies für jeden Layer einzeln durch.\n\nÄndere anschliessend beim neu hinzugefügten Zeckenstich-Layer den Namen zu «Gemeldete Zeckenstiche».\nDeaktiviere nun die Option Zeitanimation im Layer «Gemeldete Zeckenstiche». Gehe in diesem Layer auf «Eigenschaften anzeigen» und deaktiviere die Zeiteigenschaften im entsprechenden Abschnitt.\n\nVerschiebe danach diesen Layer unterhalb des Layers «Zeckenstiche Zeit-animiert».\nVerändere beim Layer «Zeckenstiche Zeit-animiert» den Style, so dass sich die animierten Zeckenstiche deutlich von den gemeldeten Zeckenstichen unterscheiden lassen. Wähle beispielsweise ein gelbes Punktsymbol inklusive Blooming-Effekt. Symboleffekte können via Reiter «Effekte» definiert werden.\nEntferne beim Layer «Zeckenstiche Zeit-animiert» das Pop-up via «Pop-up konfigurieren». Somit wird verhindert, dass das Pop-up beim Anklicken eines Zeckenstich-Standortes zwei Mal aufgerufen wird.\n\n\n\n\n\nPop-ups können übrigens über das Menü «Pop-ups» benutzerdefiniert angepasst werden. Probiere diverse Optionen für andere Layer aus.\nDie Zeit-Animation kann im linken Bereich über das Menü «Karteneigenschaften» und dann «Optionen des Zeitschiebereglers» angepasst werden (Intervall, Geschwindigkeit etc.). Probiere auch hier unterschiedliche Optionen aus.\n\nErstelle nun noch zwei Bookmarks (Lesezeichen) für die Stadtkreise 7 und 10. Zoome hierfür in den Bereich des Stadtkreises 7. Gehe dann auf «Lesezeichen» &gt; «Lesezeichen hinzufügen», gib «Stadtkreis 7» ein und bestätige die Eingabe mit der Enter-Taste. Gehe gleich vor für den Stadtkreis 10. Zoome nachfolgend wieder auf das gesamte Stadtgebiet.\nDie Karte ist nun soweit vorbereitet, damit basierend auf dieser Web Map eine Web Mapping Applikation erstellt werden kann (folgende Übungen). Speichere die Karte via «Speichern und öffnen &gt; Speichern».\nErst nachdem die Layers einer Karte fertig symbolisiert sind, die Pop-ups konfiguriert und die Layer-Funktionalitäten etc. definiert sind kann eine Web Mapping Applikation erstellt werden. Die Web Mapping Applikation übernimmt die grundlegenden Einstellungen, welche in der Web Map definiert sind.\n\n\n\n\n\n\nTipp\n\n\n\nIn der Regel müssen sowohl die Web Map als auch die Web Mapping Applikation auf dieselbe Art und Weise freigegeben werden. Dies gilt natürlich auch für alle Web-Layers welche in einer Karte enthalten sind.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-10-arcgis-online-web-app-erstellen-via-instant-maps",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-10-arcgis-online-web-app-erstellen-via-instant-maps",
    "title": "Übung Web Map",
    "section": "Übung 10: ArcGIS Online: Web App erstellen via “Instant Maps”",
    "text": "Übung 10: ArcGIS Online: Web App erstellen via “Instant Maps”\nErstelle nun eine Web Mapping Applikation basierend auf der vorher konfigurierten Web Map. In dieser Übung arbeiten wir mit «Instant Maps». Hierfür muss die Karte zuerst im «Map Viewer» geöffnet werden. Anschliessend generierst Du die Web Mapping Applikation über die Option «Instant Apps» (analog Übung 1 – Online Tutorial).\n\nWähle die Option «Schieberegler» und gehe auf «Vorschau». Gehe Zurück und erstelle die App mit «Auswählen».\nBenenne die App als «Zecken App Zürich Vorname Name», lege sie im Ordner Modul AGI ab und wähle «App erstellen»\n\n\n\n\n\nGehe durch die 5 Schritte, aktiviere die Pop-Ups, die Lesezeichen und die Layer Liste. Veröffentliche anschliessend die Web App.\nErgänze die Web App nun noch mit einem zusätzlichen WMS-Layer. Gehe hierfür zuerst auf www.geolion.zh.ch und suche nach «Klimamodell». Gehe auf «Klimamodell ZH: Analysekarten (Raster)», öffne das Register «Datenbezug» und wähle den Link unter Datenbezug -&gt; «WMS».\nWechsle in ArcGIS Online auf «Inhalt» und füge den WMS-Klimamodell via « + Neues Element» hinzu. Wähle die Option «URL».\n\nKopiere nun die WMS-URL in geolion und füge sie in ArcGIS Online im entsprechenden Feld ein. Füge nach http ein s ein (https://wms.zh.ch…..) Wähle die Option WMS (OGC) und klicke auf «Weiter». Wähle in der Liste den WMS-Layer «Lufttemperatur Tag».\nDefiniere folgende Parameter:\n\nTitel = Lufttemperatur Tag\nOrdner = Modul AGI\nTags = Temperatur\nZusammenfassung = Lufttemperatur Tag auf 2m Höhe über Grund um 14 Uhr\n\n\nÖffne in ArcGIS Online die Web Map «Zecken Stadt Zürich Vorname Name». Gehe auf «Hinzufügen &gt; Layer durchsuchen» und füge den Layer «Lufttemperatur Tag» zur Web Map hinzu. Verändere die Layerhierarchie und platziere die Temperaturkarte zuunterst.\nSpeichere die Änderungen.\nÖffne nun die Web App. Der Layer «Lufttemperatur Tag» ist nun auch in der Web App enthalten und kann je nach Bedarf ein- und ausgeblendet werden (so wie alle anderen Layer auch).",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-11-arcgis-online-web-app-erstellen-via-experience-builder",
    "href": "E_WebGIS_1/2_Uebung_Web_Map.html#übung-11-arcgis-online-web-app-erstellen-via-experience-builder",
    "title": "Übung Web Map",
    "section": "Übung 11: ArcGIS Online: Web App erstellen via “Experience Builder”",
    "text": "Übung 11: ArcGIS Online: Web App erstellen via “Experience Builder”\nNun wirst Du eine zweite Web App erstellen, dieses Mal mit Unterstützung des Experience Builders. Der Experience Builder erlaubt eine viel flexiblere Gestaltung der Web App, insbesondere können verschiedenste Widgets in die Applikation integriert werden.\n\nÖffne wiederum die Web Map «Zecken Stadt Zürich Vorname Name» und wähle im Menü links die Option «App erstellen &gt; Experience Builder»\nWähle die Vorlage «Foldable». Du kannst eine Vorschau betrachten und dann via «Erstellen» in die Design-Oberfläche wechseln.\nNun kannst Du die Web App nach Belieben konfigurieren, mit Widgets ergänzen und Funktionalitäten einbinden.\nKlicke nach Abschluss der Konfiguration auf «Speichern unter» und weise einen sinnvollen Namen zu. Veröffentliche anschliessend die Anwendung.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>Übung Web Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/3_Uebung_Story_Map.html",
    "href": "E_WebGIS_1/3_Uebung_Story_Map.html",
    "title": "Übung Story Map",
    "section": "",
    "text": "Übung 1: Story Map im ZHAW ArcGIS Online Portal erstellen\nDer einfachste Weg eine Story Map zu erstellen, geht am schnellsten via ZHAW ArcGIS Online Oberfläche im Menü «Inhalt». Am besten erstellst Du vorgängig einen eigenen Ordner, in dem alle Inhalte der Story Map abgelegt sind.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>Übung Story Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/3_Uebung_Story_Map.html#übung-1-story-map-im-zhaw-arcgis-online-portal-erstellen",
    "href": "E_WebGIS_1/3_Uebung_Story_Map.html#übung-1-story-map-im-zhaw-arcgis-online-portal-erstellen",
    "title": "Übung Story Map",
    "section": "",
    "text": "Melde Dich mit Deinen persönlichen Nutzerdaten auf dem ArcGIS Online Organisationskonto der ZHAW an: https://zhaw.maps.arcgis.com\nWechsle von der Startseite in das Register Inhalt. Erstelle bei Bedarf einen neuen Ordner für die Story Map (via Symbol «Neuen Ordner erstellen»).\nGehe auf «App Erstellen».\n\nWähle die Option «StoryMaps»\n\nÜber das Hilfemenü (oben rechts) hast Du Zugriff auf verschieden Links, unter denen Du Hilfe zur Erstellung einer Story Map erhältst.\n\nÖffne die Links jeweils in einem neuen Browser-Tab.\n\nÜberblick: Allgemein Information zu Story Maps.\nDokumentation: Lese was eine Story Map ist und informiere Dich, wie Du eine erste Story erstellen und veröffentlichen kannst.\n\nRessourcen: Hier findest Du Tipps, was Du bei der Erstellung von Story Maps beachten musst damit diese aussagekräftig und fesselnd sind. Beachte hier die Story «Nine steps to great storytelling» (https://storymaps.arcgis.com/stories/429bc4eed5f145109e603c9711a33407). Über folgendes Tutorial wird Dir vermittelt, wie Du deine Story erstellen kannst: Tutorial\nFAQ: Hier findest Du Antworten zu häufig gestellten Fragen.\n\nErstelle nun den ersten Entwurf einer Story Map. Über die Option «Entwerfen» kannst Du das Erscheinungsbild Deiner Story anpassen.\n\nÜber die Option «Vorschau» kannst Du dir eine Vorschau der erarbeiteten Story anzeigen lassen (am besten in einem neuen Browser-Tab öffnen).\n\nDie Option «Veröffentlichen» ermöglicht Dir, die Story zu veröffentlichen und die Freigabeeinstellungen anzupassen.\n\nErstelle nun Deine Story Map, fülle die Story mit Inhalten (Text, Bilder, Grafiken, Web Maps, Videos, Links etc.). Nutze selbständig die zur Verfügung stehenden Hilfe-Optionen (vorangehende Seite). Beachte: Bevor Du eine Web Map in eine Story Map integrieren kannst, muss diese vorgängig erstellt werden. Dabei müssen alle Inhalte auf die gleiche Art und Weise freigegeben werden.\nArbeite selbständig und sei kreativ. Probiere verschiedene Dinge aus. Beachte jeweils die Freigabeeigenschaften.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>Übung Story Map</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_1/4_Leistungsnachweis.html",
    "href": "E_WebGIS_1/4_Leistungsnachweis.html",
    "title": "Leistungsnachweis",
    "section": "",
    "text": "Es muss eine voll funktionsfähige Story Map erstellt werden, welche eine integrierte Web Map aus der vorherigen Übung enthält. Die Story Map soll in einer eigenen Gruppe veröffentlicht werden.\nGehe folgendermassen vor:\n\nErstelle in ArcGIS Online eine neue eigene Gruppe.\nBenenne die Gruppe als «Leistungsnachweis Vorname Name».\nDefiniere folgende Gruppeneigenschaften:\n\nWer kann diese Gruppe sehen? -&gt; Nur Gruppenmitglieder\nWer kann Mitglied dieser Gruppe sein? -&gt; Nur Mitglieder der eigenen Organisation\nWie können Personen dieser Gruppe beitreten? -&gt; Nach Einladung\nWer kann Inhalte beitragen? -&gt; Alle Gruppenmitglieder\n\nFüge Hanno Rahn (rahn_zhaw) und Dominic Lüönd (luoe_zhaw) deiner eigenen Gruppe «Leistungsnachweis Vorname Name» als Mitglied hinzu (via Benutzer einladen) ohne eine Bestätigung anzufordern.\nVeröffentliche deine Story Map für alle Mitglieder Deiner Gruppe «Leistungsnachweis Vorname Name».\n\nGib deine Lösung bis spätestens Freitag 17. Dezember 2023 auf Moodle ab. Lade hierzu den Link zu deiner Story Map hoch. Achte auf die korrekten Berechtigungen von Story Map und Web Map. Beide müssen diesselben Berechtigungen haben.",
    "crumbs": [
      "WebGIS I",
      "<span class='chapter-number'>67</span>  <span class='chapter-title'>Leistungsnachweis</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "",
    "text": "Übung 1: Vorbereitung\nWer allerdings lieber lokal arbeiten möchte kann dies gerne tun, mit den Kentnissen aus Programmieren I - III sollte das gut möglich sein. Jedoch müssen diese noch das Programm Quarto installieren, sowie das fehlende Package Folium via conda installieren.\npip install geopandas folium matplotlib mapclassify\nStartet nun das Kernel neu über Kernel -&gt; Restart.\nImportiert nun als erstes die zwei Packages geopandas und folium.\nModuleNotFoundError: No module named 'geopandas'\nLadet zudem die drei Datensätze wald.gpkg, zeckenstiche_original.gpkg und zeckenstiche_simuliert.gpkg mit der read_file Funktion von Geopandas in euer Jupyter Notebook.\nNameError: name 'gpd' is not defined",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-1-vorbereitung",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-1-vorbereitung",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "",
    "text": "Bitte ladet zuerst die Übungsdaten hier runter und entpackt diese.\nUm technische Probleme zu vermeiden, haben wir heute eine ZHAW-eigene Cloud Lösung vorbereitet. Es handelt sich dabei um eine gehostete Version von Jupyter Lab, auf welche ihr euch mit eurem ZHAW Benutzername und Passwort einloggen könnt: statistik-ide.zhaw.ch. Klickt auf + New Session und wählt JupyterLab und gebt einen Session Namen ein.\n\n\n\n\nWenn die Session geladen ist, könnt ihr eure Übungsdaten über den Upload Button hochladen. Öffnet anschliessend ein neues Jupyter Notebook und speichert es unter dem Namen visualisierung_zeckenstiche.ipynb.\nNun müssen wir noch die Packages installieren, die wir in dieser Session haben wollen. Statt conda verwenden wir jetzt allerdings pip, da die Serverlösung mit diesem Packagemanager arbeitet.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-2-base-map",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-2-base-map",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 2: Base Map",
    "text": "Übung 2: Base Map\nNun können wir unsere Karte bauen. Zuerst müssen wir eine Basiskarte erstellen, zu welcher wir dann die weiteren Layer hinzufügen können. Dazu nutzen wir nun Folium. Als Mittelpunkt der Karte wählen wir die WGS84 Koordinaten der Stadt Zürich (Zurich latitude: 47.36667, longitude: 8.55) aus.\n\n# Zurich latitude longitude: 47.36667, 8.55\nmap = folium.Map(location=[47.36667, 8.55], zoom_start = 13, tiles = \"cartodbpositron\")\n\nNameError: name 'folium' is not defined\n\n\nIhr könnt mit den Tiles und dem Zoom Level experimentieren. Information zu den Tiles findet ihr hier.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-3-wald-layer-hinzufügen",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-3-wald-layer-hinzufügen",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 3: Wald Layer hinzufügen",
    "text": "Übung 3: Wald Layer hinzufügen\nNun wollen wir die Waldflächen als unseren ersten Layer hinzufügen. Ihr habt die .explore() Funktion bereits kennengelernt. Sie verfügt über diverse interessante Attribute, welche wir nun benutzen wollen.\nDa unser Wald Datensatz aus zwei Zeilen mit Wald und nicht Wald besteht, müssen wir die Waldflächen zuerst noch rausfiltern.\nFolium kann nur das weltweite CRS WGS84 (EPSG:4326) verarbeiten und da der Geodataframe Wald das Schweizer CRS CH1903+ / LV95 (EPSG:2056) verwendet, müssen wir dieses mittels to_crs() transformieren, bevor wir ihn visualisieren können.\nTipp: Wenn ihr am Schluss des Commands ein ; hinzufügt, wird kein Output generiert. Somit wird nicht für jeden Layer den wir hinzufügen, eine Karte erstellt.\n\n# Wald zur Karte hinzufügen\nis_wald = wald[wald[\"Wald_text\"] == \"ja\"] # Selektieren nur den Wald\nis_wald.to_crs(4326).explore(\n    m = map,           # Fügt diesen Layer der Map map hinzu\n    color = \"green\",   # Der Layer wird grün dargestellt\n    tooltip = False,   # Es werden keine Daten angezeigt, wenn man über ein Objekt hovered.\n    highlight = False, # Das Objekt wird nicht hervorgehoben, wenn man darüber hovered.\n    name = \"Wald\"      # Der Name des Layers\n);",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-4-original-und-simulierter-zeckenstich-layer-hinzufügen",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-4-original-und-simulierter-zeckenstich-layer-hinzufügen",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 4: Original und simulierter Zeckenstich Layer hinzufügen",
    "text": "Übung 4: Original und simulierter Zeckenstich Layer hinzufügen\nNun wollen wir neben dem Wald Layer (Polygon) den originalen Zeckenstiche Layer (Punkte) hinzufügen. Kopiere dazu den unteren Code.\n\n# Original Zeckenstiche zur Karte hinzufügen\nzeckenstiche_original_gpd.to_crs(4326).explore(\n    m = map,                                     # Fügt diesen Layer der Map map hinzu\n    color = \"red\",                               # Der Layer wird rot dargestellt\n    marker_kwds = dict(radius = 1, fill = True), # Optionen für das Aussehen der Punkte\n    tooltip = \"ID\",                              # Beim Hovern über das Objekt wird die ID dargestellt\n    name = \"Original Zeckenstiche\"               # Der Name des Layers\n);\n\nNun wollen wir die simulierten Zeckenstiche darstellen. Als Vorlage könnt ihr den Code von oben kopieren. Erweitere die Funktion explore um folgende Logik:\n\nGerne würden wir die Spalte “Radius” mit der Farbvariation viridis visualisieren. Nutze hierfür die Attribute column und cmap.\nZudem soll die Legende des Layers dargestellt werden. Zudem wollen wir keine Colorbar als Legende haben. Nutze dafür die Optionen der Legende legend_kwds = dict(colorbar = False).\nIn den Tooltips sollen neben der ID noch der Radius und der Run dargestellt werden.\nNenne den Layer “Simulation Zeckenstiche”.\n\nWeitere Informationen zur explore Funktion findet ihr hier.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-5-layer-control-hinzufügen",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-5-layer-control-hinzufügen",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 5: Layer Control hinzufügen",
    "text": "Übung 5: Layer Control hinzufügen\nZum Abschluss wollen wir noch ein Layer Control hinzufügen, damit wir die verschiedenen Layer ein- und ausblenden können. Schaut dafür im User Guide von Folium und sucht nach der Layer Control Funktion und versucht diese eurer map hinzuzufügen. Zum Schluss kannst du die map aufrufen, damit diese Dargestellt wird. Das finale Produkt sollte wie folgt aussehen:\n\n\nNameError: name 'folium' is not defined\n\n\n\n\nmap\n\n\nNun ist unsere Map fertig. Inspiziert diese und spielt mit den Radien und Runs herum und versucht auch die Grössen und Farben der Points anzupassen, bis Ihr mit dem Resultat zufrieden seid.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-6-notebook-verschönern",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-6-notebook-verschönern",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 6: Notebook verschönern",
    "text": "Übung 6: Notebook verschönern\n\nInput\nUm unser Notebook zu verschönern werden wir das hilfreiche Tool Quarto verwenden. Dieses erlaubt es uns dynamischen Output zu generieren und ist eine Erweiterung zum klassischen Markdown. Mithilfe von Quarto kann euer Code in diverse Formate (PDF, HTML, ePub, und weitere) transformiert werden.\n\nVorbereiten von Quarto\nFügt ganz oben in eurem Notebook eine neue raw Cell ein und kopiert folgende Metadaten für Quarto. Dies bewirkt, dass euer Quarto Output ein Titel und Autor hat. Zudem sagen wir Quarto das wir mit Python3 arbeiten. Für unseren Ausgabeformat, welches HTML sein soll, definieren wir folgende global Optionen:\n\nembed-resources: true: Generiert ein einzelnes HTML File.\ncode-fold: true: Alle Code Cells werden eingeklappt.\n\n---\ntitle: Visualisierung Zeckenstiche\nauthor: Vorname Nachname\njupyter: python3\nformat:\n    html:\n        embed-resources: true\n        code-fold: true\n---\nQuarto gibt uns zudem die Möglichkeit unser File als Vorschau darzustellen. Öffne hierfür eine neue Konsole, indem du auf das grosse + in Jupyter Lab klickst. Wähle unter Other das Terminal aus. Mit dem Command quarto preview visualisierung_zeckenstiche.ipynb erhaltet ihr ein Preview im Internet Explorer.\n\n\nCell Options\nCell Options können dazu benutzt werden, um das Verhalten einer Cell zu verändern. Dabei werden diese Optionen mittels des Vorschubs #| am Anfang der Cell eingefügt. Wenn ihr eine Option für alle Cells haben wollt, könnt ihr diese als globale Optionen in den Metadaten von Quarto setzen (analog zu code-fold: true).\n#| echo: false\n#| code-summary: This is a Title for a collapsed Code Block\n\nPython Code...\nDie häufigsten Options sind:\n\neval: Soll die Code Cell ausgeführt werden.\necho: Soll der Code der Cell angezeigt werden.\noutput: Soll der Code Output dargestellt werden.\ncode-fold: Soll die Code Cell eingeklappt werden.\ncode-summary: Wenn code-fold auf true gesetzt ist kann ein Titel für die Code Cell gesetzt werden.\n\nEs gibt aber noch viele weitere Möglichkeiten (siehe hier).\n\n\nPage Layout\nMit Quarto könnt ihr euer Webseiten Layout relativ einfach anpassen. Ihr könnt zum Beispiel mit folgendem Code ein Grid erstellen, welcher aus zwei Spalten besteht. Eine Spalte ist 9 und die Zweite 3 breit. Die Gesamtbreite ist immer 12.\n::: {.grid}\n\n::: {.g-col-9}\nText 1\n:::\n\n::: {.g-col-3}\nText 2\n:::\n\n:::\nWeitere Möglichkeiten findet ihr hier.\n\n\nTabellen\nEine Tabelle muss nach folgender Markdown Syntax erstellt werden (siehe Quarto Tables):\n|Name |Gender|Age  |Origin | \n|-----|:-----|:---:|:-----:|\n|Jack |Male  |23   |USA    |\n|Susan|Female|22   |Canada |\n\n: Name der Tabelle {#tbl-names}\n\nDie erste Zeile ist die Tabellenüberschrift\nDie zweite Zeile beinhaltet Bindestriche “-” und optionalen Doppelpunkten “:”, um den Text in den Spalten auszurichten.\n\n:--- für die linke Ausrichtung\n:---: für die mittlere Ausrichtung\n---: für die rechte Ausrichtung\n\nDie weiteren Zeilen beinhalten der Tabelleninhalt.\nMit dem : unter der Tabelle kannst du den Namen der Tabelle definieren. Mit {#tbl-???} kannst du den Namen für einen Querverweise im Text erstellen. Dieser kann dann mittels @tbl-??? im Text aufrufen.\n\nEine praktische Hilfe für das Erstellen einer Tabelle ist der Tablesgenerator.\n\n\nBilder\nEin Bild kann ebenfalls via Markdown Syntax hinzugefügt werden. Zuerst folgt die Caption des Bildes, gefolgt vom Bild selbst. Mit {#fig-???} kannst du einen Querverweis für das Bild erstellen. Gleich wie bei der Tabelle kannst du ihn im Text mittels @fig-??? aufrufen.\n![Caption](../images/test.png){#fig-???}\nWeitere Information findet ihr auf Quarto.\n\n\n\nAufgabe\nSeht euch die Webseite an. Versucht nun die Struktur dieser Webseite so gut wie möglich in eurem Jupyter Notebook nachzubauen. Nutzt dafür die oben beschriebenen Methoden. Das Bild findet ihr in den Übungsdaten.\nBenutze zudem die Cell Options um euren Code sauber darzustellen. Nutzt dazu echo und output um unnötige Cell Codes und Outputs nicht auszugeben. Benenne zudem alle eingeklappten Code Cells sinnvoll mittels code-summary.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-7-notebook-in-html-konvertieren",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-7-notebook-in-html-konvertieren",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 7: Notebook in HTML konvertieren",
    "text": "Übung 7: Notebook in HTML konvertieren\nDamit wir nun unser Jupyter Notebook publizieren können, müssen wir davon einen HTML Output generieren.\nDazu nützen wir wieder Quarto in der Konsole. Aber anstelle des preview Commands nutzen wir den render Command, sprich quarto render visualisierung_zeckenstiche.ipynb. Da wir in den Quarto Metadaten als format HTML angegeben haben, wird Quarto ein HTML File generieren.\nÄndere zum Schluss den Namen des HTML Files auf index.html, damit später GitHub Pages das File automatisch als Startseite erkennt. Mit Rechtsklick auf das File kann über Download das HTML File heruntergeladen werden.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-8-github-und-publizieren",
    "href": "E_WebGIS_2/2_Uebung_Zeckenstiche.html#übung-8-github-und-publizieren",
    "title": "Übung Visualisierung Zeckenstiche",
    "section": "Übung 8: GitHub und Publizieren",
    "text": "Übung 8: GitHub und Publizieren\n\n\n\n\n\n\nHinweis\n\n\n\nGitHub ist eine webbasierte Plattform, die Hosting für Git-Repositories bereitstellt. Es bietet Tools für die Zusammenarbeit, Codeüberprüfung und Projektverwaltung. GitHub wird von Entwicklern weit verbreitet genutzt, um Open-Source-Projekte zu teilen, dazu beizutragen und zusammenzuarbeiten. Es bietet auch Funktionen wie die Verfolgung von Problemen (Issues) und Pull-Anfragen (Pull Requests).\n\n\n\nRegistriert euch mit eurer privaten Email Adresse auf GitHub.\nNun da ihr eingeloggt seid, könnt ihr euer Repository erstellen. Drücke hierfür oben rechts auf euren Avatar und wähle dann “Your repositories”. Klicke anschliessend auf das grüne Symbol “New”. Im neuen Fenster kannst du nun einen Namen für dein Repository definieren. Zudem kannst du die Sichtbarkeit des Repository anpassen, aber wir belassen es bei Public, damit wir dann auch das HTML File publizieren können. Schliesse das Ganze mit “Create repository” ab.\n\n\n\nRepository erstellen Schritt 1\n\n\n\n\n\nRepository erstellen Schritt 2\n\n\nNun hast du ein leeres Repository. Es gibt verschiedene Möglichkeiten nun Daten in dieses Repository zu kriegen. Am einfachsten ist aber das direkte Hochladen von Files. Klicke hierfür auf “uploading an existing file” und ziehe anschliessend das Jupyter Notebook und dein daraus generiertes HTML File (index.html) in den Explorer. Gib eine kurze Commit Beschreibung und klicke auf “Commit changes”.\n\n\n\n\n\n\n\n\n\nUpdate existierende Files\n\n\n\nWenn ihr nochmals Änderungen an den Files vornehmt, könnte ihr diese auf der Repository Seite über Add File vornehmen. Achte darauf das die Files den gleichen Namen haben, damit wird sichergestellt, dass das auf GitHub existierende File überschrieben wird.\n\n\n\n\nIhr seht nun eure Files im Repository. Geht nun auf Einstellungen um eure Webseite zu Publizieren.\n\nGeht auf Pages und setzt bei Branch die Einstellungen auf main und /root und klickt auf Save. Dies bewirkt, dass GitHub nun nach einem index.html in deinem main Branch sucht und aus diesem eine Webseite macht.\n\nDiesen Vorgang könnt ihr unter Actions finden. Sobald der orange Punkt zu einem grünen Häkchen wird, ist die Webseite fertig erstellt.\n\nKehr nun zurück zu Pages in den Settings. Ihr sollten nun eine URL sehen, auf welcher eure Webseite läuft.\n\nZum Abschluss könnt ihr diese URL im About des Repositorys hinzufügen. Dies macht es euch einfacher auf die Webseite zuzugreifen, da ihr nicht immer den Link in den Settings suchen müsst, sondern direkt in eurem Repository angezeigt wird.\n\nKopiere hierfür die URL und gehe auf den Code Tab und wählt dort das Rädchen neben dem About. Im Feld Webseite könnt ihr nun die URL reinkopieren. Speichert das mit “Save Changes”. Nun sieht ihr unter dem About eure Webseite.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>Übung Visualisierung Zeckenstiche</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html",
    "title": "(Optional) Übung Leaflet",
    "section": "",
    "text": "Übung 1: Erste Schritte mit HTML\nHTML Tutorial\nDie HyperText Markup Language (HTML) ist die Standard Markup Language für Inhalte, die in einem Webbrowser angezeigt werden sollen. Einfach ausgedrückt ist HTML die Sprache um den Inhalt einer Webseite zu definieren. Praktisch alle Webseiten basieren auf HTML.\nLass uns mit einem einfachen Editor eurer Wahl ein erstes einfaches HTML-Dokument erstellen.\nVorgeschlagene Editoren:\nÖffnet den Editor Eurer Wahl und erstellt eine grundlegende HTML-Struktur, indem ihr das folgende Codefragment einfügt.\nSpeichert das Dokument als index.html in Eurem Arbeitsverzeichnis ab und öffnet es in einem von euch bevorzugten Browser. Ihr solltet etwas ähnliches wie die folgende Abbildung sehen (Abbildung 69.1).\nAlle HTML-Dokumente müssen mit einer Dokumenttyp-Deklaration beginnen: &lt;!DOCTYPE html&gt;. Das HTML-Dokument selbst beginnt mit &lt;html&gt; und endet mit &lt;/html&gt;. Der sichtbare Teil des HTML-Dokuments liegt zwischen &lt;body&gt; und &lt;/body&gt;. In diesem Abschnitt haben wir unsere erste Überschrift &lt;h1&gt;&lt;/h1&gt; positioniert, sowie das HTML-Element &lt;p&gt;&lt;/p&gt;, welches einen Absatz innerhalb des Body-Abschnitts definiert. Mehr zum Thema fHTML-Elemente findet Ihr unter folgendem Link HTML Elemente.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-1-erste-schritte-mit-html",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-1-erste-schritte-mit-html",
    "title": "(Optional) Übung Leaflet",
    "section": "",
    "text": "Sublimetext\nNotepad++\nAtom\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Page title&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;My first heading&lt;/h1&gt;\n        &lt;p&gt;The first paragraph.&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\nAbbildung 69.1: Ihre Erste HTML-Seite",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-2-erste-schritte-mit-javascript-und-der-leaflet-bibliothek",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-2-erste-schritte-mit-javascript-und-der-leaflet-bibliothek",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 2: Erste Schritte mit JavaScript und der Leaflet-Bibliothek",
    "text": "Übung 2: Erste Schritte mit JavaScript und der Leaflet-Bibliothek\nJavaScript Tutorial\nIn der Welt der Webentwicklung ist HTML die Basis von allem, da es uns die Möglichkeit gibt, unsere Inhalte im Web darzustellen. Das, was die Dinge wirklich interessant und interaktiv macht, ist jedoch JavaScript. JavaScript ist im Moment die beliebteste Programmiersprache der Welt. Wenn HTML den Inhalt der Webseite definiert, definiert JavaScript dessen Verhalten. In HTML wird der JavaScript-Code zwischen den Tags &lt;script&gt; und &lt;/script&gt; in einem beliebigen Teil unseres HTML-Codes (Head oder Body) eingefügt.\nIn dieser Übung verwenden wir zur Entwicklung einer einfachen Webkarte die Library Leaflet. Leaflet ist die beliebteste Open-Source-JavaScript-Library für die Entwicklung interaktiver Webkarten. Ihr Hauptvorteil besteht darin, dass sie effizient auf allen wichtigen Desktop- und Mobilplattformen läuft und auf einer einfach zu verwendenden und gut dokumentierten Anwendungsprogrammierschnittstelle (API) basiert.\n\nGeht zurück in Euer HTML-Dokument, das Ihr in Übung 1 erstellt habt und löscht die Elemente &lt;h1&gt; und &lt;p&gt;, sodass nur noch der leere &lt;body&gt; übrig ist.\n\nAls nächsten Schritt werden wir ein &lt;div&gt;-Element für die Definition unserer Karte erstellen. Ein &lt;div&gt; HTML-Element ist ein allgemeiner Container, der keine Auswirkung auf den Inhalt oder das Layout hat, bis er in irgendeiner Art und Weise mit Hilfe einer Styling-Sprache angesteuert wird. Hier kommt der dritte wichtige Akteur der Webentwicklung ins Spiel. Nämlich die Sprache Cascading Style Sheets kurz CSS. CSS ist die Sprache, die verwendet wird, um ein HTML-Dokument zu gestalten und um zu beschreiben, wie unsere Inhalte im Web dargestellt werden sollen. In HTML wird der CSS-Code zwischen den Tags &lt;style&gt; und &lt;/style&gt; innerhalb der &lt;head&gt;-Tags eingefügt.\nCSS Tutorial\n\nErstellt ein div-Element, um die Karten-ID festzulegen, damit wir unsere Karte gestalten können.\n&lt;div id = \"map\"&gt;&lt;/div&gt;\nVerwendet den # CSS-Selektor CSS-Selektoren innerhalb der &lt;style&gt;&lt;/style&gt;-Tags, um unsere Karte auf Vollbild zu setzen, indem Ihr die absolute Positionierung in die Ecken setzen.\n&lt;style&gt;\n    #map {position: absolute; top: 0; bottom: 0; left: 0; right: 0;}\n&lt;/style&gt;\nNun werden wir die Leaflet-Bibliothek in unser File einbinden. Geht dazu auf Leaflet. Kopiert die folgenden zwei Codezeilen, welche die Leaflet CSS- und JavaScript-Dateien enthalten, in den Head-Bereich Eures HTML-Dokuments.\n&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\" integrity=\"sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=\" crossorigin=\"\" /&gt;\n&lt;script src=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.js\" integrity=\"sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=\" crossorigin=\"\"&gt;&lt;/script&gt;\nAls nächstes erstellen wir eine neue Variable (innerhalb von &lt;script&gt;&lt;/script&gt;), welcher wir unsere bereits definierte Karte zuweisen. Im Folgenden definieren wir das Zentrum unserer Karte sowie die gewünschte Schärfeebene.\nvar map = L.map('map', {center: [46.944, 8.028], zoom: 8}); // Focus on Switzerland\nUm einen geigneten Tile Layer zu finden, könnt Ihr die Website Maptiler durchforsten. Wählt eine Map die Euch gefällt aus, scrollt nach unten zu den Tiles und kopiert den Link (siehe Abbildung 69.2).\n\n\n\n\n\n\nAbbildung 69.2: Tile kopieren\n\n\n\n\nFügt den Link mit der Methode L.tileLayer() hinzu. Diese Methode von Leaflet erlaubt es uns den Tile Layer zu hosten (Leaflet-Erweiterungsmethoden). Aus Referenzierungsgründen ist es wichtig das Wir auch die Attribution hinzufügen (siehe Abbildung 69.3), welche am Ende der gleichen Webseite zu finden ist (Tipp: Ihr könnt diesen Schritt aus dem Code unten kopieren).\nFüge schliesslich alles mit der Methode addTo(map) zu unserer Karte hinzu.\n\n\n\n\n\n\nAbbildung 69.3: Kopieren der Attribution für die Nennung der Autoren\n\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nUm die Daten zu erhalten, müsst Ihr ein kostenloses Konto erstellen. (Ihr könnt dazu eure ZHAW-E-Mail-Konto verwenden).\n\n\nNachdem Ihr die oben genannten Schritte durchgeführt habt, sollte Euer Code wie folgt aussehen:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\" integrity=\"sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=\" crossorigin=\"\" /&gt;\n        &lt;script src=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.js\" integrity=\"sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=\" crossorigin=\"\"&gt;&lt;/script&gt;\n        &lt;style&gt;\n            #map {position: absolute; top: 0; bottom: 0; left: 0; right: 0;}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id = \"map\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var map = L.map('map', {center: [46.944, 8.028],zoom: 8});\n            L.tileLayer('https://api.maptiler.com/maps/streets-v2/256/{z}/{x}/{y}.png?key=4X87DmrzALHNsvjVPyhW', {attribution: '&lt;a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"&gt;&copy; MapTiler&lt;/a&gt; &lt;a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"&gt;&copy; OpenStreetMap contributors&lt;/a&gt;'}).addTo(map);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\nSpeichert das Dokument (index.html) und öffnet es in Eurem bevorzugten Browser. Das Ergebnis sollte ähnlich aussehen wie Abbildung 69.4.\n\n\n\n\n\n\n\nAbbildung 69.4: Interaktive Webkarte mit Leaflet JavaScript-Bibliothek",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-3-geojson-datei-zur-webkarte-hinzufügen",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-3-geojson-datei-zur-webkarte-hinzufügen",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 3: GeoJson-Datei zur Webkarte hinzufügen",
    "text": "Übung 3: GeoJson-Datei zur Webkarte hinzufügen\nGeoJson ist ein sehr verbreitetes Dateiformat zur Kodierung einer Vielzahl von geografischen Datenstrukturen. In der Webkartenentwicklung können GeoJson Variablen innerhalb einer JavaScript-Datei zugewiesen werden.\n\nLadet von Moodle die Übungsdateien herunter und speichert alles im gleichen Ordner, in dem Euer Dokument index.html liegt. Einer der Hauptvorteile von JavaScript ist, dass es sich gut in ein HTML-Dokument integrieren lässt. Mit den Tags `&lt;script&gt;&lt;/script&gt; können wir beliebig viele JavaScript-Dateien mit dem Haupt-HTML-Dokument verknüpfen. Dies werden wir mit der Datei kantons.js tun.\nVerknüpft die Datei kantons.js im Head Eueres Dokuments (nach dem Leaflet Script) wie folgt:\n&lt;script src=\"kantons.js\"&gt;&lt;/script&gt;\nÖffnet nun die Datei kantons.js und kopiert den Namen der Variable, in der die Geojson-Daten gespeichert sind. Fügt diese anschliessend wie folgt zu Eurer Karte hinzu:\nL.geoJSON(nameOfTheVariable).addTo(map); \n\nNach dem Speichern und Aktualisieren Eures index.html-Dokuments sollte Eure Karte wie Abbildung 69.5 aussehen.\n\n\n\n\n\n\nAbbildung 69.5: Interaktive Webkarte mit den Kantonen der Schweiz",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-4-farbe-in-die-webkarte-einbringen",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-4-farbe-in-die-webkarte-einbringen",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 4: Farbe in die Webkarte einbringen",
    "text": "Übung 4: Farbe in die Webkarte einbringen\nDas Ziel dieser Übung ist die Entwicklung einer interaktiven Choroplethenkarte. Jeder der räumlichen Einheiten (Kanton der Schweiz), wird eine Farbe zugewiesen. Jede Farbe basiert dabei auf einem spezifischen Geojson-Attribut, in unserem Fall die Bevölkerungszahl jedes Kantons.\n\nÖffnet erneut die Datei kantons.js und untersuchet die Geojson-Datei. Suchet nach dem Attribut welches die Bevölkerungszahl der Kantone representiert (siehe Abbildung 69.6).\n\n\n\n\n\n\n\nAbbildung 69.6: JavaScript-Datei mit einer Sammlung von geografischen Datenstrukturen im Geojson-Format\n\n\n\n\nAls Nächstes werden wir die folgenden beiden Funktionen (getColor(d), style(feature)) verwenden, um jedem Kanton eine Farbe auf der Grundlage seiner Bevölkerungszahl zuzuweisen. Kopiert die folgenden Funktionen und fügt diese nach der map-Variablen in Euer Dokument ein.\nfunction getColor(d) {\n    return d &gt; 1000000 ? '#084594' :\n    d &gt; 500000 ? '#2171b5' :\n    d &gt; 200000 ? '#4292c6' :\n    d &gt; 100000 ? '#6baed6' :\n    d &gt; 50000 ? '#9ecae1' :\n    d &gt; 20000 ? '#c6dbef' :\n    d &gt; 10000 ? '#deebf7' :\n    '#f7fbff';\n}\n\nfunction style(feature) {\n    return {\n        // using the population property as argument\n        fillColor: getColor(feature.properties.Bevolkerung),\n        weight: 2,\n        opacity: 1,\n        color: 'white',\n        dashArray: '3',\n        fillOpacity: 0.7\n    };\n}\nDie erste Funktion (getColor(d)) gibt das Argument d als Farbcode (z.B. #9ecae1) zurück, nachdem dessen Wert überprüft wurde. Wenn d zum Beispiel grösser als 1’000’000 ist, erhalten wir die Farbe #084594.\nDie Funktion (getColor(d)) wird dann innerhalb der zweiten Funktion (style(feature)) aufgerufen und nimmt als Argument das Attribut Bevolkerung der Variable kantons, die in der Datei kantons.js gespeichert ist. Schliesslich weist die Funktion style(feature) als Füllfarbe (fillColor) das Ergebnis der Funktion getColor(d) zu.\nWir fügen nun als Style-Eigenschaft unseres L.geoJson-Objekts die Funktion style(feature) wie folgt hinzu:\nL.geoJSON(kantons, {style: style}).addTo(map); \n\nNachdem Euer Dokument gespeichert und Euer Browser aktualisiert ist, sollte Eure Karte wie Abbildung 69.7 aussehen.\n\n\n\n\n\n\nAbbildung 69.7: Web Interaktive Choroplethenkarte mit den Kantonen der Schweiz",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-5-hinzufügen-von-interaktion-zur-webkarte",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-5-hinzufügen-von-interaktion-zur-webkarte",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 5: Hinzufügen von Interaktion zur Webkarte",
    "text": "Übung 5: Hinzufügen von Interaktion zur Webkarte\nNachdem wir die Choroplethenkarte entwickelt haben, wäre es schön, wenn wir ihr etwas Interaktivität geben könnten. Dazu verwenden wir eine der wichtigsten Funktionen von JavaScript, den Event Listener. Kurz gesagt definieren Event Listener die Art und Weise, wie die Endbenutzer mit dem Webinhalt interagieren können. Der wohl bekannteste ist der Onclick-Listener. Onclick-Listener definieren, was passiert, wenn der Benutzer irgendwo auf der Seite klickt. In unserem Fall ist es unser Ziel, dass wir auf jede räumlichen Einheiten (Kantone) in unserer Karte klicken können und wir im Gegenzug möglichst viele Informationen zurückerhalten. Genauer gesagt wollen wir, dass bei jedem Klick auf einen Kanton der Name und die Bevölkerungszahl auf dem Bildschirm angezeigt wird.\nIn einem ersten Schritt müssen wir sicherstellen, dass unsere GeoJSON-Ebene über eine Variable zugänglich ist, indem wir sie vor unseren Listenern definieren.\n\nErstellt eine Variable mit dem Namen geojson, direkt nach der Variable map wie folgt:\nvar map = L.map(\"map\", {center: [46.984, 8.950], zoom:7}); // focus on Switzerland\nvar geojson;\nZuerst definieren wir, was bei einem Klick passieren soll. In userem Fall soll ein Popup mit dem Namen und der Bevölkerungszahl des Kontons erscheinen. Die Funktion sieht wie folgt aus:\nfunction showInfo(e) {\n    geojson.bindPopup(\"Kanton: \" + \" \" + e.target.feature.properties.NAME + \n    '&lt;/b&gt;&lt;br /&gt;' + \n    \"Bevolkerung: \" + e.target.feature.properties.Bevolkerung);\n}\nIn der obigen Funktion (showInfo(e)) verknüpfen wir mit unserer Geojson-Variable ein Popup-Objekt (Leaflet popup), in das wir einen Text sowie die Attribute NAME und Bevolkerung jedes der in unserem e.target-Objekt enthaltenen räumlichen Merkmale einbinden. In unserem Fall ist das e.target-Objekt die Variable kantons (gespeichert in der Datei kantons.js). (Mehr über e.target)\nAls nächsten Schritt verwenden wir die Funktion onEachFeature, um die Funktion showInfo(e) mit dem onclick-Listener zu verknüpfen. Dies ist die Standardfunktion zur Verknüpfung der JavaScript-Listener mit den jeweiligen Funktionen, die für die Ausführung einer bestimmten Aufgabe erstellt wurden. Wir hätten zum Beispiel eine andere Funktion definieren können, die jedes Mal aufgerufen wird, wenn wir den Mauszeiger über ein bestimmtes Element unserer HTML-Struktur bewegen. In unserem Fall definieren wir den onclick listener wie folgt:\nfunction onEachFeature(feature, layer) {\n    layer.on({\n        click: showInfo\n    });\n}\nDer letzte Schritt besteht darin, unsere GeoJSON-Ebene anzupassen, indem wir ihr die Option onEachFeature hinzufügen (L.geoJson documentation).\ngeojson = L.geoJson(kantons, {\n    style: style,\n    onEachFeature: onEachFeature\n}).addTo(map);\n\nNachdem Ihr Eure HTML-Struktur aktualisiert habt, speichert Eure Datei index.html und aktualisiert den Browser. Versucht nun auf der Karte herumzuklicken und schaut was passiert. Ihr solltet etwas ähnliches sehen wie Abbildung 69.8.\n\n\n\n\n\n\nAbbildung 69.8: Web Interaktive Choroplethenkarte mit den Kantonen der Schweiz (mit Interaktivität)",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-6-der-webkarte-eine-legende-hinzufügen",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#übung-6-der-webkarte-eine-legende-hinzufügen",
    "title": "(Optional) Übung Leaflet",
    "section": "Übung 6: Der Webkarte eine Legende hinzufügen",
    "text": "Übung 6: Der Webkarte eine Legende hinzufügen\nUm eine Legende zu unserer Webkarte hinzuzufügen, werden wir JavaScript und CSS verwenden.\n\nVerwendet die beiden verbleibenden Dateien control.js und control.css (zu finden im Ordner data). Speichert diese beiden Dateien in Eurem Arbeitsverzeichnis (der Pfad, in dem sich auch index.html und kantons.js befinden)\nVerknüpft diese beiden Dateien mit Eurem Haupt-HTML-Dokument am Ende des Body-Abschnitts wie folgt.\n&lt;!-- Linking the js and css code for the legend --&gt;\n&lt;script src=\"control.js\"&gt;&lt;/script&gt;\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"control.css\"/&gt;\nSpeichert die Datei index.html und aktualisieren die Browserseite. Die Webseite sollte nun wie Abbildung 69.9 aussehen.\n\n\n\n\n\n\n\nAbbildung 69.9: Web Interaktive Choroplethenkarte mit den Kantonen der Schweiz (Endgültige Version)\n\n\n\nÖffnet die beiden Dateien, die Ihr zuletzt zur Karte hinzugefügt habt, und versucht, den darin enthaltenen Code zu interpretieren. Versucht, etwas zu ändern und seht anschliessend, wie sich diese Aktion auf Eure Karte auswirkt.\nGlückwunsch!! Ihr habt soeben Eure erste voll funktionsfähige interaktive Webkarte erstellt und dabei nur die grundlegenden Webtechnologien verwendet. Man könnte dieses HTML nun zum Beispiel über Netlify Drop Online zur Verfügung stellen.",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "E_WebGIS_2/3_Uebung_Leaflet.html#endgültige-lösung",
    "href": "E_WebGIS_2/3_Uebung_Leaflet.html#endgültige-lösung",
    "title": "(Optional) Übung Leaflet",
    "section": "Endgültige Lösung",
    "text": "Endgültige Lösung\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\" integrity=\"sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=\" crossorigin=\"\" /&gt;\n        &lt;script src=\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.js\" integrity=\"sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=\" crossorigin=\"\"&gt;&lt;/script&gt;\n        &lt;script src=\"kantons.js\"&gt;&lt;/script&gt;\n        &lt;style&gt;\n            #map {position: absolute; top: 0; bottom: 0; left: 0; right: 0;}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id = \"map\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var map = L.map('map', {center: [46.944, 8.028],zoom: 8});\n            var geojson;\n            // function for coloring the cantons based on their population property\n            \n            function getColor(d) {\n                return d &gt; 1000000 ? '#084594' :\n                d &gt; 500000 ? '#2171b5' :\n                d &gt; 200000 ? '#4292c6' :\n                d &gt; 100000 ? '#6baed6' :\n                d &gt; 50000 ? '#9ecae1' :\n                d &gt; 20000 ? '#c6dbef' :\n                d &gt; 10000 ? '#deebf7' :\n                '#f7fbff';\n            }\n            \n            function style(feature) {\n                return {\n                    fillColor: getColor(feature.properties.Bevolkerung), // using the population property as argument\n                    weight: 2,\n                    opacity: 1,\n                    color: 'white',\n                    dashArray: '3',\n                    fillOpacity: 0.7\n               };\n           }\n           \n            function showInfo(e) {\n                geojson.bindPopup(\"Kanton: \" + \" \" + e.target.feature.properties.NAME + '&lt;/b&gt;&lt;br/&gt;' + \"Bevolkerung: \" + e.target.feature.properties.Bevolkerung);\n            }\n            \n            function onEachFeature(feature, layer) {\n                layer.on({\n                    click: showInfo\n                });\n            }\n            \n            L.tileLayer('https://api.maptiler.com/maps/streets-v2/256/{z}/{x}/{y}.png?key=4X87DmrzALHNsvjVPyhW', {attribution: '&lt;a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\"&gt;&copy; MapTiler&lt;/a&gt; &lt;a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\"&gt;&copy; OpenStreetMap contributors&lt;/a&gt;'}).addTo(map);\n\n            geojson = L.geoJson(kantons, {\n                style: style,\n                onEachFeature: onEachFeature\n            }).addTo(map);\n        &lt;/script&gt;\n        \n        &lt;!-- Linking the js and css code for the legend --&gt;\n        &lt;script src=\"control.js\"&gt;&lt;/script&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"control.css\"/&gt;\n    &lt;/body&gt;\n&lt;/html&gt;",
    "crumbs": [
      "WebGIS II",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>(Optional) Übung Leaflet</span>"
    ]
  },
  {
    "objectID": "A_Unsicherheit/1_Einleitung.html",
    "href": "A_Unsicherheit/1_Einleitung.html",
    "title": "Unsicherheit",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nDu bist in der Lage bei zukünftigen GIS Arbeiten mit der Unsicherheit von Punktdaten umzugehen.\nDu kannst reale räumliche Objekte dahin beurteilen, ob diese grenzscharf oder nur mit einer Unschärfe abgebildet werden können.\nDu kannst mit Fuzzy-Tallness umgehen und diese definieren.\nDu kannst unscharfe Phänomene in deinen zukünftigen Projekten berücksichtigen und deren Unschärfe in den Geoverarbeitungsprozess integrieren und auswerten.\nDu kannst ein Modell mit ModelBuilder erstellen und ausführen.",
    "crumbs": [
      "Unsicherheit"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/1_Einleitung.html",
    "href": "B_Datenbanken_1/1_Einleitung.html",
    "title": "Datenbanken I",
    "section": "",
    "text": "Ausgangslage\nDie Gärten und Grünanlagen prägen das Bild des Campus Grüental. Eine grosse Vielfalt an verschiedenen einheimischen und exotischen Pflanzenarten lädt zum Verweilen ein. Mitarbeiter und Studierende nutzen den grünen Raum zur Erholung, zum Miteinander und zum Lernen. Nicht nur in den Sommermonaten ist das offene Areal des Campus ein Erlebnis für alle. Für die individuelle Pflege und Wartung der Gärten bedarf es sehr guter Planung. Als Datenbank Spezialist werden Sie beauftragt eine Datenbanklösung zur Verwaltung der Campus Pflanzenwelt zu entwickeln.",
    "crumbs": [
      "Datenbanken I"
    ]
  },
  {
    "objectID": "B_Datenbanken_1/1_Einleitung.html#ausgangslage",
    "href": "B_Datenbanken_1/1_Einleitung.html#ausgangslage",
    "title": "Datenbanken I",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nSie lernen ein vorgegebenes Textmodell zu lesen, zu interpretieren und dazu die richtigen Fragen zu stellen, um fehlende Antworten zu bekommen.\nSie können aus dem Textmodell relevante Objekte, Attribute und Beziehungen extrahieren.\nSie können auf der Grundlage eines bestehenden Textmodells ein konzeptuelles Datenmodell mit Hilfe eines ER-Diagramms entwickeln.\nSie können das konzeptuelle Datenmodell zu einem logischen Datenmodell weiter entwickeln, indem Sie Tabellen ableiten und Attribute, Schlüssel und Kardinalitäten identifizieren.",
    "crumbs": [
      "Datenbanken I"
    ]
  },
  {
    "objectID": "B_Datenbanken_2/1_Einleitung.html",
    "href": "B_Datenbanken_2/1_Einleitung.html",
    "title": "Datenbanken II",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nSie können ein bestehendes logisches Modell auf Datenintegrität prüfen und Konsistenzfehler korrigieren.\nSie können auf der Grundlage eines bestehenden Datenmodells mit Hilfe von pgAdmin und ArcGIS Pro auf eine Server Datenbank zugreifen.\nSie können eine bestehende Server Datenbank mit Hilfe von pgAdmin und ArcGIS Pro mit Daten befüllen.\nSie kennen die grundlegenden Mechanismen von Datenbank-Versionierung und können diese in ArcGIS Pro anwenden.",
    "crumbs": [
      "Datenbanken II"
    ]
  },
  {
    "objectID": "B_Datenbanken_3/1_Einleitung.html",
    "href": "B_Datenbanken_3/1_Einleitung.html",
    "title": "Datenbanken III",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nSie lernen die Abfragesprache SQL kennen.\nSie können Abfragen in SQL formulieren und dabei auch räumliche PostGIS Funktionen nutzen.\nSie lernen SQL‐Abfragen mit ArcGIS Pro Werkzeugen zu visualisieren.",
    "crumbs": [
      "Datenbanken III"
    ]
  },
  {
    "objectID": "C_Programmieren_1/1_Einleitung.html",
    "href": "C_Programmieren_1/1_Einleitung.html",
    "title": "Programmieren I",
    "section": "",
    "text": "Vorbereitung\nIm Modul Angewandte Geoinformatik benutzen wir Python mit Jupyter Lab. Mit der Installation von ArcGIS sollte die nötige Software bereits installiert sein. Es muss also lediglich getestet werden, ob dies auch wie erwartet funktioniert. Bitte führt die Instruktionen unter dem Punkt Mit ArcGIS Installation durch.\nWer lieber auf einem anderen Betriebssystem als Windows arbeiten möchte, sollte es für den Teil Programmieren I - III auch können. In diesem Fall braucht es aber ein bisschen Vorbereitung. Befolgt in diesem Fall die Schritte unter dem Punkt Ohne ArcGIS Installation durch.",
    "crumbs": [
      "Programmieren I"
    ]
  },
  {
    "objectID": "C_Programmieren_1/1_Einleitung.html#vorbereitung",
    "href": "C_Programmieren_1/1_Einleitung.html#vorbereitung",
    "title": "Programmieren I",
    "section": "",
    "text": "Mit ArcGIS Installation (v.a. Windows Nutzer)\nUm zu testen, ob die Installation bei Dir auch funktioniert, musst Du die paar Schritte im Video (s.u.) ausführen:\n\nPython Command Prompt suchen und starten\nMittels dem Befehl cd in dein Persönliches Laufwerk wechseln (cd C:\\Users\\DeinUserName\\Desktop, siehe dazu diesen Video)\nMittels des Befehls jupyter lab das Programm Juypter Lab starten\nMit Klick auf den Button ein neues Notebook erstellen\n\n\n\nOhne ArcGIS Installation (v.a. Mac / Linux Nutzer)\nWer keine ArcGIS installation hat, sollte folgende Software installieren:\n\nÜberprüfe, ob Python &gt; 3.9 installiert ist. Tippe dafür folgenden Befehl in den Terminal: bash     python3 --version\nWenn die Python nicht vorhanden oder die Version älter / kleiner als 3.9 ist, installiert eine aktuelle Version von Python: https://www.python.org/downloads/\nInstalliert Miniconda von dieser Website: https://docs.conda.io/projects/miniconda/en/latest/\nTippt folgende Befehle in der Commandozeile ein:\nconda create --name geopython1\nconda activate geopython1   # Windows nutzer: conda activate geopython1\nconda install -c conda-forge jupyterlab pandas",
    "crumbs": [
      "Programmieren I"
    ]
  },
  {
    "objectID": "C_Programmieren_1/1_Einleitung.html#daten",
    "href": "C_Programmieren_1/1_Einleitung.html#daten",
    "title": "Programmieren I",
    "section": "Daten",
    "text": "Daten\nIm Kurs werdet ihr nachstehende Datensätze benötigen, die ihr im Moodlekurs unter Programmieren I → Datensätze herunterladen könnt.\n\n\n\nTabelle 1: Datensätze für den Teil “Programmieren I - III”\n\n\n\n\n\n\n\n\n\nDatensatz (inkl. Link)\nBeschreibung\n\n\n\n\nzeckenstiche.csv\nEine CSV mit 10 Zeckenstich-Meldungen im Kanton Zürich\n\n\nzeckenstiche_full.csv\nEine CSV mit 1’076 Zeckenstich-Meldungen im Kanton Zürich\n\n\nwald.gpkg\nEin Geodatensatz mit einem flächendeckenden (lückenlosen) Polygon, welche den Kanton Zürich in “Wald” und “nicht Wald” unterscheidet\n\n\n\n\n\n\n\n\n\n\n\n\nÜbungsziele\n\n\n\n\nPython kennen lernen, erste Interaktionen mit Python durch die Commandline\nErste Erfahrungen mit JupyterLab sammeln\nDie wichtigsten Datentypen in Python kennen lernen (bool, str, int, float, list, dict)\nPandas DataFrames kennen lernen und einfache Manipulationen durchführen",
    "crumbs": [
      "Programmieren I"
    ]
  },
  {
    "objectID": "C_Programmieren_2/1_Einleitung.html",
    "href": "C_Programmieren_2/1_Einleitung.html",
    "title": "Programmieren II",
    "section": "",
    "text": "Letzte Woche habt ihr die wichtigsten Datentypen in Python kennen gelernt und sowohl den Command Prompt wie auch Juypter Notebook verwendet. Diese Woche werden wir Python Module genauer beleuchten und dabei conda kennenlernen. Zudem widmen wir uns dem Erstellen von Funktionen (Functions), Fallunterscheidungen (if und else) sowie dem Erstellen von Zufallszahlen.\n\n\n\n\n\n\nÜbungsziele\n\n\n\n\nConda verstehen und beherrschen\nPython Module verstehen\nFunctions kennenlernen und beherrschen\nFunction auf eine ganze Spalte einer DataFrame anwenden können.",
    "crumbs": [
      "Programmieren II"
    ]
  },
  {
    "objectID": "C_Programmieren_3/1_Einleitung.html",
    "href": "C_Programmieren_3/1_Einleitung.html",
    "title": "Programmieren III",
    "section": "",
    "text": "Heute widmen wir uns zwei grossen Themen bevor wir uns an die Umsetzung der Monte Carlo Simulation wenden.\nIm ersten Thema geht es um for Loops, mit denen wir eine Aufgabe mehrfach (“Iterativ”) durchzuführen können. Ein for Loop ist ein sehr wichtiges und hilfreiches Werkzeug das man unbedingt kennen sollte. Wir werden for loops brauchen um Zeckenstiche zu simulieren, indem wir die bestehenden Meldungen x-fach zufällig verschieben. Das Thema for loops behandeln wir in Einführung in for loop, Basic for loop und Advanced for loops.\nBeim zweiten Thema geht es um GIS. Wir haben bisher mit Daten gearbeitet die eine Rauminformation beinhalten, die Zeckenstiche haben x/y-Koordinaten. Diese Rauminformation haben wir aber nicht als solche behandelt, wir haben die Koordinaten als Zahlen eingelesen und uns nicht gross darum geschert, dass es sich dabei um spezifische Punkte in der Schweiz handelt. Heute werden wir dies ändern müssen da uns eine räumliche Abfrage bevorsteht: Wir wollen nämlich wissen, welche Zeckenstiche sich im Wald befinden. Dadurch lernen wir eine neue Erweiterung kennen und sehen, was für räumliche Operationen in Python möglich sind. Das Thema behandeln wir in Input: GIS in Python, Räumliche Operationen und Spatial Joins.\n\n\n\n\n\n\nÜbungsziele\n\n\n\n\nIhr kennt for-Loops und könnt sie anwenden\nIhr seht, was mit räumlichen Operationen in Python möglich ist und kennt ein Tool, welches dazu notwendig ist\nIhr könnt räumliche Operationen (spatial join, overlay) in Python umsetzen\nIhr könnt summary Statistiken (mit groupby/count) aus DataFrames extrahieren",
    "crumbs": [
      "Programmieren III"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_1/1_Netzwerkanalyse_I.html",
    "href": "D_Netzwerkanalyse_1/1_Netzwerkanalyse_I.html",
    "title": "Netzwerkanalyse I",
    "section": "",
    "text": "Die Lerneinheit vermittelt die Grundlagen bei der Verwendung von Netzwerk-Geodaten. Die Anwendungsfelder reichen von Streckenfindung und Reisezeitberechnungen zu Energienetzwerk-Systeme bis hin zu Gewässernetzen in der Hydrologie. Diese Lerneinheit vermittelt die dafür relevanten Grundlagen aus der Graphentheorie und knüpft dabei an die bekannten Grundlagen der Vektordatenmodellierung (Definitionen, Elemente von Graphen, Eigenschaften von Graphen, Bäume) an. Zudem werden im theoretischen Teil Netzwerkmasse, insbesondere Zentralitätsmasse nähergebracht. Der praktische Teil basiert auf der Einführung und Verwendung von QGIS als Alternative zu den ESRI-Produkten.\n\n\n\n\n\n\nÜbungsziele\n\n\n\n\nEinfache GIS-Operationen mit QGIS durchführen können (Clip, Reproject, Abfrage der Attributtabelle, Symbolisierung, Export als jpg)\nSchnittstelle zwischen QGIS und anderen GIS-Software am Beispiel GRASS kennenlernen\nErste Netzwerkoperationen mit QGIS/GRASS GIS durchführen\nNetzwerk-Zentralitätsmasse verstehen und für einfache Netzwerkdaten berechnen können",
    "crumbs": [
      "Netzwerkanalyse I"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_2/1_Einleitung.html",
    "href": "D_Netzwerkanalyse_2/1_Einleitung.html",
    "title": "Netzwerkanalyse II",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nIn einem gegebenen Netzwerk kürzeste Pfade mit QGIS berechnen können\nWeitere GRASS GIS Werkezeuge innerhalb von QGIS ansteuern können\nVerschiedene QGIS / GRASS GIS Tools kennenlernen und deren Outputs interpretieren können\nEigene einfache Vektor-Datensätze erstellen können, resp. Punkte von Hand digitalisieren können\nAlternative, professionelle Routing Services kennenlernen und ausserhalb herkömmlicher Services (z.B. Google) nutzen",
    "crumbs": [
      "Netzwerkanalyse II"
    ]
  },
  {
    "objectID": "D_Netzwerkanalyse_3/1_Einleitung.html",
    "href": "D_Netzwerkanalyse_3/1_Einleitung.html",
    "title": "Netzwerkanalyse III",
    "section": "",
    "text": "Angenommen Sie sind auf Wohnungssuche in Wädenswil. Dabei gilt es nebst dem Budget viele wichtige raumgebundene Variablen zu berücksichtigen, dazu verwenden Sie natürlich QGIS. Sie wollen drei Kriterien untersuchen:\n\nLaufdistanz zur nächsten Entsorgungsstelle\nErschliessung an die öffentlichen Verkehrsmittel (unter Berücksichtigung des Fahrplans)\nDistanz zur Durchfahrtsstrasse\n\nWir werden für jeden dieser drei Kriterien einen Rasterdatensatz kreieren, den wir zum Schluss miteinander verrechnen können. So finden wir den optimalen Standort unter der Berücksichtigung aller drei Kriterien. Starten Sie dazu QGIS und laden Sie folgende Daten in das Projekt:\n\nStrassennetz Wädenswil (“osm_highway_prepared.gpkg”, siehe Tabelle 55.1)\nEntsorgungsstellen Wädenswil (“abfallentsorgung_waedenswil.gpkg”, siehe Tabelle 55.1)\nGemeindegrenze Wädenswil (“Gemeinde_Waedenswil.gpkg”, siehe Tabelle 55.1)\nOptional: OSM Hintergrundkarte grau eingefärbt (siehe Übung 3.1: Projekt vorbereiten)\n\n\n\n\n\n\n\nÜbungsziele\n\n\n\n\nSie sind in der Lage, einfache Reisezeitberechnungen in QGIS selber durchzuführen.\nSie erweitern Ihr Skillset zur Umwandlung von verschiedenen Geodatentypen (Vektor zu Raster, Raster zu Vektor, Linien zu Punkte, usw.)\nSie können eine einfache Multi-Kriterien-Analyse (MCA) mit Raster-Daten in QGIS selbständig durchführen.\nSie können einfache Map Overlay-Operationen in QGIS selber ausführen.",
    "crumbs": [
      "Netzwerkanalyse III"
    ]
  },
  {
    "objectID": "E_WebGIS_1/1_Einleitung.html",
    "href": "E_WebGIS_1/1_Einleitung.html",
    "title": "WebGIS I",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nDu bist in der Lage auf dem ArcGIS Online Organisationskonto Deine Inhalte zu organisieren und die Freigabeeigenschaften von Inhalten zu ändern.\nDu kannst in ArcGIS Pro eine Karte vorbereiten, eine Zeitanimation aktivieren und ArcGIS Pro Karten auf einem ArcGIS Online Organisationskonto als Web Maps veröffentlichen.\nDu kannst eine Web Map zielgerichtet gestalten und basierend auf bestehenden Web Maps neue Web Map Applikationen erstellen.\nDu weisst, wie Du eine Story Map erstellen und diese mit Inhalten füllen kannst.",
    "crumbs": [
      "WebGIS I"
    ]
  },
  {
    "objectID": "E_WebGIS_2/1_Einleitung.html",
    "href": "E_WebGIS_2/1_Einleitung.html",
    "title": "WebGIS II",
    "section": "",
    "text": "Übungsziele\n\n\n\n\nDu kannst eine Map mit mehreren Layern und einer Legende in Python erstellen.\nDu kannst dein Jupyter Notebook mittels Chunk Options und weiteren Tools verschönern.\nDu kennst Github und kannst ein Repository erstellen, Files hochladen und diese publizieren.\nOptional: Du kennst die grundlegenden Webtechnologien wie HyperText Markup Language (HTML), JavaScript und Cascading Style Sheets (CSS).\nOptional: Du hast dich mit Leaflet, der beliebtesten Open-Source-JavaScript-Bibliothek, vertraut gemacht.\nOptional: Du kannst das GeoJson-Dateiformat verwenden.",
    "crumbs": [
      "WebGIS II"
    ]
  }
]